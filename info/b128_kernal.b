SYSTEM	= 0             ;CBM SYSTEM =0  PET SYSTEM =1
SYSAGE	= 0             ;MONITOR = 0   CASSETTE = 1
SYSSIZ	= 0             ;NO PACKING = 0  PACKING = 1
; -------------------------------------------------------------
; ##### DISCLAIMER #####
;***************************************
;*                                     *
;* KK  K EEEEE RRRR  NN  N  AAA  LL    *
;* KK KK EE    RR  R NNN N AA  A LL    *
;* KKK   EE    RR  R NNN N AA  A LL    *
;* KKK   EEEE  RRRR  NNNNN AAAAA LL    *
;* KK K  EE    RR  R NN NN AA  A LL    *
;* KK KK EE    RR  R NN NN AA  A LL    *
;* KK KK EEEEE RR  R NN NN AA  A LLLLL *
;*                                     *
;***************************************
;
;*****LISTING DATE --17:00 31 MAY  1983
;
;***************************************
;* CBM KERNAL                          *
;*   MEMORY AND I/O DEPENDENT ROUTINES *
;* DRIVING THE HARDWARE OF THE         *
;* FOLLOWING CBM MODELS:               *
;*   P-SERIES (5XX) & B-SERIES (7XX)   *
;* COPYRIGHT (C) 1983 BY               *
;* COMMODORE BUSINESS MACHINES (CBM)   *
;***************************************
.SKI 2
;***************************************
;* THIS SOFTWARE IS FURNISHED FOR USE  *
;* USE IN THE CBM P-SERIES AND B-SERIES*
;* COMPUTERS.                          *
;*                                     *
;* COPIES THEREOF MAY NOT BE PROVIDED  *
;* OR MADE AVAILABLE FOR USE ON ANY    *
;* OTHER SYSTEM.                       *
;*                                     *
;* THE INFORMATION IN THIS DOCUMENT IS *
;* SUBJECT TO CHANGE WITHOUT NOTICE.   *
;*                                     *
;* NO RESPONSIBILITY IS ASSUMED FOR    *
;* RELIABILITY OF THIS SOFTWARE.  RSR  *
;*                                     *
;***************************************
.END
; -------------------------------------------------------------
; ##### DECLARE #####
.PAG 'DECLARE 03/11/83'
	* =$0000
;------------------------------------------------------
; 6509  USED TO EXTEND MEMORY ON BC2 & P2 SYSTEMS
;   LOCATION - USED TO DIRECT
;   $0000 -  EXECUTION REGISTER (4 BITS)
;   $0001 -  INDIRECT  REGISTER (4 BITS)
;
;   THESE REGISTERS PROVIDE 4 EXTRA HIGH-ORDER ADDRESS
;   CONTROL LINES.  ON 6509 RESET ALL LINES ARE HIGH.
;
; CURRENT MEMORY MAP:
;   SEGMENT 15- $FFFF-$E000  ROM (KERNAL)
;               $DFFF-$DF00  I/O  6525 TPI2
;               $DEFF-$DE00  I/O  6525 TPI1
;               $DDFF-$DD00  I/O  6551 ACIA
;               $DCFF-$DC00  I/O  6526 CIA
;               $DBFF-$DB00  I/O  UNUSED (Z80,8088,68008)
;               $DAFF-$DA00  I/O  6581 SID
;               $D9FF-$D900  I/O  UNUSED (DISKS)
;               $D8FF-$D800  I/O  6566 VIC/ 6845 80-COL
;               $D7FF-$D400  COLOR NYBLES/80-COL SCREEN
;               $D3FF-$D000  VIDEO MATRIX/80-COL SCREEN
;               $CFFF-$C000  CHARACTER DOT ROM (P2 ONLY)
;               $BFFF-$8000  ROMS EXTERNAL (LANGUAGE)
;               $7FFF-$4000  ROMS EXTERNAL (EXTENSIONS)
;               $3FFF-$2000  ROM  EXTERNAL
;               $1FFF-$1000  ROM  INTERNAL
;               $0FFF-$0400  UNUSED
;               $03FF-$0002  RAM (KERNAL/BASIC SYSTEM)
;   SEGMENT 14- SEGMENT 8 OPEN (FUTURE EXPANSION)
;   SEGMENT 7 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 6 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 5 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 4 - $FFFF-$0002  RAM B2 EXPANSION (P2 EXTERNAL)
;   SEGMENT 3 - $FFFF-$0002  RAM EXPANSION
;   SEGMENT 2 - $FFFF-$0002  RAM B2 STANDARD (P2 OPTINAL)
;   SEGMENT 1 - $FFFF-$0002  RAM B2 P2 STANDARD
;   SEGMENT 0 - $FFFF-$0002  RAM P2 STANDARD (B2 OPTIONAL)
;
; THE 6509 REGISTERS APPEAR IN LOCATIONS $0000 AND
; $0001 IN ALL SEGMENTS OF MEMORY.
;
;------------------------------------------------------
E6509	*=*+1           ;6509 EXECUTION   REGISTER
I6509	*=*+1           ;6509 INDIRECTION REGISTER
.SKI 2
IROM	=$F             ;INDIRECT=ROM OR EXECUTION=ROM
	.IFE SYSAGE <
.PAGE 'DECLARE - MONITOR'
;
;VIRTUAL REGISTERS
;
	*=$AE           ;PLACE IN THESE LOCATIONS TEMPORARLY...
PCH	*=*+1           ;PROGRAM COUNTER
PCL	*=*+1
;
FLGS	*=*+1           ;PROCESSOR STATUS
;
ACC	*=*+1           ;ACCUMULATOR
;
XR	*=*+1           ;.X REGISTER
;
YR	*=*+1           ;.Y REGISTER
;
SP	*=*+1           ;STACK POINTER
;
XI6509	*=*+1           ;OLD INDIRECTION SEGMENT
;
RE6509	*=*+1           ;RETURN EXECUTION SEGMENT
;
INVH	*=*+1           ;USER INTERRUPT VECTOR
INVL	*=*+1
;
;MONITOR INDIRECT VARIABLES
;
TMP0	*=*+2
TMP2	*=*+2
;
;OTHER MONITOR VARIABLES
;
TMPC	*=*+1           ;PLACE TO SAVE LAST CMD
T6509	*=*+1           ;TEMPORARY I6509
DDISK	*=*+1           ;DEFAULT DISK UNIT # FOR MONITOR
;
>
.PAG 'DECLARE - KERNAL'
	* =$90
;KERNAL PAGE ZERO VARIABLES
;
;KERNAL INDIRECT ADDRESS VARIABLES
;
FNADR	*=*+3           ;ADDRESS OF FILE NAME STRING
SAL	*=*+1           ;CURRENT LOAD/STORE ADDRESS
SAH	*=*+1
SAS	*=*+1
EAL	*=*+1           ;END OF LOAD/SAVE
EAH	*=*+1
EAS	*=*+1
STAL	*=*+1           ;START OF LOAD/SAVE
STAH	*=*+1
STAS	*=*+1
;
;FREQUENTLY USED KERNAL VARIABLES
;
STATUS	*=*+1           ;I/O OPERATION STATUS
FNLEN	*=*+1           ;FILE NAME LENGTH
LA	*=*+1           ;CURRENT LOGICAL INDEX
FA	*=*+1           ;CURRENT FIRST ADDRESS
SA	*=*+1           ;CURRENT SECOND ADDRESS
DFLTN	*=*+1           ;DEFAULT INPUT DEVICE
DFLTO	*=*+1           ;DEFAULT OUTPUT DEVICE
;
;TAPE BUFFER POINTER
;
TAPE1	*=*+3           ;ADDRESS OF TAPE BUFFER
;
;RS-232 BUFFER POINTERS
;
RIBUF	*=*+3           ;INPUT BUFFER
;
;VARIABLES FOR KERNAL SPEED
;
STKEY	*=*+1           ;STOP KEY FLAG
CTEMP	;USED TO REDUCE CASSETTE READ TIMES
C3PO	*=*+1           ;IEEE BUFFER FLAG
SNSW1	;USED TO REDUCE CASSETTE READ TIMES
BSOUR	*=*+1           ;IEEE CHARACTER BUFFER
;
;   CASSETTE TEMPS - OVERLAYS IPC BUFFER
;
IPOINT	;NEXT 2 BYTES USED FOR TRANSX CODE
SYNO	*=*+1
DPSW	*=*+1
; NEXT 18 BYTES ALSO USED FOR MONITOR
PTR1	*=*+1           ;INDEX TO PASS1 ERRORS
PTR2	*=*+1           ;INDEX TO PASS2 ERRORS
PCNTR	*=*+1
FIRT	*=*+1
CNTDN	*=*+1
SHCNL	*=*+1
RER	*=*+1
REZ	*=*+1
RDFLG	*=*+1
FLAGT1	;TEMP DURING BIT READ TIME
SHCNH	*=*+1
CMP0	*=*+1
DIFF	*=*+1
PRP	*=*+1
OCHAR	*=*+1
PRTY	*=*+1
FSBLK	*=*+1
MYCH	*=*+1
CDATA	*=*+1           ;HOW TO TURN CASSETTE TIMERS ON
.PAG 'DECLARE-EDITOR'
;SCREEN EDITOR PAGE ZERO VARIABLES
;
;EDITOR INDIRECT ADDRESS VARIABLES
;
	*=$C0           ;LEAVE SOME SPACE
PKYBUF	*=*+2           ;START ADR OF PGM KEY
KEYPNT	*=*+2           ;CURRENT PGM KEY BUF
SEDSAL	*=*+2           ;SCROLL PTR
SEDEAL	*=*+2           ;SCROLL PTR
PNT	*=*+2           ;CURRENT CHARACTER POINTER
;
;EDITOR VARIABLES FOR SPEED & SIZE
;
TBLX	*=*+1           ;CURSOR LINE
PNTR	*=*+1           ;CURSOR COLUMN
GRMODE	*=*+1           ;GRAPHIC/TEXT MODE FLAG
LSTX	*=*+1           ;LAST CHARACTER INDEX
LSTP	*=*+1           ;SCREEN EDIT START POSITION
LSXP	*=*+1
CRSW	*=*+1           ;
NDX	*=*+1           ;INDEX TO KEYD QUEUE
QTSW	*=*+1           ;QUOTE MODE FLAG
INSRT	*=*+1           ;INSERT MODE FLAG
CONFIG	*=*+1           ;COURSOR TYPE / CHAR BEFORE BLINK (PETII)
INDX	*=*+1           ;LAST BYTE POSISTION ON LINE (##234-02##244-02)
KYNDX	*=*+1           ;COUNT OF PROGRAM KEY STRING
RPTCNT	*=*+1           ;DELAY TWEEN CHARS
DELAY	*=*+1           ;DELAY TO NEXT REPEAT
;
SEDT1	*=*+1           ;FREQUENTLY USED TEMP VARIABLES
SEDT2	*=*+1
;
;FREQUENTLY USED EDITOR VARIABLES
;
DATA	*=*+1           ;CURRENT PRINT DATA
SCTOP	*=*+1           ;TOP SCREEN 0-25
SCBOT	*=*+1           ;BOTTOM 0-25
SCLF	*=*+1           ;LEFT MARGIN
SCRT	*=*+1           ;RIGHT MARGIN
MODKEY	*=*+1           ;KEYSCANNER SHIFT/CONTROL FLAGS ($FF-NOKEY)
NORKEY	*=*+1           ;KEYSCANNER NORMAL KEY NUMBER ($FF-NOKEY)
;
; SEE SCREEN EDITOR LISTINGS FOR USAGE IN THIS AREA
;
	* =$F0          ;FREE ZERO PAGE SPACE, 16 BYTES
.PAG 'DECLARE ABSOLUTE'
	* =$100         ;SYSTEM STACK AREA
BAD	*=*+1           ;CASSETTE BAD ADDRESS TABLE
	* =$1FF
STACKP	*=*+1           ;SYSTEM STACK POINTER TRANSX CODE
	* =$200
BUF	*=*+256         ;BASIC'S ROM PAGE WORK AREA
;
;SYSTEM RAM VECTORS
;
CINV	*=*+2           ;IRQ VECTOR
CBINV	*=*+2           ;BRK VECTOR
NMINV	*=*+2           ;NMI VECTOR
IOPEN	*=*+2           ;OPEN FILE VECTOR
ICLOSE	*=*+2           ;CLOSE FILE VECTOR
ICHKIN	*=*+2           ;OPEN CHN IN VECTOR
ICKOUT	*=*+2           ;OPEN CHN OUT VECTOR
ICLRCH	*=*+2           ;CLOSE CHANNEL VECTOR
IBASIN	*=*+2           ;INPUT FROM CHN VECTOR
IBSOUT	*=*+2           ;OUTPUT TO CHN VECTOR
ISTOP	*=*+2           ;CHECK STOP KEY VECTOR
IGETIN	*=*+2           ;GET FROM QUEUE VECTOR
ICLALL	*=*+2           ;CLOSE ALL FILES VECTOR
ILOAD	*=*+2           ;LOAD FROM FILE VECTOR
ISAVE	*=*+2           ;SAVE TO FILE VECTOR
USRCMD	*=*+2           ;MONITOR EXTENSION VECTOR
ESCVEC	*=*+2           ;USER ESC KEY VECTOR
CTLVEC	*=*+2           ;UNUSED CONTROL KEY VECTOR
ISECND	*=*+2           ;IEEE LISTEN SECONDARY ADDRESS
ITKSA	*=*+2           ;IEEE TALK SECONDARY ADDRESS
IACPTR	*=*+2           ;IEEE CHARACTER IN ROUTINE
ICIOUT	*=*+2           ;IEEE CHARACTER OUT ROUTINE
IUNTLK	*=*+2           ;IEEE BUS UNTALK
IUNLSN	*=*+2           ;IEEE BUS UNLISTN
ILISTN	*=*+2           ;IEEE LISTEN DEVICE PRIMARY ADDRESS
ITALK	*=*+2           ;IEEE TALK DEVICE PRIMARY ADDRESS
;
;KERNAL ABSOLUTE VARIABLES
;
LAT	*=*+10          ;LOGICAL FILE NUMBERS
FAT	*=*+10          ;DEVICE NUMBERS
SAT	*=*+10          ;SECONDARY ADDRESSES
;
;
LOWADR	*=*+3           ;START OF SYSTEM MEMORY
HIADR	*=*+3           ;TOP OF SYSTEM MEMORY
MEMSTR	*=*+3           ;START OF USER MEMORY
MEMSIZ	*=*+3           ;TOP OF USER MEMORY
TIMOUT	*=*+1           ;IEEE TIMEOUT ENABLE
VERCK	*=*+1           ;LOAD/VERIFY FLAG
LDTND	*=*+1           ;DEVICE TABLE INDEX
MSGFLG	*=*+1           ;MESSAGE FLAG
BUFPT	*=*+1           ;CASSETTE BUFFER INDEX
;
;KERNAL TEMPORARY (LOCAL) VARIABLE
;
T1	*=*+1
T2	*=*+1
XSAV	*=*+1
SAVX	*=*+1
SVXT	*=*+1
TEMP	*=*+1
ALARM	*=*+1           ; IRQ VARIABLE HOLDS 6526 IRQ'S
;
;KERNAL CASSETTE VARIABLES
;
ITAPE	*=*+2           ;INDIRECT FOR CASSETTE CODE
CASSVO	*=*+1           ;CASSETTE READ  VARIABLE
ASERVO	*=*+1           ;FLAGT1***INDICATES T1 TIMEOUT CASSETTE READ
CASTON	*=*+1           ;HOW TO TURN ON TIMERS
RELSAL	*=*+1           ;MOVEABLE START LOAD ADDR
RELSAH	*=*+1
RELSAS	*=*+1
OLDINV	*=*+3           ;RESTORE USER IRQ AND I6509 AFTER CASSETTES
CAS1	*=*+1           ;CASSETTE SWITCH FLAG
;
;RS-232 INFORMATION STORAGE
;
M51CTR	*=*+1           ;6551 CONTROL IMAGE
M51CDR	*=*+1           ;6551 COMMAND IMAGE
	*=*+2
RSSTAT	*=*+1           ;PERM. RS-232 STATUS
DCDSR	*=*+1           ;LAST DCD/DSR VALUE
RIDBS	*=*+1           ;INPUT START INDEX
RIDBE	*=*+1           ;INPUT END INDEX
.PAG 'DECLARE ABSOLUTE'
;
;SCREEN EDITOR ABSOLUTE
;
	*=$380          ;BLOCK SOME AREA FOR EDITOR
PKYEND	*=*+2           ;PROGRAM KEY BUFFER END ADDRESS
PAGSAV	*=*+1           ;TEMP RAM PAGE
;
; SEE SCREEN EDITOR LISTINGS FOR OTHER VARIABLES
;
	* =$3C0         ;FREE ABSOLUTE SPACE START
;
; SYSTEM WARM START VARIABLES AND VECTORS
;
	* =$3F8
EVECT	*=*+5
WARM	=$A5            ;WARM START FLAG
WINIT	=$5A            ;INITILIZATION COMPLETE FLAG
	* =$400
RAMLOC
.PAG 'DECLARE IPC'
;
; KERNAL INTER-PROCESS COMMUNICATION VARIABLES
	* = $0800
IPBSIZ	= 16            ;IPC BUFFER SIZE
;
;   IPC BUFFER OFFSETS
;
IPCCMD	= 0             ;IPC COMMAND
IPCJMP	= 1             ;IPC JUMP ADDRESS
IPCIN	= 3             ;IPC #INPUT BYTES
IPCOUT	= 4             ;IPC #OUTPUT BYTES
IPCDAT	= 5             ;IPC DATA BUFFER (8 BYTES MAX)
;
IPB	*=*+IPBSIZ      ;IPC BUFFER
IPJTAB	*=*+256         ;IPC JUMP TABLE
IPPTAB	*=*+128         ;IPC PARAM SPEC TABLE
;
.END
; -------------------------------------------------------------
; ##### EQUATE #####
.PAG 'EQUATE 04/29/83'
;TAPE BLOCK TYPES
;
EOT	= 5             ;END OF TAPE
BLF	= 1             ;BASIC LOAD FILE
BDF	= 2             ;BASIC DATA FILE
BDFH	= 4             ;BASIC DATA FILE HEADER
BUFSZ	= 192           ;BUFFER SIZE
CR	= $D            ;CARRIAGE RETURN
BASIC	= $8000         ;START OF ROM (LANGUAGE)
KERNAL	= $E000         ;START OF ROM (KERNAL)
.SKI 5
; 6845 VIDEO DISPLAY CONTROLLER FOR BC2
;
VDC	= $D800
ADREG	= $0            ;ADDRESS REGISTER
DAREG	= $1            ;DATA REGISTER
.SKI 3
; 6581 SID SOUND INTERFACE DEVICE
;   REGISTER LIST
SID	= $DA00
;
; BASE ADDRESSES OSC1, OSC2, OSC3
OSC1	= $00
OSC2	= $07
OSC3	= $0E
;
; OSC REGISTERS
FREQLO	= $00
FREQHI	= $01
PULSEF	= $02
PULSEC	= $03
OSCCTL	= $04
ATKDCY	= $05
SUSREL	= $06
;
; FILTER CONTROL
FCLOW	= $15
FCHI	= $16
RESNCE	= $17
VOLUME	= $18
;
; POTS, RANDOM NUMBER, AND ENV3 OUT
POTX	= $19
POTY	= $1A
RANDOM	= $1B
ENV3	= $1C
.PAG 'EQUATE 6526'
; 6526 CIA  COMPLEX INTERFACE ADAPTER
;  GAME / IEEE DATA / USER
;
;   TIMER A: IEEE LOCAL / CASS LOCAL / MUSIC / GAME
;   TIMER B: IEEE DEADM / CASS DEADM / MUSIC / GAME
;
;   PRA0 : IEEE DATA1 / USER / PADDLE GAME 1
;   PRA1 : IEEE DATA2 / USER / PADDLE GAME 2
;   PRA2 : IEEE DATA3 / USER
;   PRA3 : IEEE DATA4 / USER
;   PRA4 : IEEE DATA5 / USER
;   PRA5 : IEEE DATA6 / USER
;   PRA6 : IEEE DATA7 / USER / GAME TRIGGER 14
;   PRA7 : IEEE DATA8 / USER / GAME TRIGGER 24
;
;   PRB0 : USER / GAME 10
;   PRB1 : USER / GAME 11
;   PRB2 : USER / GAME 12
;   PRB3 : USER / GAME 13
;   PRB4 : USER / GAME 20
;   PRB5 : USER / GAME 21
;   PRB6 : USER / GAME 22
;   PRB7 : USER / GAME 23
;
;   FLAG : USER / CASSETTE READ
;   PC   : USER
;   CT   : USER
;   SP   : USER
;
CIA	= $DC00
PRA	= $0            ;DATA REG A
PRB	= $1            ;DATA REG B
DDRA	= $2            ;DIRECTION REG A
DDRB	= $3            ;DIRECTION REG B
TALO	= $4            ;TIMER A LOW  BYTE
TAHI	= $5            ;TIMER A HIGH BYTE
TBLO	= $6            ;TIMER B LOW  BYTE
TBHI	= $7            ;TIMER B HIGH BYTE
TOD10	= $8            ;10THS OF SECONDS
TODSEC	= $9            ;SECONDS
TODMIN	= $A            ;MINUTES
TODHR	= $B            ;HOURS
SDR	= $C            ;SERIAL DATA REGISTER
ICR	= $D            ;INTERRUPT CONTROL REGISTER
CRA	= $E            ;CONTROL REGISTER A
CRB	= $F            ;CONTROL REGISTER B
.PAGE 'EQUATE IPC'
;
; 6526 CIA FOR INTER-PROCESS COMMUNICATION
;
;    PRA  = DATA PORT
;    PRB0 = BUSY1 (1=>6509 OFF DBUS)
;    PRB1 = BUSY2 (1=>8088/Z80 OFF DBUS)
;    PRB2 = SEMAPHORE 8088/Z80
;    PRB3 = SEMAPHORE 6509
;    PRB4 = UNUSED
;    PRB5 = UNUSED
;    PRB6 = IRQ TO 8088/Z80 (LO)
;    PRB7 = UNUSED
;
IPCIA	= $DB00
;
SEM88	= $04           ;PRB BIT2
SEM65	= $08           ;PRB BIT3
.PAGE 'EQUATE 6551'
; 6551 ACIA  RS-232C AND NETWORK INTERFACE
;
ACIA	= $DD00
DRSN	= $00           ;TRANSMITT/RECEIVE DATA REGISTER
SRSN	= $01           ;STATUS REGISTER
CDR	= $02           ;COMMAND REGISTER
CTR	= $03           ;CONTROL REGISTER
.SKI 5
DSRERR	= $40           ;DATA SET READY ERROR
DCDERR	= $20           ;DATA CARRIER DETECT ERROR
DOVERR	= $08           ;RECEIVER OUTER BUFFER OVERRUN
.PAGE 'EQUATE 6525/D1'
; 6525 TPI1  TRIPORT INTERFACE DEVICE #1
;  IEEE CONTROL / CASSETTE / NETWORK / VIC / IRQ
;
;   PA0 : IEEE DC CONTROL (TI PARTS)
;   PA1 : IEEE TE CONTROL (TI PARTS) (T/R)
;   PA2 : IEEE REN
;   PA3 : IEEE ATN
;   PA4 : IEEE DAV
;   PA5 : IEEE EOI
;   PA6 : IEEE NDAC
;   PA7 : IEEE NRFD
;
;   PB0 : IEEE IFC
;   PB1 : IEEE SRQ
;   PB2 : NETWORK TRANSMITTER ENABLE
;   PB3 : NETWORK RECEIVER ENABLE
;   PB4 : ARBITRATION LOGIC SWITCH
;   PB5 : CASSETTE WRITE
;   PB6 : CASSETTE MOTOR
;   PB7 : CASSETTE SWITCH
;
;   IRQ0: 50/60 HZ IRQ
;   IRQ1: IEEE SRQ
;   IRQ2: 6526 IRQ
;   IRQ3: (OPT) 6526 INTER-PROCESSOR
;   IRQ4: 6551
;   *IRQ: 6566 (VIC) / USER DEVICES
;   CB  : VIC DOT SELECT
;   CA  : VIC MATRIX SELECT
;
TPI1	= $DE00
PA	= $0            ;PORT REGISTER A
PB	= $1            ;PORT REGISTER B
PC	= $2            ;PORT REGISTER C
LIR	= $2            ;INTERRUPT LATCH REGISTER MC= 1
DDPA	= $3            ;DATA DIRECTION REGISTER A
DDPB	= $4            ;DATA DIRECTION REGISTER B
DDPC	= $5            ;DATA DIRECTION REGISTER C
MIR	= $5            ;INTERRUPT MASK REGISTER MC= 1
CREG	= $6            ;CONTROL REGISTER
AIR	= $7            ;ACTIVE INTERRUPT REGISTER
;
FREQ	= $01           ;IRQ LINE 50/60 HZ FOUND ON...
	.IFE SYSTEM <
ID55HZ	= 27            ;55 HZ VALUE REQUIRED BY IOINIT
>
	.IFN SYSTEM <
ID55HZ	= 14            ;55HZ VALUE REQUIRED BY IOINIT
>
.PAGE 'EQUATE 6525/D2'
; 6525 TPI2 TIRPORT INTERFACE DEVICE #2
;  KEYBOARD / VIC 16K CONTROL
;
;   PA0 : KYBD OUT 8
;   PA1 : KYBD OUT 9
;   PA2 : KYBD OUT 10
;   PA3 : KYBD OUT 11
;   PA4 : KYBD OUT 12
;   PA5 : KYBD OUT 13
;   PA6 : KYBD OUT 14
;   PA7 : KYBD OUT 15
;
;   PB0 : KYBD OUT 0
;   PB1 : KYBD OUT 1
;   PB2 : KYBD OUT 2
;   PB3 : KYBD OUT 3
;   PB4 : KYBD OUT 4
;   PB5 : KYBD OUT 5
;   PB6 : KYBD OUT 6
;   PB7 : KYBD OUT 7
;
;   PC0 : KYBD IN 0
;   PC1 : KYBD IN 1
;   PC2 : KYBD IN 2
;   PC3 : KYBD IN 3
;   PC4 : KYBD IN 4
;   PC5 : KYBD IN 5
;   PC6 : VIC 16K BANK SELECT LOW
;   PC7 : VIC 16K BANK SELECT HI
;
TPI2	= $DF00
.PAGE 'EQUATE IEEE LINES'
; IEEE LINE EQUATES
;
DC	= $01           ;75160/75161 CONTROL LINE
TE	= $02           ;75160/75161 CONTROL LINE
REN	= $04           ;REMOTE ENABLE
ATN	= $08           ;ATTENTION
DAV	= $10           ;DATA AVAILABLE
EOI	= $20           ;END OR IDENTIFY
NDAC	= $40           ;NOT DATA ACCEPTED
NRFD	= $80           ;NOT READY FOR DATA
IFC	= $01           ;INTERFACE CLEAR
SRQ	= $02           ;SERVICE REQUEST
;       
RDDB	= NRFD+NDAC+TE+DC+REN ;DIRECTIONS FOR RECEIVER
TDDB	= EOI+DAV+ATN+TE+DC+REN ;DIRECTIONS FOR TRANSMITT
;
EOIST	= $40           ;EOI STATUS TEST
TLKR	= $40           ;DEVICE IS TALKER
LSTNR	= $20           ;DEVICE IS LISTENER
UTLKR	= $5F           ;DEVICE UNTALK
ULSTN	= $3F           ;DEVICE UNLISTEN
;       
TOOUT	= $01           ;TIMEOUT STATUS ON OUTPUT
TOIN	= $02           ;TIMEOUT STATUS ON INPUT
EOIST	= $40           ;EOI ON INPUT
NODEV	= $80           ;NO DEVICE ON BUS.
SPERR	= $10           ;VERIFY ERROR
;       
;        EQUATES FOR C3P0 FLAG BITS 6 AND 7.
;       
SLOCK	= $40           ;SCREEN EDITOR LOCK-OUT
DIBF	= $80           ;DATA IN OUTPUT BUFFER
.END
; -------------------------------------------------------------
	* = KERNAL
	JMP MONOFF      ;COLD START VECTOR
	NOP
	* = KERNAL+$0E00 ;3.5K CODE SPACE (SCREEN EDITOR)
; -------------------------------------------------------------
; ##### MONITOR #####
.PAG 'MONITOR 05/02/83'
;************************************************
;*                                              *
;* KERNAL MONITOR                               *
;*                                              *
;* ENTRY VIA CALL (JMP) OR BREAKPOINT (BRK)     *
;* ---FUNCTIONS---                              *
;* <:>      ALTER MEMORY                        *
;* <;>      ALTER REGISTERS                     *
;* <R>      DISPLAY REGISTERS                   *
;* <M>      DISPLAY MEMORY                      *
;* <G>      START EXECUTION OF CODE             *
;* <L>      LOAD MEMORY                         *
;* <S>      SAVE MEMORY                         *
;* <V>      VIEW SEGMENT                        *
;* <@>      DISK COMMAND                        *
;* <X>      WARM START BASIC                    *
;* <U>      SET DEFAULT DISK UNIT               *
;* <OTHER>  LOAD AND EXECUTE FROM DISK          *
;*                                              *
;* FOR SYNTAX & SEMANTICS SEE CBM KERNAL MANUAL *
;* COPYRIGHT (C) 1981 BY CBM                    *
;************************************************
.PAG 'MONITOR'
; RESET ENTRY
	* = $EE00
;
;*****WARM START ENTRY*******
;
MONON	JSR IOINIT      ;GET I/O
	JSR RESTOR      ;VECTORS
	JSR CINT        ;SCREEN EDITOR
;
;*****COLD START ENTRY******
;
MONOFF
	JSR CLRCH       ;CLEAR CHANNELS
	LDA #WINIT      ;WASTE TWO BYTES SO TIMC=60950
	LDX #<MONON     ;POINT RESET VECTORS AT MONITOR ON
	LDY #>MONON
	JSR VRESET
	CLI             ;RELEASE IRQ'S
;
;*****CALL ENTRY*****
;
TIMC	LDA #$40+$80
	STA MSGFLG      ;ERROR+MESSAGES ON
	LDA #MS34-MS1   ;CALL ENTRY
	STA TMPC
	BNE B3          ;BRANCH ALWAYS
;
;*****BREAK ENTRY*****
;
TIMB	JSR CLRCH       ;CLR CHANNELS
	LDA #MS36-MS1   ;BREAK ENTRY
	STA TMPC
	CLD 
;
;SAVE .Y,.X,.A,FLAGS, AND PC
;
	LDX #5
B1	PLA
	STA PCH,X
	DEX
	BPL B1
;
B3
	LDA I6509       ;SAVE INDIRECTION SEGMENT
	STA XI6509
	LDA CINV
	STA INVL        ;SAVE IRQ LOW
	LDA CINV+1
	STA INVH        ;SAVE IRQ HIGH
;
	TSX
	STX SP          ;SAVE ORIGINAL SP
	CLI             ;CLEAR INTS
	LDA #8          ;SET DISK DEFAULT TO 8
	STA DDISK
;
B5	LDY TMPC        ;MESSAGE CODE
	JSR SPMSG       ;PRINT BREAK/CALL
;
	LDA #'R         ;DISPLAY REGS ON ENTRY
	BNE S0          ;BRANCH ALWAYS
;
;*****ERROR ENTRY*****
;
ERROPR	JSR OUTQST
	PLA
	PLA
;
;*****COMMAND INTERPRETER ENTRY*****
;
STRTM1=*-1
	LDA #$40+$80
	STA MSGFLG      ;I/O MESSAGES TO SCREEN
	LDA #<BUF       ;PUT FILENAME AT BOTTOM OF BASIC BUFFER
	STA FNADR
	LDA #>BUF
	STA FNADR+1
	LDA #IROM
	STA FNADR+2
	JSR CRLF
;
ST1	JSR BASIN       ;READ COMMAND
	CMP #'.'
	BEQ ST1         ;SKIP PROMPT CHARACTERS
	CMP #$20
	BEQ ST1         ;SPAN BLANKS
	JMP (USRCMD)    ;USER INDIRECT FOR MONITOR
;
;COMMAND INTERPRETER
;
S0	LDX #0
	STX FNLEN
	TAY             ;SAVE CURRENT COMMAND
;
;PUT RETURN ADDRESS FOR COMMANDS ON STACK
;
	LDA #>STRTM1
	PHA
	LDA #<STRTM1
	PHA
;
	TYA             ;CURRENT COMMAND IN .A
;
S1	CMP CMDS,X      ;IS IT THIS ONE?
	BNE S2          ;NOTIT
;
	STA SAVX        ;SAVE CURRENT COMMAND
;
;INDIRECT JMP FROM TABLE
;
	LDA CMDS+1,X
	STA TMP0
	LDA CMDS+2,X
	STA TMP0+1
	JMP (TMP0)
;
;EACH TABLE ENTRY IS 3 LONG---SKIP TO NEXT
;
S2	INX
	INX
	INX
	CPX #CMDEND-CMDS
	BCC S1          ;LOOP FOR ALL COMMANDS
;
;COMMAND NOT IN TABLE...LOOK ON DISK.
;COMMAND NAME CAN BE ANY LENGTH AND
;HAVE PARAMETERS.
;
	LDX #0          ;LENGTH TO ZERO
S3	CMP #$D         ;END OF NAME?
	BEQ S4          ;YES...
	CMP #$20        ;BLANK?
	BEQ S4          ;YES
	STA BUF,X
	JSR BASIN       ;GET NEXT
	INX             ;COUNT CHAR
	BNE S3          ;AND CONTINUE
;
S4	STA TMPC
	TXA             ;COUNT
	BEQ S6          ;IS ZERO
;
	STA FNLEN
	LDA #$40
	STA MSGFLG      ;MESSAGES OFF
	LDA DDISK       ;
	STA FA          ;WILL USE DEFAULT DISK
	LDA #IROM       ;COMMANDS ONLY LOAD TO ROM SEGMENT !!!***
	STA I6509       ;TURN INDIRECT TO ROM SEGMENT
	LDX #$FF
	LDY #$FF
	JSR LOAD        ;TRY TO LOAD COMMAND
	BCS S6          ;BAD LOAD...
;
	LDA TMPC        ;PASS LAST CHARACTER
	JMP (STAL)      ;GO DO IT
;
S6	RTS
.SKI 3
CMDS	.BYT ':'        ;ALTER MEMORY
	.WOR ALTM
	.BYT ';' ;ALTER REGISTERS
	.WOR ALTR
	.BYT 'R'        ;DISPLAY REGISTERS
	.WOR DSPLYR
	.BYT 'M'        ;DISPLAY MEMORY
	.WOR DSPLYM
	.BYT 'G'        ;START EXECUTION
	.WOR GO
	.BYT 'L'        ;LOAD MEMORY
	.WOR LD
	.BYT 'S'        ;SAVE MEMORY
	.WOR LD
	.BYT 'V'        ;VIEW SEGMENT
	.WOR VIEW
	.BYT '@'        ;DISK COMMAND (ALTERNATE)
	.WOR DISK
	.BYT 'Z'        ;TRANSFER TO 2ND MICROPROCESSOR
	.WOR IPCGOV     ;IPCGO VECTOR
	.BYT 'X'        ;WARM START BASIC
	.WOR XEIT
	.BYT 'U'        ;DEFAULT DISK UNIT SET
	.WOR UNITD
CMDEND
.SKI 5
XEIT	PLA             ;REMOVE COMMAND RETURN FROM STACK
	PLA
	SEI             ;DISABLE INTERRUPTS...ALL WARM START CODE EXPECTS
	JMP (EVECT)     ;GO WARMSTART LANGUAGE
.SKI 5
PUTP	LDA TMP0        ;MOVE TMP0 TO PCH,PCL
	STA PCL
	LDA TMP0+1
	STA PCH
	RTS
.SKI 5
SETR	LDA #<FLGS      ;SET TO ACCESS REGS
	STA TMP0
	LDA #>FLGS
	STA TMP0+1
	LDA #IROM       ;POINT INDIRECT AT ROMS
	STA I6509
	LDA #5
	RTS
.SKI 5
;PRINTS '.:' OR '.;' BEFORE DATA TO PERMIT
;ALTER AFTER 'M' OR 'R' COMMAND
;
ALTRIT	PHA             ;PRESERVE ALTER CHARACTER
	JSR CRLF
	PLA
	JSR BSOUT
.SKI 3
SPACE	LDA #$20        ;OUTPUT A SPACE
	.BYT $2C        ;SKIP TWO BYTES
OUTQST	LDA #'?         ;OUTPUT QUESTION
	JMP BSOUT       ;GO PRINT BYTES
CRLF	LDA #$D         ;DO CARRIAGE RETURN
	JSR BSOUT
	LDA #'.'        ;MONITOR PROMPT
	JMP BSOUT
.SKI 5
;DATA FOR REGISTER DISPLAY HEADING
;
REGK	.BYT CR,$20,$20 ;3 SPACES
	.BYT ' PC ',' IRQ ',' SR AC XR YR SP'
.SKI 5
;DISPLAY REGISTER FUNCTION
;
DSPLYR	LDX #0
D2	LDA REGK,X
	JSR BSOUT       ;PRINT HEADING
	INX
	CPX #DSPLYR-REGK ;MAX LENGTH
	BNE D2
	LDA #';
	JSR ALTRIT      ;ALLOW ALTER AFTER DISPLAY
	LDX PCH
	LDY PCL
	JSR WROA        ;PRINT PROGRAM COUNTER
	JSR SPACE
	LDX INVH
	LDY INVL
	JSR WROA        ;PRINT IRQ VECTOR
	JSR SETR        ;SET TO PRINT .P,.A,.X,.Y,.S
;
;DISPLAY MEMORY SUBROUTINE
;
DM	STA TMPC        ;BYTE COUNT
	LDY #0          ;INDIRECT INDEX
	STY FNLEN       ;FNLEN IS ZERO-PAGE CROSSING FLAG...
DM1	JSR SPACE       ;SPACE TWEEN BYTES
	LDA (TMP0)Y
	JSR WROB        ;WRITE BYTE OF MEMORY
;
;INCREMENT INDIRECT
;
	INC TMP0
	BNE DM2
	INC TMP0+1
	BNE DM2         ;NO ZERO PAGE CROSSING
	DEC FNLEN       ;FNLEN<>0 IS FLAG
;
DM2	DEC TMPC        ;COUNT BYTES
	BNE DM1         ;UNTIL ZERO
	RTS
.SKI 5
;DISPLAY MEMORY FUNCTION
;
DSPLYM	JSR RDOAE       ;READ START ADR...ERR IF NO SA
	JSR T2T2        ;SA TO TMP2
;
;ALLOW USER TO TYPE JUST ONE ADDRESS
;
	JSR RDOA        ;READ END ADR
	BCC DSP123      ;GOOD...NO DEFAULT
;
	LDA TMP2
	STA TMP0        ;DEFAULT LOW BYTE
	LDA TMP2+1
	STA TMP0+1      ;DEFAULT HI BYTE
;
DSP123	JSR T2T2        ;SA TO TMP0, EA TO TMP2
DSP1	JSR STOP        ;STOP KEY?
	BEQ BEQS1       ;YES...BREAK LIST
;
	LDA #':
	JSR ALTRIT      ;ALLOW ALTER
	LDX TMP0+1
	LDY TMP0
	JSR WROA        ;WRITE START ADDRESS
	.IFN SYSTEM <
	LDA #8          ;COUNT OF BYTES
>
	.IFE SYSTEM <
	LDA #16         ;COUNT OF BYTES CBMII
>
	JSR DM          ;DISPLAY BYTES
;
;CHECK FOR END OF DISPLAY
;
	LDA FNLEN       ;CHECK FOR ZERO-CROSSING
	BNE BEQS1       ;YUP....
	SEC
	LDA TMP2
	SBC TMP0
	LDA TMP2+1
	SBC TMP0+1
	BCS DSP1        ;END >= START
;
BEQS1	RTS             ;A.O.K. EXIT
;
.SKI 5
;ALTER REGISTER FUNCTION
;
ALTR	JSR RDOAE       ;READ NEW PC...NO ADDRESS=ERROR
;
	JSR PUTP        ;ALTER PC
;
	JSR RDOAE       ;READ NEW IRQ...NO ADDRESS=ERROR
;
	LDA TMP0
	STA INVL        ;ALTER IRQ VECTOR
	LDA TMP0+1
	STA INVH
;
	JSR SETR        ;SET TO ALTER R'S
	BNE A4          ;BRANCH ALWAYS
.SKI 2
;VIEW A SEGMENT (POINT INDIRECT)
;
VIEW	JSR RDOBE       ;GET A BYTE...IF NONE...ERROR
	CMP #16         ;RANGE 0-15
	BCS ERRL        ;TO LARGE NO MODULO
	STA I6509
	RTS
.SKI 2
;UNIT DEFAULT FOR DISK
;
UNITD	JSR RDOBE       ;GET A BYTE...IF NONE...ERROR
	CMP #32         ;RANGE 0-31
	BCS ERRL        ;TO LARGE NO MODULO
	STA DDISK
	RTS
.SKI 2
;ALTER MEMORY - READ ADR AND DATA
;
ALTM	JSR RDOAE       ;READ ALTER ADR...IF NONE...ERROR
;
	.IFN SYSTEM <
	LDA #8          ;ALLOW 8 BYTES CHANGE
>
	.IFE SYSTEM <
	LDA #16         ;ALLOW 16 BYTES CHANGE
>
;
;COMMON CODE FOR ':' AND ';'
;
A4	STA TMPC        ;NUMBER OF BYTES TO CHANGE
;
A5	JSR RDOB        ;READ BYTE
	BCS A9          ;NONE...END OF LINE
;
	LDY #0
	STA (TMP0)Y     ;STORE IT AWAY
;
;INCREMENT STORE ADDRESS
;
	INC TMP0
	BNE A6
	INC TMP0+1
;
A6	DEC TMPC        ;COUNT BYTE
	BNE A5          ;UNTIL ZERO
;
A9	RTS
.SKI 5
;START EXECUTION FUNCTION
;
GO	JSR RDOC        ;SEE IF DEFAULT
	BEQ G1          ;YES...PC IS ADDRESS
;
	JSR RDOAE       ;NO...GET NEW ADDR...NONE=ERROR
;
	JSR PUTP        ;MOVE ADDR TO P.C.
;
G1	LDX SP
	TXS             ;ORIG OR NEW SP VALUE TO SP
;
	SEI             ;PREVENT DISASTER
;
	LDA INVH
	STA CINV+1      ;SET UP IRQ VECTOR
	LDA INVL
	STA CINV
	LDA XI6509      ;AND INDIRECTION REGISTER
	STA I6509
;
;GET FLAGS,PCH,PCL,.A,.X,.Y
;
	LDX #0
G2	LDA PCH,X
	PHA             ;EVERYBODY ON STACK
	INX
	CPX #6
	BNE G2
;
;INTERRUPT RETURN SETS EVERYBODY UP
;FROM DATA ON STACK
;
	JMP PREND
.SKI 3
; RDOBE - READ A BYTE AND ERROR ON LINE END..WASTE STACK
;
RDOBE	JSR RDOB
	BCS ERRLPL
RDOXIT	RTS
;
; RDOAE - READ AN ADDRESS AND ERROR ON LINE END...WASTE STACK
;
RDOAE	JSR RDOA
	BCC RDOXIT
;
ERRLPL	PLA             ;ZAP STACK
	PLA
ERRL	JMP ERROPR      ;SYNTAX ERROR JUMP
.SKI 3
;LOAD RAM FUNCTION
;  *NOTE - LOAD/SAVE RESET INDIRECT TO ROM
;
LD	LDY #1
	STY FA          ;DEFAULT DEVICE #1
	DEY             ;.Y=0 TO COUNT NAME LENGTH
	LDA #$FF        ;DEFAULT NO MOVE LOAD
	STA TMP0
	STA TMP0+1
	LDA I6509       ;SAVE INDIRECT FOR SEG ADDRESS
	STA T6509
	LDA #IROM       ;INDIRECT TO ROM FOR FILENAME
	STA I6509
;
L1	JSR RDOC        ;DEFAULT?
	BEQ L5          ;YES...TRY LOAD
;
	CMP #' 
	BEQ L1          ;SPAN BLANKS
;
	CMP #'"         ;STRING NEXT?
L2	BNE ERRL        ;NO FILE NAME...
;
L3	JSR RDOC        ;GET CHARACTER OF NAME
	BEQ L5          ;END...ASSSUME LOAD
;
	CMP #'"         ;END OF STRING?
	BEQ L8          ;YES...COULD STILL BE 'L' OR 'S'
;
	STA (FNADR)Y    ;STORE NAME
	INC FNLEN
	INY
	CPY #16         ;MAX FILE NAME LENGTH
;
L4	BEQ ERRL        ;FILE NAME TOO LONG
	BNE L3          ;BRANCH ALWAYS
;
;SEE IF WE GOT A LOAD
;
L5	LDA SAVX        ;GET LAST COMMAND
	CMP #'L
	BNE L2          ;NO..NOT A LOAD..ERROR
;
	LDA T6509       ;GET SEGMENT TO LOAD TO
	AND #IROM       ;MASK OFF VERIFY BIT
	LDX TMP0
	LDY TMP0+1
	JMP LOAD        ;YES...DO LOAD
;
L8	JSR RDOC        ;MORE STUFF?
	BEQ L5          ;NO...DEFUALT LOAD
;
	CMP #',         ;DELEIMETER?
L9	BNE L2          ;NO...BAD SYNTAX
;
	JSR RDOBE       ;YES...GET NEXT PARM...ERROR IF NONE
;
	STA FA
;
	JSR RDOC        ;MORE PARMS?
	BEQ L5          ;NO...DEFAULT LOAD
;
	CMP #',         ;DELIMETER?
L12	BNE L9          ;NO...BAD SYNTAX
;
	JSR RDOBE       ;SEGMENT BYTE ?...MUST HAVE
	CMP #16         ;00-0F ALLOWED
	BCS L15         ;TOO BIG...
	STA T6509
	STA STAS        ;PREP SEGMENT
	JSR RDOAE       ;START ADDRESS?...MUST HAVE
;
;SET UP START SAVE ADDRESS
;
	LDA TMP0
	STA STAL
	LDA TMP0+1
	STA STAH
;
	JSR RDOC        ;DELIMETER?
	BEQ L5          ;CR, DO LOAD
	CMP #',
	BNE L15         ;NO DELIM
;
	JSR RDOBE       ;GET SEGMENT BYTE...MUST HAVE
	CMP #16         ;ALLOW ONLY 00-0F
	BCS L15         ;TOO BIG...
	STA EAS         ;PREP SEGMENT
	JSR RDOAE       ;TRY TO READ END ADDRESS...MUST HAVE
;
;SET UP END SAVE ADDRESS
;
	LDA TMP0
	STA EAL
	LDA TMP0+1
	STA EAH
;
L20	JSR BASIN
	CMP #$20
	BEQ L20         ;SPAN BLANKS
;
	CMP #CR
L14	BNE L12         ;MISSING CR AT END
	LDA SAVX        ;WAS COMMAND SAVE?
	CMP #'S
	BNE L14         ;NO...LOAD CAN'T HAVE PARMS
	LDX #STAL       ;GET PARAMS FOR SAVE
	LDY #EAL
	JMP SAVE
;
L15	JMP ERROPR
.SKI 5
;WRITE ADR FROM TMP0 STORES
;
WROA	TXA             ;HI-BYTE
	JSR WROB
	TYA             ;LOW-BYTE
.SKI 3
;WRITE BYTE --- A = BYTE
;UNPACK BYTE DATA INTO TWO ASCII
;CHARACTERS. A=BYTE; X,A=CHARS
WROB	PHA
	LSR A
	LSR A
	LSR A
	LSR A
	JSR ASCII       ;CONVERT TO ASCII
	TAX
	PLA
	AND #$0F
.SKI 3
;CONVERT NYBBLE IN A TO ASCII AND
;PRINT IT
;
ASCII	CLC
	ADC #$F6
	BCC ASC1
	ADC #$06
ASC1	ADC #$3A
	JMP BSOUT
.SKI 5
;EXCHANGE TEMPORARIES
;
T2T2	LDX #2
T2T21	LDA TMP0-1,X
	PHA
	LDA TMP2-1,X
	STA TMP0-1,X 
	PLA
	STA TMP2-1,X
	DEX
	BNE T2T21
	RTS
.SKI 5
;READ HEX ADR,RETURN HI IN TMP0,
;LO IN TMP0+1,AND CY=1
;IF SP CY=0
;
RDOA	JSR RDOB        ;READ 2-CHAR BYTE
	BCS RDOA2       ;SPACE
	STA TMP0+1
	JSR RDOB
	STA TMP0
RDOA2	RTS
;READ HEX BYTE AND RETURN IN A
;AND CY=0 IF SP CY=1
RDOB	LDA #0          ;SPACE
	STA BAD         ;READ NEXT CHAR
	JSR RDOC
	BEQ RDOB4       ;FAIL ON CR
	CMP #'          ;BLANK?
	BEQ RDOB        ;SPAN BLANKS...
;
	JSR HEXIT       ;CONVERT TO HEX NYBBLE
	ASL A
	ASL A
	ASL A
	ASL A
	STA BAD
	JSR RDOC        ;2ND CHAR ASSUMED HEX
	BEQ RDOB4       ;FAIL ON CR
	JSR HEXIT
	ORA BAD
;
RDOB4	RTS
.SKI 5
;CONVERT ASCII CHAR TO HEX NYBBLE
;
HEXIT	CMP #$3A
	PHP             ;SAVE FLAGS
	AND #$0F
	PLP
	BCC HEX09       ;0-9
	ADC #8          ;ALPHA ADD 8+CY=9
HEX09	RTS
.SKI 5
;GET CHARACTER AND TEST FOR CR
;
RDOC	JSR BASIN
	CMP #$0D        ;IS IT A CR
	RTS             ;RETURN WITH FLAGS
.SKI 5
;SEND DISK COMMAND OR READ STATUS
;
DISK	LDA #0          ;CLEAR STATUS @ I/O BEGIN
	STA STATUS
	STA FNLEN       ;FILENAME LENGTH OF ZERO...
;
	LDX DDISK       ;GET DEFAULT DISK
	LDY #$0F        ;OPEN COMMAND CHANNEL
	JSR SETLFS      ;.A-0 TEMPORARY CHANNEL #
	CLC
	JSR OPEN        ;OPEN A REAL CHANNEL
	BCS DISK30      ;EXIT IF BAD RETURN
;
	JSR RDOC        ;SEE IF STATUS CHECK
	BEQ DISK20      ;YES
;
	PHA
	LDX #0
	JSR CKOUT       ;SET UP AS OUTPUT
	PLA
	BCS DISK30      ;BAD STATUS RETURN
	BCC DISK15      ;NO...OK
;
DISK10	JSR BASIN       ;GET A CHARACTER
DISK15	CMP #$D         ;SEE IF END
	PHP             ;SAVE FOR LATER
	JSR BSOUT       ;OUT TO FLOPPY
	LDA STATUS
	BNE DISK28      ;BAD STATUS RETURNED
	PLP             ;END?
	BNE DISK10      ;NO...CONTINUE
	BEQ DISK30      ;YES...FLOPPY DONE
;
DISK20	JSR CRLF
	LDX #0
	JSR CHKIN       ;TELL FLOPPY TO SPEAK
	BCS DISK30      ;BAD DEVICE
;
DISK25	JSR RDOC        ;GET A CHARACTER
	PHP             ;SAVE TEST FOR LATER
	JSR BSOUT       ;OUT TO SCREEN
	LDA STATUS      ;CHECK FOR BAD BASIN
	AND #$FF-$40    ;REMOVE EOI BIT
	BNE DISK28      ;REPORT BAD STATUS
	PLP             ;END?
	BNE DISK25      ;NO...
	BEQ DISK30      ;YES...FLOPPY DONE
;
DISK28	PLA             ;CLEAN UP...
DISK29	JSR ERROR5      ;REPORT ERROR #5 FOR BAD DEVICE
DISK30	JSR CLRCH       ;CLEAN UP
	LDA #0
	CLC             ;JUST REMOVE FROM TABLE
	JMP CLOSE
.END
; -------------------------------------------------------------
; ##### MESSAGES #####
.PAG 'MESSAGES'
MS1	.BYT $D,'I/O ERROR ',$A3
MS5	.BYT $D,'SEARCHING',$A0
MS6	.BYT 'FOR',$A0
;MS7 .BYT $D,'PRESS PLAY ON TAP',$C5
;MS8 .BYT 'PRESS RECORD & PLAY ON TAP',$C5
MS10	.BYT $D,'LOADIN',$C7
MS11	.BYT $D,'SAVING',$A0
MS21	.BYT $D,'VERIFYIN',$C7
MS17	.BYT $D,'FOUND',$A0
MS18	.BYT $D,'OK',$8D
	.IFE SYSAGE <
MS34	.BYT $D,'** MONITOR 1.0 **',$8D
MS36	.BYT $D,'BREA',$CB
>
.SKI 5
;PRINT MESSAGE TO SCREEN ONLY IF
;OUTPUT ENABLED
;
SPMSG	BIT MSGFLG      ;PRINTING MESSAGES?
	BPL MSG10       ;NO...
MSG	LDA MS1,Y
	PHP
	AND #$7F
	JSR BSOUT
	INY
	PLP
	BPL MSG
MSG10	CLC
	RTS
.END
; -------------------------------------------------------------
; ##### IEEE #####
.PAGE 'IEEE 04/29/83'
;        COMMAND IEEE-488 DEVICE TO TALK
;       
NTALK	ORA #TLKR       ;MAKE A TALK ADR
	BNE LIST1       ;ALWAYS GO TO LIST1
.SKIP 4
;        COMMAND IEEE-488 DEVICE TO LISTEN
;       
NLISTN	ORA #LSTNR      ;MAKE A LISTEN ADR
;       
LIST1	PHA             ;SAVE DEVICE AND TALK/LISTEN
;       
	LDA #TDDB       ;SET CONTROL FOR ATN/DATA OUT
	STA TPI1+DDPA
;
	LDA #$FF        ;SET DIRECTION FOR TRANSMITT *
	STA CIA+PRA     ;SET DATA   *
	STA CIA+DDRA    ;SET DATA DIRECTION OUT   *
	LDA #$FF-DC-REN ;ENABLE TRANSMITT
	STA TPI1+PA
	LDA C3PO        ;GET IEEE FLAGS
	BPL LIST2       ;IF DATA IN BUFFER
;       
	LDA TPI1+PA     ;SEND EOI
	AND #$FF-EOI
	STA TPI1+PA
;       
	LDA BSOUR       ;GET BYTE TO SEND
	JSR TBYTE       ;SEND LAST CHARACTER
;       
	LDA C3PO        ;CLEAR BYTE IN BUFFER FLAG
	AND #$FF-DIBF
	STA C3PO
;       
	LDA TPI1+PA     ;CLEAR EOI
	ORA #EOI
	STA TPI1+PA
;       
LIST2	LDA TPI1+PA     ;ASSERT ATN
	AND #$FF-ATN
	STA TPI1+PA
;       
	PLA             ;GET TALK/LISTEN ADDRESS
	JMP TBYTE
.SKIP 4
;        SEND SECONDARY ADDRESS AFTER LISTEN
;       
NSECND	JSR TBYTE       ;SEND IT
;       
;        RELEASE ATTENTION AFTER LISTEN
;       
SCAT1
;
SCATN	LDA TPI1+PA     ;DE-ASSERT ATN
	ORA #ATN
	STA TPI1+PA
	RTS
.SKIP 4
;        TALK SECOND ADDRESS
;       
NTKSA	JSR TBYTE       ;SEND SECONDARY ADDRESS
;
TKATN
	LDA #$FF-NRFD-NDAC-TE-REN ;PULL NRFD AND NDAC LOW
	AND TPI1+PA
SETLNS	;EXIT ENTRY FOR UNTALK/UNLISTEN
	STA TPI1+PA
	LDA #RDDB       ;SET CONTROL LINES FOR INPUT
	STA TPI1+DDPA
	LDA #$00        ;SET DATA LINES FOR RECIEVE
	STA CIA+DDRA
	BEQ SCATN
.SKIP 4
;
;        BUFFERED OUTPUT TO IEEE-488
;
NCIOUT	PHA             ;SAVE DATA
	LDA C3PO        ;GET IEEE FLAGS
	BPL CI1         ;IF NO DATA IN BUFFER
	LDA BSOUR       ;GET DATA IN BUFFER
	JSR TBYTE       ;TRANSMIT BYTE
	LDA C3PO        ;GET IEEE FLAGS
;
CI1	ORA #DIBF       ;SET DATA IN BUFFER FLAG
	STA C3PO
;
	PLA             ;GET NEW DATA
	STA BSOUR
	RTS
.SKIP 4
;        SEND UNTALK COMMAND ON IE
;       
NUNTLK
	LDA #UTLKR      ;UNTALK COMMAND
	BNE UNLS1       ;ALWAYS
.SKIP 4
;        SEND UNLISTEN COMMAND ON IEEE-488
;       
NUNLSN	LDA #ULSTN      ;UNLISTEN COMMAND
UNLS1	JSR LIST1       ;SEND IT
	LDA #$FF-TE-REN ;SET FOR RECIEVE ALL LINES HIGH
	JMP SETLNS      ;GO SETUP PROPER EXIT STATE
;
.SKIP 4
;        TBYTE -- OUTPUT BYTE ONTO IEEE BUS.
;       
;        ENTRY A = DATA BYTE TO BE OUTPUT.
;       
;        USES A REGISTER.
;        1 BYTE OF STACK SPACE.
;       
TBYTE
	EOR #$FF        ;COMPLIMENT DATA
	STA CIA+PRA
;
	LDA TPI1+PA
	ORA #DAV+TE     ;SAY DATA NOT VALID, TE=DATA OUT
	STA TPI1+PA
;       
	BIT TPI1+PA     ;TEST NRFD & NDAC IN HIGH STATE
	BVC TBY2        ;EITHER NRFD OR NDAC LOW => OK
	BPL TBY2
;       
TBY1	LDA #NODEV      ;SET NO-DEVICE BIT IN STATUS
	JSR UDST
	BNE TBY7        ;ALWAYS EXIT
;       
TBY2	LDA TPI1+PA
	BPL TBY2        ;IF NRFD IS HIGH
;       
	AND #$FF-DAV
	STA TPI1+PA
;       
TBY3	JSR TIMERO      ;SET TIMEOUT
	BCC TBY4        ;C-CLEAR MEANS FIRST TIME THROUGH
TBY3T	SEC             ;C-SET IS SECOND TIME
;
TBY4	BIT TPI1+PA
	BVS TBY6        ;IF NDAC HI
	LDA CIA+ICR
	AND #$02        ;TIMER B POSISTION (CIA)
	BEQ TBY4        ;IF NO TIMEOUT
	LDA TIMOUT      ;TIMEOUT SELECTION FLAG
	BMI TBY3        ;NO - LOOP
	BCC TBY3T       ;WAIT FULL 64US
;       
TBY5	LDA #TOOUT      ;SET TIMEOUT ON OUTPUT IN STATUS
	JSR UDST        ;UPDATE STATUS
;       
TBY6	LDA TPI1+PA     ;RELEASE DAV
	ORA #DAV
	STA TPI1+PA
;       
TBY7	LDA #$FF        ;RELEASE DATA BUS
	STA CIA+PRA     ;BUS FAILURE EXIT
	RTS
.SKIP 4
;        RBYTE -- INPUT BYTE FROM IEEE BUS.
;       
;        USES A REGISTER.
;        1 BYTE OF STACK SPACE.
;       
;        EXIT A = INPUT DATA BYTE.
;       
NACPTR	;********************************
NRBYTE
	LDA TPI1+PA     ;SET CONTROL LINES
	AND #$FF-TE-NDAC-REN ;PULL NDAC LOW, TE=DATA IN
	ORA #NRFD+DC    ;SAY READ FOR DATA
	STA TPI1+PA
;
RBY1	JSR TIMERO      ;RETURN C-CLEAR FOR CBMII
	BCC RBY2        ;C-CLEAR IS FIRST TIME THROUGH
RBY1T	SEC             ;C-SET IS SECOND TIME THROUGH
;       
RBY2	LDA TPI1+PA     ;GET IEEE CONTROL LINES
	AND #DAV
	BEQ RBY4        ;IF DATA AVAILABLE
	LDA CIA+ICR
	AND #$02        ;TIMER B (CIA)
	BEQ RBY2        ;IF NOT TIMED OUT
	LDA TIMOUT      ;GET TIMEOUT FLAG
	BMI RBY1        ;LOOP
	BCC RBY1T       ;GO THROUGH TWICE
;
RBY3	LDA #TOIN       ;SET TIMEOUT ON INPUT IN STATUS
	JSR UDST
	LDA TPI1+PA
	AND #$FF-NRFD-NDAC-TE ;NRFD & NDAC LO ON ERROR
	STA TPI1+PA
	LDA #CR         ;RETURN NULL INPUT
	RTS
.SKIP 2
RBY4
	LDA TPI1+PA     ;SAY NOT READ FOR DATA
	AND #$FF-NRFD
	STA TPI1+PA
	AND #EOI
	BNE RBY5        ;IF NOT EOI
	LDA #EOIST      ;SET EOI IN STATUS
	JSR UDST
;       
RBY5	LDA CIA+PRA     ;GET DATA
	EOR #$FF
;       
RBY6	PHA             ;SAVE DATA
	LDA TPI1+PA     ;SAY DATA ACCEPTED
	ORA #NDAC
	STA TPI1+PA
;       
RBY7	LDA TPI1+PA     ;GET IEEE CONTROL LINES
	AND #DAV
	BEQ RBY7        ;IF DAV HIGH
;       
	LDA TPI1+PA     ;SAY DAT NOT ACCPTED
	AND #$FF-NDAC
	STA TPI1+PA
	PLA             ;RETURN DATA IN A
	RTS
;
; SET UP FOR TIMEOUT (6526)
;
	.IFE SYSTEM <
TIMERO	LDA #$FF        ;SET TIMER FOR AT LEAST 32US
>
	.IFN SYSTEM <
TIMERO	LDA #$80        ;SET TIME FOR AT LEAST 32US
>
	STA CIA+TBHI
	LDA #$11        ;TURN ON TIMER CONTINOUS IN CASE OF OTHER IRQ'S
	STA CIA+CRB
	LDA CIA+ICR     ;CLEAR INTERRUPT
	CLC
	RTS
.END
; -------------------------------------------------------------
; ##### RS232 #####
.PAG 'RS232 ROUTINES 11/20/81'
RS232	JMP ERROR9      ;BAD DEVICE NUMBER
.SKI 5
;---------------------------------------------
; OPN232 - OPEN AN RS-232 CHANNEL
;   IF SA=1 THEN OUTPUT CHANNEL
;   IF SA=2 THEN INPUT  CHANNEL
;   IF SA=3 THEN BIDIRECTIONAL CHANNEL
;   IF SA>128 THEN ASCII CONVERSION ENABLED
;
;   FILENAME CONSISTS OF 0-4 BYTES
;  BYTE #1- CONTROL REGISTER 6551
;  BYTE #2- COMMAND REGISTER 6551
;  BYTE #3- C/R LF DELAY...60THS OF SEC   (UNIMPLEMENTED)
;  BYTE #4- AUTO C/R INSERT AFER XX CHARS (UNIMPLEMENTED)
;
;
;    ACTIONS:
;  1. CLEAR  RS232 STATUS:  RSSTAT
;  2. SET 6551 CONTRL (CTR) REGISTER
;  3. SET 6551 COMMAND (CDR) REGISTER
;       CDR BITS (7-4) = FILENAME BYTE 2 BITS (7-4)
;                (3-2) = 00  (XMITTER OFF)
;                (1)   = 1   (RECEIVER OFF)
;                (0)   = 0   (DTR OFF)
;  4. DO BUFFER ALLOCATION, IF NEEDED
;
;---------------------------------------------
OPN232	JSR RST232      ;RESET RS232 STATUS
	LDY #0
;
OPN020	CPY FNLEN       ;FILENAME ALL OUT ?
	BEQ OPN030      ;YES...
;
	JSR FNADRY
	STA M51CTR,Y
	INY
	CPY #4          ;ONLY FOUR BYTES IN ALL
	BNE OPN020
;
OPN030	LDA M51CTR      ;SET THE REGISTER
	STA ACIA+CTR
	LDA M51CDR      ;CLEAR UP CONFLICTS
	AND #$F2
	ORA #$02
	STA ACIA+CDR    ;EVERYTHING OFF
	CLC
	LDA SA          ;CHECK FOR BUFFERS NEEDED
	AND #$02
	BEQ OPN045      ;NO INPUT
;
	LDA RIDBE       ;SET UP POINTERS
	STA RIDBS
	LDA RIBUF+2     ;CHECK FOR ALLOCATION
	AND #$F0        ;$FF NOT ALLOCATED FLAG (SEE ALLOC ERROR CODES, TOO)
	BEQ OPN045      ;ALREADY ALLOCATED
	JSR REQ256      ;REQUEST 256 BYTES FOR STORAGE
	STA RIBUF+2     ;SAVE STARTING
	STX RIBUF
	STY RIBUF+1
OPN045	BCC OPN050
	JMP ERRORX
OPN050	RTS             ;C-CLR ALREADY ALLOCATED
.PAG 'RS232 - CONVERSIONS'
;----------------------------------------
; TOASCI - CONVERT CBM TEXT CODE TO
;  ASCII FOR VALID ASCII RANGES.
; ENTRY: .A - CBM TEXT CODE
; EXIT : .A - ASCII CODE
;----------------------------------------
TOASCI	CMP #'A'        ;CONVERT $41 TO $5A
	BCC TOA020
	CMP #$5B
	BCS TOA010
	ORA #$20        ; TO LOWER CASE ASCII
TOA010	CMP #$C1        ;CONVERT $C1 TO $DA
	BCC TOA020
	CMP #$DB
	BCS TOA020
	AND #$7F        ; TO UPPER CASE ASCII
TOA020	RTS
.SKI 3
;----------------------------------------
; TOCBM - CONVERT ASCII CODE TO CBM
;  TEXT CODE FOR VALID ASCII RANGES.
; ENTRY: .A - ASCII CODE
; EXIT : .A - CBM TEXT CODE
;----------------------------------------
TOCBM	CMP #'A'        ;CONVERT UPPER CASE ASCII
	BCC TOC020
	CMP #$5B
	BCS TOC010
	ORA #$80        ; TO $C1 TO $DA
TOC010	CMP #$61        ;CONVERT LOWER CASE ASCII
	BCC TOC020
	CMP #$7B
	BCS TOC020
	AND #$FF-$20    ;TO $41 - $5A
TOC020	RTS
.SKI 3
;---------------------------------------------------------------
;  XON232 - TURN 6551 TRANSMITTER ON, NO TRANSMIT INTERRUPTS
;        CDR BITS(3-2) = 10
;            BIT(1)    = 1
;---------------------------------------------------------------
XON232	LDA ACIA+CDR
	ORA #$09
	AND #$FB
	STA ACIA+CDR
	RTS
.PAG 'RS232 - ALLOCATE'
; REQ256 - REQUEST 256 BYTES OF SPACE
;  (DON'T CARE WHERE WE GET IT...)
;
REQ256	; LDA #$FF
	LDX #00
	LDY #01
.SKI 3
;-----------------------------------------------------------------------
; ALOCAT - ALLOCATE SPACE
;  ENTRY:
; *  .A- IF .A=$FF THEN DON'T CARE WHAT SEGMENT
; *  .A- IF .A=$80 THEN WE WANT BOTTOM OF MEMORY
; *  .A- IF .A=$40 THEN WE WANT TOP OF MEMORY
; *  .A- IF .A=$0X THEN WE NEED SEGMENT X
;    .X- LOW # OF BYTES NEEDED
;    .Y- HIGH # OF BYTES NEEDED
;
;  EXIT :
;    C-CLR  NO PROBLEM ALLOCATING SPACE
;     .A,.X,.Y IS START ADDRESS OF ALLOCATED SPACE
;    C-SET  PROBLEM WITH ALLOCATION
;     IF .A =$FF THEN ALLOCATION REFUSED (CANNOT CROSS SEGMENT BOUNDRYS)
; *   IF .A =$8X THEN BOTTOM OF MEMORY NEEDS TO BE CHANGED
;     IF .A =$4X THEN TOP OF MEMORY NEEDS TO BE CHANGED
; *   IF .A =$C0 THEN BOTTOM>TOP  !! FATAL ERROR !!
;     RETURN TO LANGUAGE
;
; *=> NOT IMPLEMENTED YET  10/30/81 RSR (ONLY TOP ALLOCATION)
;-----------------------------------------------------------------------
ALOCAT
;
;
TTTOP	TXA             ;CALC NEW HIADR
	SEC
	EOR #$FF
	ADC HIADR
	TAX
	TYA
	EOR #$FF
	ADC HIADR+1
	TAY
	LDA HIADR+2
	BCS TOP010
;
REFUSE	LDA #$FF        ;ALLOCATION REFUSED...CROSSED BOUNDRY
TOPBAD	ORA #$40        ;WANT TOP OF MEMORY CHANGED
	SEC
	RTS
;
TOP010	CPY MEMSIZ+1
	BCC TOPBAD      ;BELOW...
	BNE TOPXIT
	CPX MEMSIZ
	BCC TOPBAD      ;BELOW...
TOPXIT	STX HIADR
	STY HIADR+1
	CLC
	RTS
.SKI 5
;----------------------------------------------------------------
; RST232 - RESET RS232 AND DCD/DSR STATUS
;          NOTE, THE DCD AND DSR BITS OF RSSTAT REFLECT WHETHER A
;          DSR OR DCD ERROR OCCURED SINCE THE LAST TIME THE USER
;          EXAMINED RSSTAT.
;          DCDSR HAS THE DCD/DSR STATES PRIOR TO THEIR LAST STATE
;          CHANGES.
;-----------------------------------------------------------------
RST232	PHP
	SEI             ;DISABLE INTS
	LDA ACIA+SRSN
	AND #$60
	STA RSSTAT
	STA DCDSR
	PLP
	RTS
.END
; -------------------------------------------------------------
; ##### CHANNELIO #####
.PAG 'CHANNEL I/O'
;*****************************************
;* GETIN -- GET CHARACTER FROM CHANNEL   *
;*      CHANNEL IS DETERMINED BY DFLTN.  *
;* IF DEVICE IS 0, KEYBOARD QUEUE IS     *
;* EXAMINED AND A CHARACTER REMOVED IF   *
;* AVAILABLE.  DEVICES 1,3-31 ADVANCE TO *
;* BASIN.                                *
;*                                       *
;* EXIT:  .A = CHARACTER                 *
;*        CY = 1, STOP KEY ERROR FOR CAS-*
;*                CASSETES AND RS232     *
;*           = 0, OTHERWISE.             *
;*        Z  = 1, IF KBD AND QUEUE EMPTY.*
;*****************************************
;
NGETIN	LDA DFLTN       ;CHECK DEVICE
	BNE GN10        ;NOT KEYBOARD
;
	LDA NDX         ;QUEUE INDEX
	ORA KYNDX       ;CHECK FUNCTION KEY QUE
	BEQ GN20        ;NOBODY THERE...EXIT
;
	SEI
	JSR LP2         ;GO REMOVE A CHARACTER
	CLC
	RTS
;
GN10	CMP #2          ;IS IT RS-232
	BEQ GN232
	JMP BASIN       ;NO...USE BASIN
;
GN232	STY XSAV        ;SAVE .Y...
	STX SAVX        ;..AND .X
	LDY RIDBS       ;GET LAST BYTE ADDRESS
	CPY RIDBE       ;SEE IF BUFFER EMPTYY
	BNE GN15        ;RS232 BUFFER NOT EMPTY...
;
	LDA ACIA+CDR    ;MAKE SURE RECEIVER IS ON
	AND #$FD
	ORA #$01        ;BITS(10) = 01 NOW
	STA ACIA+CDR
	LDA RSSTAT      ;SET EMPTY INPUT BUFFER CONDITION
	ORA #$10
	STA RSSTAT
	LDA #0          ;RETURN A NULL BYTE
	BEQ GNEXIT      ;ALWAYS
;
GN15	LDA RSSTAT      ;CLEAR EMPTY BUFFER STATUS
	AND #$EF
	STA RSSTAT
	LDX I6509
	LDA RIBUF+2
	STA I6509       ; POINT AT BUFFER
	LDA (RIBUF)Y    ;GET LAST CHAR
	STX I6509       ; RESTORE
	INC RIDBS       ;INC TO NEXT POSISTION
	BIT SA          ;CHECK FOR ASCII FLAG
	BPL GNEXIT      ;NOT ON...
	JSR TOCBM       ;CONVERT TO CBM CODE
GNEXIT	LDY XSAV        ;RESTORE .Y
	LDX SAVX
GN20	CLC             ;GOOD RETURN
	RTS
.PAG 'CHANNEL I/O'
;***************************************
;* BASIN-- INPUT CHARACTER FROM CHANNEL*
;*     INPUT DIFFERS FROM GET ON DEVICE*
;* #0 FUNCTION WHICH IS KEYBOARD. THE  *
;* SCREEN EDITOR MAKES READY AN ENTIRE *
;* LINE WHICH IS PASSED CHAR BY CHAR   *
;* UP TO THE CARRIAGE RETURN.  NOTE,   *
;* RS232 USES GETIN TO GET EACH CHAR.  *
;* OTHER DEVICES ARE:                  *
;*      0 -- KEYBOARD                  *
;*      1 -- CASSETTE #1               *
;*      2 -- RS232                     *
;*      3 -- SCREEN                    *
;*   4-31 -- IEEE   BUS                *
;*                                     *
;* EXIT: CY=1, STOP KEY ERROR FOR CAS- *
;*             SETTES AND RS232.       *
;*       CY=0, OTHERWISE.              *
;*                                     *
;*       ALL OTHER ERRORS MUST BE DE-  *
;*       TECTED BY CHECKING STATUS !   *
;***************************************
;
NBASIN	LDA DFLTN       ;CHECK DEVICE
	BNE BN10        ;IS NOT KEYBOARD...
;
;INPUT FROM KEYBOARD
;
	LDA PNTR        ;SAVE CURRENT...
	STA LSTP        ;... CURSOR COLUMN
	LDA TBLX        ;SAVE CURRENT...
	STA LSXP        ;... LINE NUMBER
	JMP BN15        ;BLINK CURSOR UNTIL RETURN
;
BN10	CMP #3          ;IS INPUT FROM SCREEN?
	BNE BN20        ;NO...
;
	STA CRSW        ;FAKE A CARRIAGE RETURN
	LDA SCRT        ;SAY WE ENDED...
	STA INDX        ;...UP ON THIS LINE
BN15	JSR LOOP5       ;PICK UP CHARACTERS
	CLC
	RTS
;
BN20	BCS BN30        ;DEVICES >3
	CMP #2          ;RS232?
	BEQ BN50
;
;INPUT FROM CASSETTE BUFFERS
;
	.IFN SYSAGE <
	STX XSAV
	JSR JTGET
	BCS JTG37       ;STOP KEY/ERROR
	PHA
	JSR JTGET
	BCS JTG36       ;STOP KEY/ERROR
	BNE JTG35       ;NOT AN END OF FILE
	LDA #64         ;TELL USER EOF
	JSR UDST        ;IN STATUS
JTG35	DEC BUFPT
	LDX XSAV        ;.X PRESERVED
	PLA             ;CHARACTER RETURNED
;C-CLEAR FROM JTGET
	RTS             ;ALL DONE
;
JTG36	TAX             ;SAVE ERROR INFO
	PLA             ;TOSS DATA
	TXA             ;RESTORE ERROR
JTG37	RTS             ;ERROR RETURN C-SET FROM JTGET
.SKI 3
;GET A CHARACTER FROM APPROPRIATE
;CASSETTE BUFFER
;
JTGET	JSR JTP20       ;BUFFER POINTER WRAP?
	BNE JTG10       ;NO...
	JSR RBLK        ;YES...READ NEXT BLOCK
	BCS BN33        ;STOP KEY PRESSED
	LDA #0
	STA BUFPT       ;POINT TO BEGIN.
	BEQ JTGET       ;BRANCH ALWAYS
;
JTG10	JSR TAPERY      ;GET CHAR FROM BUFFER
	CLC             ;GOOD RETURN
	RTS
>
	.IFE SYSAGE <
	JSR XTAPE       ;GO TO TAPE INDIRECT
>
.SKI 3
;INPUT FROM IEEE   BUS
;
BN30	LDA STATUS      ;STATUS FROM LAST
	BEQ BN35        ;WAS GOOD
BN31	LDA #$D         ;BAD...ALL DONE
BN32	CLC             ;VALID DATA
BN33	RTS
;
BN35	JSR ACPTR       ;GOOD...HANDSHAKE
	CLC
	RTS
;
;INPUT FROM RS232
;
BN50	JSR GETIN       ;GET DATA
	BCS BN33        ;ERROR RETURN
	CMP #00         ;NON-NULL MEANS GOOD DATA ALWAYS
	BNE BN32        ;HAVE VALID DATA
	LDA RSSTAT      ;CHECK FOR VALID NULL BYTE
	AND #$10
	BEQ BN32        ;OK
	LDA RSSTAT      ;BUFFER EMPTY, CHECK FOR ERRORS IN DSR, DCD
	AND #DSRERR+DCDERR
	BNE BN31        ;HAVE ERROR...SEND C/R'S
	JSR STOP        ;CHECK FOR STOP KEY DEPRESSED
	BNE BN50        ;NO, STAY IN LOOP 'TIL WE GET SOMETHING
	SEC             ;.A=0, STOP KEY ERROR
	RTS
.PAG 'CHANNEL OUTPUT'
;***************************************
;* BSOUT -- OUT CHARACTER TO CHANNEL   *
;*     DETERMINED BY VARIABLE DFLTO:   *
;*     0 -- INVALID                    *
;*     1 -- CASSETTE #1                *
;*     2 -- RS232                      *
;*     3 -- SCREEN                     *
;*  4-31 -- IEEE   BUS                 *
;*                                     *
;* EXIT:  CY=1, STOP KEY ERROR FOR CAS-*
;*              SETTES AND RS232.      *
;*        CY=0, OTHERWISE.             *
;*                                     *
;*       NOTE, OTHER ERRORS MUST BE DE-*
;*       TECTED BY CHECKING STATUS !   *
;***************************************
;
NBSOUT	PHA             ;PRESERVE .A
	LDA DFLTO       ;CHECK DEVICE
	CMP #3          ;IS IT THE SCREEN?
	BNE BO10        ;NO...
;
;PRINT TO CRT
;
	PLA             ;RESTORE DATA
	JSR PRT         ;PRINT ON CRT
	CLC
	RTS
;
BO10
	BCC BO20        ;DEVICE 1 OR 2
;
;PRINT TO IEEE   BUS
;
	PLA
	JSR CIOUT
	CLC
	RTS
;
;PRINT TO CASSETTE DEVICES
;
BO20	CMP #2          ;RS232?
	BEQ BO50
;
	PLA
	.IFN SYSAGE <
CASOUT	STA T1
;
;PRESERVE REGISTERS
;
	PHA
	TXA
	PHA
	TYA
	PHA
;
	JSR JTP20       ;CHECK BUFFER POINTER
	BNE JTP10       ;HAS NOT REACHED END
	JSR WBLK        ;WRITE FULL BUFFER
	BCS RSTOR       ;ABORT ON STOP KEY
;
;PUT BUFFER TYPE BYTE
;
	LDA #BDF
	JSR TAPZWY      ;WRITE TO BUFFER BEGINNING
;
;RESET BUFFER POINTER
;
	INY             ;MAKE .Y=1
	STY BUFPT       ;BUFPT=1
;
JTP10	LDA T1
	JSR TAPEWY      ;DATA TO BUFFER
;
;RESTORE .X AND .Y
;
	CLC             ;GOOD RETURN
RSTOR	PLA
	TAY
	PLA
	TAX
>
	.IFE SYSAGE <
	JSR XTAPE       ;GO TO TAPE INDIRECT
>
RSTBO	PLA             ;RESTORE .A (ERROR EXIT FOR 232)
	BCC RSTOR1      ;NO ERROR
	LDA #00         ;STOP ERROR IF C-SET
RSTOR1	RTS
;
;OUTPUT TO RS232
;
BO50	STX T1          ;PUT IN A TEMP
	STY T2
;
BO55	LDA RSSTAT      ;CHECK FOR DSR,DCD ERRORS
	AND #$60
	BNE BO90        ;BAD....
;
BO70	PLA             ;RESTORE DATA
	BIT SA          ;CHECK FOR CBM TO ASCII CONVERSION
	BPL BO80        ;NONE
	JSR TOASCI      ;CONVERT CBM TO ASCII
BO80	STA ACIA+DRSN   ;SENDING DATA
	PHA
;
BO60	LDA RSSTAT
	AND #$60        ;DCD,DSR ERRORS?
	BNE BO90        ;YES...
BO64	LDA ACIA+SRSN
	AND #$10        ;TRANSMIT BUFFER EMPTY?
	BNE BO90        ;YES, TRANSMIT DONE!
	JSR STOP        ;CHECK FOR STOP KEY
	BNE BO60        ;TRY AGAIN
BO66	SEC             ;STOP KEY/ERROR RETURN
	BCS RSTBO       ;EXIT....
;
BO90	PLA
	LDX T1          ;GO RESTORE
	LDY T2
	CLC
	RTS
.END
; -------------------------------------------------------------
; ##### OPENCHANNEL #####
.PAG 'OPEN CHANNEL'
;***************************************
;* NCHKIN -- OPEN CHANNEL FOR INPUT    *
;*                                     *
;* THE NUMBER OF THE LOGICAL FILE TO BE*
;* OPENED FOR INPUT IS PASSED IN .X.   *
;* CHKIN SEARCHES THE LOGICAL FILE     *
;* TO LOOK UP DEVICE AND COMMAND INFO. *
;* ERRORS ARE REPORTED IF THE DEVICE   *
;* WAS NOT OPENED FOR INPUT ,(E.G.     *
;* CASSETTE WRITE FILE), OR THE LOGICAL*
;* FILE HAS NO REFERENCE IN THE TABLES.*
;* DEVICE 0, (KEYBOARD), AND DEVICE 3  *
;* (SCREEN), REQUIRE NO TABLE ENTRIES  *
;* AND ARE HANDLED SEPARATE.           *
;***************************************
;
NCHKIN	JSR LOOKUP      ;SEE IF FILE KNOWN
	BEQ JX310       ;YUP...
;
	JMP ERROR3      ;NO...FILE NOT OPEN
;
JX310	JSR JZ100       ;EXTRACT FILE INFO
;
	LDA FA
	BEQ JX320       ;IS KEYBOARD...DONE.
;
;COULD BE SCREEN, KEYBOARD, OR SERIAL
;
	CMP #3
	BEQ JX320       ;IS SCREEN...DONE.
	BCS JX330       ;IS SERIAL...ADDRESS IT
	CMP #2          ;RS232?
	BNE JX315       ;NO...
;
; RS232 CHANNEL
;
	LDA SA
	AND #02         ;CHECK FOR INPUT
	BEQ JX316       ;NOT INPUT FILE
	AND ACIA+CDR    ;CHECK IF RUNNING
	BEQ JX312       ;IS...DONE ?? (RCEIVER ON => YES)
	EOR #$FF        ;FLIP ALL BITS
	AND ACIA+CDR    ;TURN ON...
	ORA #$01        ;TURN ON DTR ;BITS(10)=01
	PHA
	JSR RST232      ;RESET RS232 STATUS
	PLA
	STA ACIA+CDR    ;SET COMMAND
JX312	LDA #2          ;DEVICE
	BNE JX320       ;BRA...DONE
;
;SOME EXTRA CHECKS FOR TAPE
;
JX315
	.IFN SYSAGE <
	LDX SA
	CPX #$60        ;IS COMMAND A READ?
	BEQ JX320       ;YES...O.K....DONE
>
	.IFE SYSAGE <
	JSR XTAPE       ;GOTO TAPE INDIRECT
>
;
JX316	JMP ERROR6      ;NOT INPUT FILE
;
JX320	STA DFLTN       ;ALL INPUT COME FROM HERE
;
	CLC             ;GOOD EXIT
	RTS
;
;AN SERIAL DEVICE HAS TO BE A TALKER
;
JX330	TAX             ;DEVICE # FOR DFLTO
	JSR TALK        ;TELL HIM TO TALK
;
	LDA SA          ;A SECOND?
	BPL JX340       ;YES...SEND IT
	JSR TKATN       ;NO...LET GO
	JMP JX350
;
JX340	JSR TKSA        ;SEND SECOND
;
JX350	TXA
	BIT STATUS      ;DID HE LISTEN?
	BPL JX320       ;YES
;
	JMP ERROR5      ;DEVICE NOT PRESENT
.PAG 'OPEN CHANNEL OUT'
;***************************************
;* CHKOUT -- OPEN CHANNEL FOR OUTPUT   *
;*                                     *
;* THE NUMBER OF THE LOGICAL FILE TO BE*
;* OPENED FOR OUTPUT IS PASSED IN .X.  *
;* CHKOUT SEARCHES THE LOGICAL FILE    *
;* TO LOOK UP DEVICE AND COMMAND INFO. *
;* ERRORS ARE REPORTED IF THE DEVICE   *
;* WAS NOT OPENED FOR INPUT ,(E.G.     *
;* KEYBOARD), OR THE LOGICAL FILE HAS  *
;* REFERENCE IN THE TABLES.            *
;* DEVICE 0, (KEYBOARD), AND DEVICE 3  *
;* (SCREEN), REQUIRE NO TABLE ENTRIES  *
;* AND ARE HANDLED SEPARATE.           *
;***************************************
;
NCKOUT	JSR LOOKUP      ;IS FILE IN TABLE?
	BEQ CK5         ;YES...
;
	JMP ERROR3      ;NO...FILE NOT OPEN
;
CK5	JSR JZ100       ;EXTRACT TABLE INFO
;
	LDA FA          ;IS IT KEYBOARD?
	BNE CK10        ;NO...SOMETHING ELSE.
;
CK20	JMP ERROR7      ;YES...NOT OUTPUT FILE
;
;COULD BE SCREEN,SERIAL,OR TAPES
;
CK10	CMP #3
	BEQ CK30        ;IS SCREEN...DONE
	BCS CK40        ;IS SERIAL...ADDRESS IT
	CMP #2          ;RS232?
	BNE CK15
;
; RS232 OUTPUT
;
	LDA SA          ;CHECK IF OUTPUT FILE
	LSR A
	BCC CK20        ;NOT SO...
	JSR RST232      ;RESET RS232 STATUS
	JSR XON232      ;MAKE SURE TRANSMIT IS ON
	LDA #2          ;DEVICE#
	BNE CK30        ;BRA...DONE
;
;SPECIAL TAPE CHANNEL HANDLING
;
	.IFE SYSAGE <
CK15	JSR XTAPE       ;GOTO SYSTEM TAPE INDIRECT
>
	.IFN SYSAGE <
CK15	LDX SA
	CPX #$60        ;IS COMMAND READ?
	BEQ CK20        ;YES...ERROR
>
;
CK30	STA DFLTO       ;ALL OUTPUT GOES HERE
;
	CLC             ;GOOD EXIT
	RTS
;
CK40	TAX             ;SAVE DEVICE FOR DFLTO
	JSR LISTN       ;TELL HIM TO LISTEN
;
	LDA SA          ;IS THERE A SECOND?
	BPL CK50        ;YES...
;
	JSR SCATN       ;NO...RELEASE LINES
	BNE CK60        ;BRANCH ALWAYS
;
CK50	JSR SECND       ;SEND SECOND...
;
CK60	TXA
	BIT STATUS      ;DID HE LISTEN?
	BPL CK30        ;YES...FINISH UP
;
	JMP ERROR5      ;NO...DEVICE NOT PRESENT
.END
; -------------------------------------------------------------
; ##### CLOSE #####
.PAG 'CLOSE  2/15/83'
;*************************************
;* NCLOSE -- CLOSE LOGICAL FILE      *
;*                                   *
;* ENTER:                            *
;*     CY =1 ,TRANSMIT CLOSE TO DEV- *
;*            ICE.                   *
;*     CY =0 ,ONLY REMOVE FROM KERNAL*
;*            TABLES.                *
;*                                   *
;*     THE LOGICAL FILE NUMBER OF THE*
;* FILE TO BE CLOSED IS PASSED IN .A.*
;* KEYBOARD, SCREEN, AND FILES NOT   *
;* OPEN PASS STRAIGHT THROUGH. TAPE  *
;* FILES OPEN FOR WRITE ARE CLOSED BY*
;* DUMPING THE LAST BUFFER AND       *
;* CONDITIONALLY WRITING AN END OF   *
;* TAPE BLOCK.SERIAL FILES ARE CLOSED*
;* BY SENDING A CLOSE FILE COMMAND IF*
;* A SECONDARY ADDRESS WAS SPECIFIED *
;* IN ITS OPEN COMMAND.              *
;*************************************
;
NCLOSE	PHP             ;SAVE CY FLAG
	JSR JLTLK       ;LOOK FILE UP
	BEQ JX110       ;WAS OPEN...CONTINUE
	PLP
	CLC             ;WAS NEVER OPEN...NO ERROR
	RTS
;
JX110	JSR JZ100       ;EXTRACT TABLE DATA
	PLP             ;RETRIEVE CY FLAG
	TXA             ;SAVE TABLE INDEX
	PHA
	BCC JX150       ;CLOSE OUT TABLE ENTRIES ONLY
;
	LDA FA          ;CHECK DEVICE NUMBER
	BEQ JX150       ;IS KEYBOARD...DONE
	CMP #3
	BEQ JX150       ;IS SCREEN...DONE
	BCS JX120       ;IS IEEE...PROCESS
	CMP #2          ;RS232?
	BNE JX115       ;NO...
;
; CLOSE RS-232 FILE
;
CLS232	LDA #0
	STA ACIA+CDR    ;DO A SOFT RESET
	BEQ JX150       ;JMP...REMOVE FILE
;
;
;CLOSE CASSETTE FILE
;
	.IFN SYSAGE <
JX115	LDA SA          ;WAS IT A TAPE READ?
	AND #$F
	BEQ JX150       ;YES
;
	JSR ZZZ         ;NO. . .IT IS WRITE
	LDA #0          ;END OF FILE CHARACTER
	JSR CASOUT      ;PUT IN END OF FILE
	JSR WBLK        ;EMPTY LAST BUFFER
	BCS JX200       ;STOP KEY PRESSED
;
	LDA SA
	CMP #$62        ;WRITE END OF TAPE BLOCK?
	BNE JX150       ;NO...
;
	LDA #EOT
	JSR TAPEH       ;WRITE END OF TAPE BLOCK
	JMP JX150
>
	.IFE SYSAGE <
JX115	PLA             ;CASSETTE NOW CLOSES THE CHANNEL...
	JSR JX151       ;BEFORE TRANSMITTING OUT THE FINAL DATA
	JSR XTAPE       ;GOTO TAPE INDIRECT
>
;
;CLOSE AN IEEE FILE
;
JX120	JSR CLSEI
;
;ENTRY TO REMOVE A GIVE LOGICAL FILE
;FROM TABLE OF LOGICAL, PRIMARY,
;AND SECONDARY ADDRESSES
;
JX150	PLA             ;GET TABLE INDEX OFF STACK
JX151	TAX             ;ENTRY FOR CASSETTE SPECIAL
	DEC LDTND
	CPX LDTND       ;IS DELETED FILE AT END?
	BEQ JX160       ;YES...DONE
;
;DELETE ENTRY IN MIDDLE BY MOVING
;LAST ENTRY TO THAT POSITION.
;
	LDY LDTND
	LDA LAT,Y
	STA LAT,X
	LDA FAT,Y
	STA FAT,X
	LDA SAT,Y
	STA SAT,X
JX160	CLC
JX170	RTS             ;CLOSE EXIT
	.IFN SYSAGE <
JX200	TAX             ;STOP KEY EXIT
	PLA
	TXA             ;RESTORE ERROR
	RTS
>
.SKI 5
;LOOKUP TABLIZED LOGICAL FILE DATA
;
LOOKUP	LDA #0
	STA STATUS
	TXA
JLTLK	LDX LDTND
JX600	DEX
	BMI LKUPS4
	CMP LAT,X
	BNE JX600
	CLC
	RTS
.SKI 5
;ROUTINE TO FETCH TABLE ENTRIES
;
JZ100	LDA LAT,X
	STA LA
	LDA FAT,X
	STA FA
	LDA SAT,X
	STA SA
JZ101	RTS
.SKI 5
;
;SA IS PASSED IN .Y
;ROUTINE LOOKS FOR MATCH IN TABLES
;CARRY SET IF NOT PRESENT
;CARRY CLEAR:
;.A=LA,.X=FA,.Y=SA
;
LKUPSA	TYA
	LDX LDTND
LKUPS2	DEX
	BMI LKUPS4
	CMP SAT,X
	BNE LKUPS2
	CLC
LKUPS3	JSR JZ100       ;GET TABLE DATA
	TAY
	LDA LA
	LDX FA
	RTS
LKUPS4	SEC
	RTS             ;NOT FOUND EXIT
.SKI 5
;LA IS PASSED IN .A
;ROUTINE LOOKS FOR MATCH IN TABLES
;CARRY SET IF NOT FOUND
;CARRY CLEAR:
;.A=LA,.X=FA,.Y=SA
;
LKUPLA	TAX
	JSR LOOKUP
	BCC LKUPS3
	RTS
.END
; -------------------------------------------------------------
; ##### CLALL #####
.PAG 'CLALL 05/31/83'
;******************************************
;* NCLALL -- CLOSE ALL LOGICAL FILES      *
;*      DELETES ALL TABLE ENTRIES AND     *
;* RESTORES DEFAULT I/O CHANNELS          *
;* AND CLEARS IEEE PORT DEVICES           *
;******************************************
;
;------------------------------------------
; NEW NCALL
;  CLOSES ALL FILES UNTILL DONE OR AN
;  ERROR OCCURS.
;  ENTRY:
;    C-CLR => CLOSE ALL FILES
;    C-SET => .A = FA (DEVICE TO BE CLOSED)
;------------------------------------------
NCLALL	ROR XSAV        ;SAVE CARRY
	STA SAVX        ;SAVE .A
NCL010	LDX LDTND       ;SCAN INDEX
NCL020	DEX
	BMI NCLRCH      ;ALL DONE...CLEAR CHANNELS (DCLOSE PATCH 5/31/83)
	BIT XSAV        ;CHECK FOR FIXED FA
	BPL NCL030      ;NONE...
	LDA SAVX
	CMP FAT,X
	BNE NCL020      ;NO MATCH...
NCL030	LDA LAT,X       ;CLOSE THIS LA
	SEC             ;C-SET REQUIRED TO CLOSE
	JSR CLOSE
	BCC NCL010      ;
;
NCL040	LDA #0          ;ORIGINAL ENTRY FOR NCLALL
	STA LDTND       ;FORGET ALL FILES
.SKI 3
;********************************************
;* NCLRCH -- CLEAR CHANNELS                 *
;*   UNLISTEN OR UNTALK IEEE DEVICES, BUT   *
;* LEAVE OTHERS ALONE.  DEFAULT CHANNELS    *
;* ARE RESTORED.                            *
;********************************************
;
NCLRCH	LDX #3
	CPX DFLTO       ;IS OUTPUT CHANNEL IEEE?
	BCS JX750       ;NO...
;
	JSR UNLSN       ;YES...UNLISTEN IT
;
JX750	CPX DFLTN       ;IS INPUT CHANNEL IEEE?
	BCS CLALL2      ;NO...
;
	JSR UNTLK       ;YES...UNTALK IT
;
;RESTORE DEFAULT VALUES
;
;
CLALL2	LDX #3
	STX DFLTO       ;OUTPUT CHAN=3=SCREEN
	LDA #0
	STA DFLTN       ;INPUT CHAN=0=KEYBOARD
	RTS
.END
; -------------------------------------------------------------
; ##### OPEN #####
.PAG 'OPEN FILE'
;***********************************
;*                                 *
;* OPEN FUNCTION                   *
;*                                 *
;* ENTER: CY=1, TRANSMIT COMMAND TO*
;*              DEVICE.            *
;*        CY=0, PERFORM OPEN OPERA-*
;*              TION.              *
;*                                 *
;* LA, FA, SA MUST BE SET UP PRIOR *
;* TO THE CALL TO THIS ROUTINE, AS *
;* WELL AS THE FILE NAME DESCRIPT- *
;* TOR.                            *
;*                                 *
;***********************************
;
NOPEN
	BCC OP000       ;DO OPEN
	JMP TRANR       ;DO TRANSMIT
.SKI 4
;***********************************
;*                                 *
;* CREATE AN ENTRY IN THE LOGICAL  *
;* FILES TABLES CONSISTING OF      *
;* LOGICAL FILE NUMBER--LA, DEVICE *
;* NUMBER--FA, AND SECONDARY CMD-- *
;* SA.                             *
;*                                 *
;* A FILE NAME DESCRIPTOR, FNADR & *
;* FNLEN, IS PASSED TO THIS ROUTINE*
;*                                 *
;***********************************
;
OP000	LDX LA          ;CHECK FILE #
;BNE OP98 ;IS NOT THE KEYBOARD
;
;JMP ERROR6 ;NOT INPUT FILE...
;
OP98	JSR LOOKUP      ;SEE IF IN TABLE
	BNE OP100       ;NOT FOUND...O.K.
;
	JMP ERROR2      ;FILE OPEN
;
OP100	LDX LDTND       ;LOGICAL DEVICE TABLE END
	CPX #10         ;MAXIMUM # OF OPEN FILES
	BCC OP110       ;LESS THAN 10...O.K.
;
	JMP ERROR1      ;TOO MANY FILES
;
OP110	INC LDTND       ;NEW FILE
	LDA LA
	STA LAT,X       ;STORE LOGICAL FILE #
	LDA SA
	ORA #$60        ;MAKE SA AN IEEE COMMAND
	STA SA
	STA SAT,X       ;STORE COMMAND #
	LDA FA
	STA FAT,X       ;STORE DEVICE #
;
;PERFORM DEVICE SPECIFIC OPEN TASKS
;
	BEQ OP175       ;IS KEYBOARD...DONE.
	CMP #3
	BEQ OP175       ;IS SCREEN...DONE.
	BCC OP150       ;ARE CASSETTES 1 & 2
;
	JSR OPENI       ;IS ON IEEE...OPEN IT
	BCC OP175       ;BRANCH ALWAYS...DONE
;
;PERFORM TAPE OPEN STUFF
;
OP150	CMP #2
	BNE OP152
;
	JMP OPN232
;
	.IFN SYSAGE <
OP152	JSR ZZZ         ;SEE IF TAPE BUFFER
	BCS OP180       ;ERROR RETURNED
;
OP155	LDA SA
	AND #$F         ;MASK OFF COMMAND
	BNE OP200       ;NON ZERO IS TAPE WRITE
;
;OPEN CASSETE TAPE FILE TO READ
;
	JSR CSTE1       ;TELL "PRESS PLAY"
	BCS OP180       ;STOP KEY PRESSED
;
	JSR LUKING      ;TELL USER "SEARCHING"
;
	LDA FNLEN
	BEQ OP170       ;LOOKING FOR ANY FILE
;
	JSR FAF         ;LOOKING FOR NAMED FILE
	BCC OP171       ;FOUND IT!!!
	BEQ OP180       ;STOP KEY PRESSED
;
OP160	JMP ERROR4      ;FILE NOT FOUND
;
OP170	JSR FAH         ;GET ANY OLD HEADER
	BEQ OP180       ;STOP KEY PRESSED
	BCC OP171       ;ALL O.K.
	BCS OP160       ;FILE NOT FOUND...
;
;OPEN CASSETTE TAPE FOR WRITE
;
OP200	JSR CSTE2       ;TELL "PRESS PLAY AND RECORD"
	BCS OP180       ;STOP KEY PRESSED
	LDA #BDFH       ;DATA FILE HEADER TYPE
	JSR TAPEH       ;WRITE IT
	BCS OP180       ;EXIT IF STOP KEY PRESSED...
;
;FINISH OPEN FOR TAPE READ/WRITE
;
OP171
	LDA #BUFSZ-1    ;ASSUME FORCE READ
;
	LDY SA
	CPY #$60        ;OPEN FOR READ?
	BEQ OP172
;
;SET POINTERS FOR BUFFERING DATA
;
	LDA #BDF        ;TYPE FLAG FOR BLOCK
	JSR TAPZWY      ;TO BEGIN OF BUFFER
	TYA
;
OP172	STA BUFPT       ;POINT TO DATA
>
	.IFE SYSAGE <
OP152	JSR XTAPE       ;GOTO TAPE DEVICE INDIRECT
>
OP175	CLC             ;FLAG GOOD OPEN
OP180	RTS             ;EXIT IN PEACE
.SKI 5
OPENI	LDA SA
	BMI OP50        ;NO SA...DONE
;
	LDY FNLEN
	BEQ OP50        ;NO FILE NAME...DONE
;
	LDA FA
	JSR LISTN       ;DEVICE LA TO LISTEN
;
	LDA SA
	ORA #$F0
OPENIB	JSR SECND
;
	LDA STATUS      ;ANYBODY HOME?
	BPL OP35        ;YES...CONTINUE
;
;THIS ROUTINE IS CALLED BY OTHER
;KERNAL ROUTINES WHICH ARE CALLED
;DIRECTLY BY OS.  KILL RETURN
;ADDRESS TO RETURN TO OS.
;
	PLA
	PLA
	JMP ERROR5      ;DEVICE NOT PRESENT
;
OP35	LDA FNLEN
	BEQ OP45        ;NO NAME...DONE SEQUENCE
;
;SEND FILE NAME OVER IEEE
;
	LDY #0
OP40	JSR FNADRY
	JSR CIOUT
	INY
	CPY FNLEN
	BNE OP40
;
OP45	JSR UNLSN
;
OP50	CLC             ;NO  ERROR
	RTS
.SKI 4
;*****************************************
;*  TRANSMIT COMMAND TO DEVICE           *
;*                                       *
;*   FNLEN,FNADR MUST BE SET UP ALREADY  *
;*   TO CONTAIN THE COMMAND STRING.      *
;*   FA MUST BE SET FOR THE DEVICE.      *
;*****************************************
TRANR
	LDA FA
	JSR LISTN
	LDA #$6F
	STA SA
	JMP OPENIB
.END
; -------------------------------------------------------------
; ##### LOAD #####
.PAG 'LOAD FUNCTION'
;**************************************
;* LOAD RAM FUNCTION     10/30/81     *
;*                                    *
;*  LOADS FROM CASSETTE 1 OR 2, OR    *
;*  IEEE BUS DEVICES >=4 TO 31 AS     *
;*  DETERMINED BY CONTENTS OF         *
;*  VARIABLE FA.                      *
;* ENTRY:                             *
;*   .A(BIT 7)=0 PERFORMS LOAD        *
;*   .A(BIT 7)=1 PERFORMS VERIFY      *
;*   .A(BITS 0123)=START SEGMENT      *
;*   .X=START ADDRESS LOW             *
;*   .Y=START ADDRESS HIGH            *
;*   IF .X=$FF & .Y=$FF => FIXED LOAD *
;* EXIT:                              *
;*   .A(BITS 0123)=END SEGMENT        *
;*   .X=END ADDRESS LOW               *
;*   .Y=END ADDRESS HIGH              *
;*                                    *
;**************************************
.SKI 3
NLOAD	STX RELSAL      ;SAVE ALT ADDRESS
	STY RELSAH
	STA VERCK       ;SET VERIFY FLAG (N)
	STA RELSAS      ;SAVE START ADDRESS
	LDA #0          ;CLEAR STATUS
	STA STATUS
;
	LDA FA          ;CHECK DEVICE NUMBER
	BNE LD20
;
LD10	JMP ERROR9      ;BAD DEVICE #-KEYBOARD
;
LD20	CMP #3
	BEQ LD10        ;DISALLOW SCREEN LOAD
	BCS *+5
	JMP LD100       ;HANDLE TAPES DIFFERENT
;
;LOAD FROM CBM IEEE DEVICE
;
	LDA #$60        ;SPECIAL LOAD COMMAND
	STA SA
;
	LDY FNLEN       ;MUST HAVE FILE NAME
	BNE LD25        ;YES...OK
;
	JMP ERROR8      ;MISSING FILE NAME
;
LD25	JSR LUKING      ;TELL USER LOOKING
	JSR OPENI       ;OPEN THE FILE
;
	LDA FA
	JSR TALK        ;ESTABLISH THE CHANNEL
	LDA SA
	JSR TKSA        ;TELL IT TO LOAD
;
	JSR ACPTR       ;GET FIRST BYTE
	STA EAL
	STA STAL
;
	LDA STATUS      ;TEST STATUS FOR ERROR
	LSR A
	LSR A
	BCC *+5         ;FILE  FOUND...
;
	JMP ERROR4      ;FILE NOT FOUND ERROR
;
	JSR ACPTR
	STA EAH
	STA STAH
;
	JSR LODING      ;TELL USER LOADING
;
;
;TEST FOR FIXED OR MOVEABLE LOAD
;
	LDA RELSAS      ;NO SEGMENT BYTE IN STORAGE ***
	STA EAS
	STA STAS
	LDA RELSAL
	AND RELSAH
	CMP #$FF
	BEQ LD40        ;FIXED LOAD
;
	LDA RELSAL
	STA EAL
	STA STAL
	LDA RELSAH
	STA EAH
	STA STAH
;
LD40	LDA #$FD        ;MASK OFF TIMEOUT
	AND STATUS
	STA STATUS
;
	JSR STOP        ;STOP KEY?
	BNE LD45        ;NO...
;
	JMP BREAK       ;STOP KEY PRESSED
;
LD45	JSR ACPTR       ;GET BYTE OFF IEEE
	TAX
	LDA STATUS      ;WAS THERE A TIMEOUT?
	LSR A
	LSR A
	BCS LD40        ;YES...TRY AGAIN
	TXA
; CHANGE INDIRECT PAGES
	LDX I6509
	LDY EAS
	STY I6509
	LDY #0
	BIT VERCK       ;PERFORMING VERIFY?
	BPL LD50        ;NO...LOAD
	STA SAL         ;USE AS A TEMP
	LDA (EAL)Y
	CMP SAL
	BEQ LD60        ;OKAY
	LDA #SPERR      ;NO GOOD...VERIFY ERROR
	JSR UDST        ;UPDATE STATUS
	.BYT $AD        ;SKIP NEXT STORE
;
LD50	STA (EAL)Y
LD60	STX I6509       ;RESTORE INDIRECT
	INC EAL         ;INCREMENT STORE ADDR
	BNE LD64
	INC EAH
	BNE LD64
	INC EAS
	LDA #2          ;SKIP $0000 $0001
	STA EAL
LD64	BIT STATUS      ;EOI?
	BVC LD40        ;NO...CONTINUE LOAD
;
	JSR UNTLK       ;CLOSE CHANNEL
	JSR CLSEI       ;CLOSE THE FILE
	JMP LD180       ;EXIT IEEE LOAD
;
LD90	JMP ERROR4      ;FILE NOT FOUND
;
;LOAD FROM TAPE
;
	.IFN SYSAGE <
LD100	CMP #2
	BNE LD102
;
	JMP RS232
;
LD102	JSR ZZZ         ;SET POINTERS AT TAPE1
	BCS LD104
	JSR CSTE1       ;TELL USER ABOUT BUTTONS
	BCC LD105
LD104	RTS             ;STOP KEY PRESSED
LD105	JSR LUKING      ;TELL USER SEARCHING
;
LD112	LDA FNLEN       ;IS THERE A NAME?
	BEQ LD150       ;NONE...LOAD ANYTHING
	JSR FAF         ;FIND A FILE ON TAPE
	BCC LD170       ;GOT IT!
	BEQ LD190       ;STOP KEY PRESSED
	BCS LD90        ;NOPE...END OF TAPE
;
LD150	JSR FAH         ;FIND ANY HEADER
	BCC LD170
	BEQ LD190       ;STOP KEY PRESSED
	BCS LD90        ;NO HEADER
;
LD170	CPX #BLF        ;IS IT A PROGRAM
	BNE LD112       ;NO...SOMETHING ELSE
;
	LDA STATUS
	AND #SPERR      ;MUST GOT HEADER RIGHT
;CARRY SET FROM LAST CPX
	BNE LD112       ;IS BAD...RETRY
;
	LDY #1
	JSR TAPERY
	STA STAL
	JSR TAPIRY
	STA STAH
	JSR TAPIRY
	STA EAL
	JSR TAPIRY
	STA EAH
;
;DETERMINE FIXED OR MOVEABLE LOAD
;
	LDA RELSAS      ;SET UP INDIRECT
	STA EAS
	STA STAS
	LDA RELSAL
	AND RELSAH
	CMP #$FF
	BEQ LD175       ;FIXED LOAD
;
	SEC
	LDA EAL         ;COMPUTE LENGTH
	SBC STAL
	STA EAL
	LDA EAH
	SBC STAH
	STA EAH
	CLC
	LDA RELSAL      ;COMPUTE NEW END
	STA STAL
	ADC EAL
	STA EAL
	LDA RELSAH
	STA STAH
	ADC EAH
	STA EAH
;
LD175	JSR LODING      ;TELL USER LOADING
	JSR TRD         ;DO TAPE BLOCK LOAD
	.BYT $24        ;CARRY FROM TRD
>
	.IFE SYSAGE <
LD100	JSR XTAPE       ;GOTO TAPE INDIRECT
>
;
LD180	CLC             ;GOOD EXIT
;
;SET UP END LOAD ADDRESS
;
	LDA EAS
	LDX EAL
	LDY EAH
;
LD190	RTS
.SKI 5
;SUBROUTINE TO PRINT TO CONSOLE:
;
;SEARCHING [FOR NAME]
;
LUKING	BIT MSGFLG      ;SUPPOSED TO PRINT?
	BPL LD115
	LDY #MS5-MS1    ;"SEARCHING"
	JSR SPMSG
	LDA FNLEN
	BEQ LD115
	LDY #MS6-MS1    ;"FOR"
	JSR SPMSG
.SKI 3
;SUBROUTINE TO OUTPUT FILE NAME
;
OUTFN	LDY FNLEN       ;IS THERE A NAME?
	BEQ LD115       ;NO...DONE
	LDY #0
LD110	JSR FNADRY
	JSR BSOUT
	INY
	CPY FNLEN
	BNE LD110
;
LD115	RTS
.SKI 3
;SUBROUTINE TO PRINT:
;
;LOADING/VERIFING
;
LODING	LDY #MS10-MS1   ;ASSUME 'LOADING'
	LDA VERCK       ;CHECK FLAG
	BPL LD410       ;ARE DOING LOAD
	LDY #MS21-MS1   ;ARE 'VERIFYING'
LD410	JMP SPMSG
.END
; RSR  FIX SEGMENTATION 10/15/81
; RSR  6509 CHANGES  10/15/81
; -------------------------------------------------------------
; ##### SAVE #####
.PAG 'SAVE FUNCTION'
;***************************************
;* NSAVE              10/30/81         *
;*                                     *
;* SAVES TO CASSETTE 1 OR 2, OR        *
;* IEEE DEVICES 4>=N>=31 AS SELECTED   *
;* BY VARIABLE FA.                     *
;*                                     *
;* .X => ZPAGE ADDRESS OF START VECTOR *
;* .Y => ZPAGE ADDRESS OF END VECTOR   *
;***************************************
.SKI 3
NSAVE	LDA 0,X         ;GET START VECTOR
	STA STAL
	LDA 1,X
	STA STAH
	LDA 2,X
	STA STAS
	TYA
	TAX
	LDA 0,X         ;GET END VECTOR
	STA EAL
	LDA 1,X
	STA EAH
	LDA 2,X
	STA EAS
;
	LDA FA
	BNE SV20
;
SV10	JMP ERROR9      ;BAD DEVICE #
;
SV20	CMP #3
	BEQ SV10
	BCC SV100
	LDA #$61
	STA SA
	LDY FNLEN
	BNE SV25
;
	JMP ERROR8      ;MISSING FILE NAME
;
SV25	JSR OPENI
	JSR SAVING
	LDA FA
	JSR LISTN
	LDA SA
	JSR SECND
	LDX I6509       ;INDIRECTS SWITCHED BY RD300
	JSR RD300
	LDA SAL
	JSR CIOUT
	LDA SAH
	JSR CIOUT
;
	LDY #0
SV30	JSR CMPSTE      ;COMPARE START TO END
	BCS SV50        ;HAVE REACHED END
	LDA (SAL)Y
	JSR CIOUT
	JSR INCSAL
	JSR STOP
	BNE SV30
;
	STX I6509       ;RESTORE INDIRECTS
BREAK	JSR CLSEI
	LDA #0
	SEC
	RTS
;
SV50	STX I6509       ;RESTORE INDIRECTS
	JSR UNLSN
.SKI 3
CLSEI	BIT SA
	BMI CLSEI2
	LDA FA
	JSR LISTN
	LDA SA
	AND #$EF
	ORA #$E0
	JSR SECND
	JSR UNLSN
;
CLSEI2
SV110	CLC
SV115	RTS
.SKI 3
	.IFN SYSAGE <
SV100	CMP #2
	BNE SV102
;
	JMP RS232
;
SV102	JSR ZZZ         ;GET ADDR OF TAPE
	BCS SV115       ;BUFFER IS DEALLOCATED...EXIT
	JSR CSTE2
	BCS SV115       ;STOP KEY PRESSED
	JSR SAVING      ;TELL USER 'SAVING'
SV105	LDA #BLF
	JSR TAPEH
	BCS SV115       ;STOP KEY PRESSED
	JSR TWRT
	BCS SV115       ;STOP KEY PRESSED
	LDA SA
	AND #2          ;WRITE END OF TAPE?
	BEQ SV110       ;NO...
;
	LDA #EOT
	JMP TAPEH
>
	.IFE SYSAGE <
SV100	JSR XTAPE       ;GOTO TAPE DEVICE
>
.SKI 3
;SUBROUTINE TO OUTPUT:
;'SAVING <FILE NAME>'
;
SAVING	LDA MSGFLG
	BPL SV115       ;NO PRINT
;
	LDY #MS11-MS1   ;'SAVING'
	JSR SPMSG
	JMP OUTFN       ;<FILE NAME>
.END
; -------------------------------------------------------------
; ##### TIME #####
.PAG 'TIME 11/12/81'
;----------------------------------------
;
; TIME AND ALARM ROUTINES FOR 6526
;      RSR 11/12/81
;
;----------------------------------------
;----------------------------------------
; RDTIM - READ THE TIME
;  .Y = (BIT7=PM,BIT6/5=T8/T4,BITS4-0 HRS)
;  .X = (BIT7=T2,BITS6-0 MINUTES)
;  .A = (BIT7=T1,BITS6-0 SECONDS)
;----------------------------------------
RDTIM	LDA CIA+TOD10
	PHA             ;SAVE FOR LATER
	PHA
	ASL A           ;SHIFT TO ADD TO TODHRS
	ASL A
	ASL A
	AND #$60        ;BIT POSISTIONS 5,6
	ORA CIA+TODHR
	TAY             ;RETURN IN .Y
	PLA
	ROR A           ;SHIFT TO ADD TO TODSEC
	ROR A
	AND #$80
	ORA CIA+TODSEC
	STA SAL         ;SAVE FOR LATER
	ROR A           ;SHIT TO ADD TO TODMIN
	AND #$80
	ORA CIA+TODMIN
	TAX             ;RETURN IN .X
	PLA
	CMP CIA+TOD10   ;WATCH OUT FOR ROLLOVER
	BNE RDTIM       ;...IT CHANGED DO AGAIN...
	LDA SAL
	RTS
.PAG
;----------------------------------------
; SETTIM - SET TOD AND ALARM
;  C-SET => SET ALARM
;  C-CLR => SET TOD
;  REGISTERS SAME AS RDTIM
;
;----------------------------------------
SETTIM	PHA             ;SAVE FOR LATER
	PHA
	ROR A           ;SET BIT 8
	AND #$80
	ORA CIA+CRB
	STA CIA+CRB
	TYA             ;GET BITS FROM TODHRS
	ROL A
	ROL A
	ROL SAL         ;BIT T8 (DON'T NEED TO CLEAR SAL)
	ROL A
	ROL SAL         ;BIT T4
	TXA             ;GET BIT FROM TODMIN
	ROL A
	ROL SAL         ;BIT T2
	PLA             ;GET BIT FROM TODSEC
	ROL A
	ROL SAL         ;BIT T1
	STY CIA+TODHR
	STX CIA+TODMIN
	PLA
	STA CIA+TODSEC
	LDA SAL
	STA CIA+TOD10
	RTS
.END
; -------------------------------------------------------------
; ##### ERRORHANDLER #####
.PAG 'ERROR HANDLER'
;************************************
;*                                  *
;* ERROR HANDLER                    *
;*  RESTORES I/O CHANNELS TO DEFAULT*
;*  PRINTS KERNAL ERROR MESSAGE IF  *
;*  BIT 6 OF MSGFLG SET.  RETURNS   *
;*  WITH ERROR # IN .A AND CARRY.   *
;*                                  *
;************************************
;
ERROR1	LDA #1          ;TOO MANY FILES
	.BYT $2C
ERROR2	LDA #2          ;FILE OPEN
	.BYT $2C
ERROR3	LDA #3          ;FILE NOT OPEN
	.BYT $2C
ERROR4	LDA #4          ;FILE NOT FOUND
	.BYT $2C
ERROR5	LDA #5          ;DEVICE NOT PRESENT
	.BYT $2C
ERROR6	LDA #6          ;NOT INPUT FILE
	.BYT $2C
ERROR7	LDA #7          ;NOT OUTPUT FILE
	.BYT $2C
ERROR8	LDA #8          ;MISSING FILE NAME
	.BYT $2C
ERROR9	LDA #9          ;BAD DEVICE #
;
ERRORX	PHA             ;ERROR NUMBER ON STACK
	JSR CLRCH       ;RESTORE I/O CHANNELS
;
	LDY #MS1-MS1
	BIT MSGFLG      ;ARE WE PRINTING ERROR?
	BVC EREXIT      ;NO...
;
	JSR MSG         ;PRINT "CBM I/O ERROR #"
	PLA
	PHA
	ORA #$30        ;MAKE ERROR # ASCII
	JSR BSOUT       ;PRINT IT
;
EREXIT	PLA
	SEC
	RTS
.PAG 'ERROR HANDLER'
;***************************************
;* STOP -- CHECK STOP KEY FLAG AND     *
;* RETURN Z FLAG SET IF FLAG TRUE.     *
;* ALSO CLOSES ACTIVE CHANNELS AND     *
;* FLUSHES KEYBOARD QUEUE.             *
;* ALSO RETURNS KEY DOWNS FROM LAST    *
;* KEYBOARD ROW IN .A.                 *
;***************************************
NSTOP	LDA STKEY       ;VALUE OF LAST ROW
	AND #$01        ;CHECK STOP KEY POSITION
	BNE STOP2       ;NOT DOWN
	PHP
	JSR CLRCH       ;CLEAR CHANNELS
	STA NDX         ;FLUSH QUEUE
	PLP
STOP2	RTS
.SKI 3
;---------------------------------------
; UDTIM - UPDATE THE STOP KEY LOCATION
;   EXPECTS KEYBOARD OUTPUTS SET TO
;   DEFAULT VALUE. BIT 0 OF STKEY =0
;   FOR STOP KEY DOWN.
;---------------------------------------
UDTIM	LDA TPI2+PC     ;CHECK KEYBOARD
	LSR A
	BCS UDEXIT      ;NO  STOP KEY
	LDA #$FE        ;CHECK FOR SHIFT
	STA TPI2+PB
	LDA #$10
	AND TPI2+PC
	BNE UDTTT       ;NO SHIFT KEY
	SEC             ;SHIFT KEY MARK
UDTTT	LDA #$FF        ;CLEAR
	STA TPI2+PB
UDEXIT	ROL A           ;MOVE BIT 0 BACK
	STA STKEY
	RTS
.END
; -------------------------------------------------------------
;.LIB TAPEFILE
;.LIB TAPECONTROL
;.LIB READ
;.LIB WRITE
; -------------------------------------------------------------
; ##### INIT #####
.PAG 'INIT 05/02/83'
;------------------------------------------------
; START - SYSTEM RESET ROUTINE
;  KERNAL CHECKS ON 4K BOUNDRIES FROM $1000-$8000
;    FIRST OCCURANCE HAS PRIORITY.
;    IF NO OCCURANCE THEN $E000 IS USED FOR VECTOR
;    $E000 => MONITOR START
;  KERNAL EXPECTS:
;    $X000 - JMP INIT  (COLD START)
;    $X003 - JMP WINIT (WARM START)
;    $X006 - 'C'(+$80)=> KERNAL COLD START FIRST
;    $X007 - 'B'+$80
;    $X008 - 'M'+$80
;    $X009 - 'X'  X=4K BANK (1-8)
;
;------------------------------------------------
.SKI 1
PATALL	.BYT  $C2,$CD   ;$X004 ROM PATTERN
.SKI 1
START	LDX #$FE        ;DO ALL NORMAL JUNK...
	SEI
	TXS
	CLD
;
; CHECK FOR WARM START
;
	LDA #WARM       ;LOAD UP BITS THAT SHOW WARM
	CMP EVECT+2     ;CHECK WARM FLAG
	BNE SCOLD
	LDA EVECT+3     ;CHECK COMPLETE FLAG
	CMP #WINIT
	BEQ SWARM       ;GOOD...DO WARM START
;
; CHECK FOR ROMS
;
SCOLD	LDA #6          ;SET UP INDIRECT
	STA EAL
	LDA #0          ;CLEAR UPPER
	STA EAH
	STA EVECT+0     ;SET LOW BYTE OF VECTOR
	LDX #$30        ;EXISTANCE FLAG
SLOOP0	LDY #3          ;GO AROUND TEST LOOP
	LDA EAH
	BMI SLOOP2      ;NO ROMS BUT THIS ONE...
	CLC             ;CALC NEW TEST POINT
	ADC #$10        ;4K STEPS
	STA EAH
	INX
	TXA
	CMP (EAL)Y
	BNE SLOOP0      ;DIDN'T MATCH 'X'...
	DEY
SLOOP1	LDA (EAL)Y
	DEY
	BMI SLOOP3      ;ALL DONE...CORRECTLY
	CMP PATALL,Y
	BEQ SLOOP1
	BNE SLOOP0      ;NO GOOD...
;
; MONITOR (COULD BE TEST FOR KEYDOWN ***)
;
SLOOP2	LDY #$E0        ;MONITOR VECTOR
	.BYTE $2C       ;SKIP TWO BYTES
SLOOP3	LDY EAH
STARHI	STY EVECT+1     ;SET HIGH BYTE OF VECTOR
;
	TAX             ;SET FLAGS
	BPL SWARM       ;DON'T USE KERNAL INITILIZATION
;
; KERNAL COLD START
;
SKERNL	JSR IOINIT      ;INITILIZE I/O
	LDA #$F0        ;PREVENT DAMAGE TO NON-TESTED BUFFERS
	STA PKYBUF+1
	JSR CINT        ; CINIT CALL FOR NON-CLEARED SYSTEM
	JSR RAMTAS      ;RAM TEST AND SET
	JSR RESTOR      ;OPERATIONG SYSTEM VECTORS
	JSR CINT        ;SCREEN EDITOR INITILIZATION
	LDA #WARM       ;KERNAL INITILIZE DONE FLAG
	STA EVECT+2
SWARM	JMP (EVECT)     ;START EXIT
.PAGE 'INIT - I/O'
;-----------------------------------------
; IOINIT - INITILIZE I/O SYSTEM
;   6509/6525/6525/6526
;   MUST BE ENTERED WITH IRQ'S DISABLED
;------------------------------------------
IOINIT
;
; 6509 INITILIZATION CODE
;   SEE PAGE 2 FOR ASSIGNMENTS
;   DONE BY RESET
;
;
; 6525 TPI1 INITILIZATION CODE
;   SEE PAGE 12 FOR ASSIGNMENTS
;
	LDA #%11110011  ;CB,CA=HI IE3,4=NEG IP=1 MC=1
	STA TPI1+CREG
	LDY #$FF        ;MASK ON ALL IRQ'S
	STY TPI1+DDPC
;     PB4=OUTPUT 1, TO CLAIM DBUS
	LDA #%01011100  ;WRT=LO UNUSED NETR=OFF
	STA TPI1+PB     ;NETW=OFF IFC=LO (MUST TURN OFF !!!)
	LDA #%01111101  ;SET DIRECTIONS
	STA TPI1+DDPB
;
	LDA #%00111101  ;IEEE CONTROLS OFF
	STA TPI1+PA
	LDA #%00111111  ;IEEE CONTROL TO TRANSMITT
	STA TPI1+DDPA   ;DATA TO RECEIVE
;
; 6525 TPI2 INITILIZATION CODE
;   SEE PAGE 13 FOR ASSIGNMENTS
;
; .Y = $FF FROM ABOVE
	STY TPI2+PA     ;SET UP KEYBOARD OUTPUTS
	STY TPI1+PB
	STY TPI2+DDPA
	STY TPI2+DDPB
	LSR TPI2+PA     ;TURN STOP KEY LINE ON ***
	.IFN SYSTEM <
	LDA #$C0        ;SET UP VIC SELECTS=OUT FOR P-SERIES
>
	.IFE SYSTEM <
	INY             ;.Y=0 SET UP VIC SELECTS=IN FOR SYSTEM JUMPERS
>
	STY TPI2+PC
	STY TPI2+DDPC   ; KEYBOARD=IN (0-5)
;
; 6526 CIA INITILIZATION CODE
;   SEE PAGE 10 FOR ASSIGNMENTS
;
	LDA #$7F        ;TURN OFF ALL IRQ SOURCES FROM 6526...
	STA CIA+ICR
; .Y =$00 FROM ABOVE
	STY CIA+DDRA    ;ALL IEEE IN / TRIGGERS 14,24 ALSO
	STY CIA+DDRB    ;SAME FOR GAME INPUTS 10-13,20-23
	STY CIA+CRB     ;WRITE TOD   TIMER B=OFF
; ACTIVATE TOD
;
	STA CIA+TOD10
;
; 60/50 HZ TEST CODE FOR TOD
;
	STY TPI1+PC
IO100	LDA TPI1+PC     ;WAIT UNTILL IT HAPPENS AGAIN
	ROR A
	BCC IO100       ;PC0 = 1 -> 50/60HZ IRQ
	STY TPI1+PC     ;CLEAR IT AGAIN
;
; START A TIMMER
;
	LDX #0          ;.Y=$00 FROM ABOVE
IO110	INX
	BNE IO110
	INY
	LDA TPI1+PC
	ROR A
	BCC IO110       ;PC0 = 1 -> 50/60HZ IRQ
;
	CPY #ID55HZ
	BCC IO120       ;IT WAS 60 HZ
	LDA #%10001000  ;SET FOR 50HZ
	.BYT $2C        ;SKIP TWO BYTES
IO120	LDA #%00001000
	STA CIA+CRA
;
; 6526  INTER-PROCESS COMMUNICATION INITIALIZATION
;       PRA = DATA PORT
;       PRB = IPC LINES
;       IRQ'S FROM 2ND PROCESSOR VIA FLAG INPUT
;
	LDA IPCIA+ICR   ;CLEAR ICR
	LDA #$90
	STA IPCIA+ICR   ;FLAG IRQS ON
	LDA #$40
	STA IPCIA+PRB   ;NO NMI TO Z80, SEM6509 LOW
;.X =$00 FROM ABOVE
	STX IPCIA+DDRA  ;PORT A=INPUT
	STX IPCIA+CRB   ;TIMER B OFF
	STX IPCIA+CRA   ;TIMER A OFF
	LDA #%01001000  ;PORT B LINES SEM65,ENNMI ARE OUTS
	STA IPCIA+DDRB
;
;
; 6551 INITILIZATION CODE
;   SEE PAGE 11 FOR ASSIGNMENTS
;   HANDLED BY RESET  10/19/81 RSR
;
; TURN OFF IFC
;
	LDA #IFC
	ORA TPI1+PB
	STA TPI1+PB
	RTS
.PAGE 'INIT - RAMTAS'
;-----------------------------------------
; RAMTAS - INITILIZE LOWER RAM WITH $00
;  AND TEST ALL SYSTEM DYNAMIC RAM
;  SET RAM LIMITS (64K BANK MIN SIZE)
;  ALLOCATE INITIAL BUFFER SPACE
;  TURN OFF RS232 AND CASSETTE BUFFERS
;  RESET XTAPE VECTORS TO NON-CASSETTE
;
;-----------------------------------------
RAMTAS
; CLEAR $0002-$0101 AND $0200-$03F7
;
	LDA #0
	TAX
PX1	.BYT $9D        ;STA $0002,X
	.WOR $0002
	STA $200,X
	STA $300-8,X
	INX
	BNE PX1
.SKIP 3
;
;MEMORY SIZE CHECK
;
	.IFE SYSTEM <
	LDA #1          ;BOTTOM OF MEMORY ALWAYS SEGMENT 1
>
	.IFN SYSTEM <
	LDA #0          ;BOTTOM OF MEMORY ALWAYS SEGMENT 0
>
	STA I6509
	STA MEMSTR+2    ;SET BOTTOM OF MEMORY
	STA LOWADR+2
	LDA #2
	STA MEMSTR
	STA LOWADR
	DEC I6509       ;PLACE BACK ONE SEGMENT FOR TEST
;
; MEMSIZ,SAL,LOWADR ARE ZEROED ABOVE
;
SIZLOP	INC I6509       ;CLACULATE NEXT IND SEG
	LDA I6509
	CMP #15         ;ALL SLOTS FULL...EXIT
	BEQ SIZE
	LDY #2          ;ALWAYS START AT $0002
SIZ100
	LDA (SAL)Y
	TAX
	LDA #$55
	STA (SAL)Y
	LDA (SAL)Y
	CMP #$55
	BNE SIZE
	ASL A
	STA (SAL)Y
	LDA (SAL)Y
	CMP #$AA
	BNE SIZE
	TXA
	STA (SAL)Y
	INY
	BNE SIZ100
	INC SAL+1
	BNE SIZ100
	BEQ SIZLOP
;
; SET TOP OF MEMORY
;
SIZE	LDX I6509       ;SEG NUMBER OF FAILURE
	DEX             ;BACK UP ONE SEGMENT
	TXA             ;.A= SEG#
	LDX #$FF
	LDY #$FD        ;RESERVE TOP PAGE FOR SWAPPING SYSTEM
	STA HIADR+2     ;SET SYSTEM TOP OF MEMORY
	STY HIADR+1
	STX HIADR
;
; ALLOCATE 3 PAGES (512FUNCS,256RS232)
;
	LDY #$FD-3
	CLC
	JSR MEMTOP      ;SET USER TOP OF MEMORY
;
; FLAG BUFFERS AS NOT ASSIGNED =>$FF
;
	DEC RIBUF+2
	DEC TAPE1+2
	.IFE SYSAGE <
	LDA #<NOCASS    ;SET UP CASSETTE INDIRECTS
	STA ITAPE
	LDA #>NOCASS
	STA ITAPE+1
>
	RTS
.PAGE 'INIT - KERNAL'
.SKI 5
JMPTAB	.WOR YIRQ       ;CINV
	.WOR TIMB       ;CBINV....BRK GOES TO MONITOR
	.WOR PANIC      ;NO.....NMINV !!!!!
	.WOR NOPEN      ;OPEN FILE
	.WOR NCLOSE     ;CLOSE FILE
	.WOR NCHKIN     ;OPEN CHANNEL IN
	.WOR NCKOUT     ;OPEN CHANNEL OUT
	.WOR NCLRCH     ;CLOSE CHANNEL
	.WOR NBASIN     ;INPUT FROM CHANNEL
	.WOR NBSOUT     ;OUTPUT TO CHANNEL
	.WOR NSTOP      ;SCAN STOP KEY
	.WOR NGETIN     ;SCAN KEYBOARD
	.WOR NCLALL     ;CLOSE ALL FILES
	.WOR NLOAD      ;LOAD FROM FILE
	.WOR NSAVE      ;SAVE TO FILE
	.WOR S0         ;MONITOR COMMAND PARSER
	.WOR ESCRTS     ;ESC KEY VECTOR
	.WOR ESCRTS     ;USER CTRL KEY VECTOR
	.WOR NSECND     ;IEEE LISTEN SECONDARY ADDRESS
	.WOR NTKSA      ;IEEE TALK SECONDARY ADDRESS
	.WOR NACPTR     ;IEEE CHARACTER IN
	.WOR NCIOUT     ;IEEE CHARACTER OUT
	.WOR NUNTLK     ;IEEE UNTALK BUS
	.WOR NUNLSN     ;IEEE UNLISTEN BUS
	.WOR NLISTN     ;IEEE LISTEN A DEVICE
	.WOR NTALK      ;IEEE TALK TO A DEVICE
TABEND
NMI	JMP (NMINV)
.SKI 5
; .A = FILENAME LENGTH
; .X = ZERO PAGE LOCATION OF 3 BYTE ADDRESS
;
SETNAM	STA FNLEN
	LDA $00,X
	STA FNADR
	LDA $01,X
	STA FNADR+1
	LDA $02,X
	STA FNADR+2
	RTS
.SKI 5
SETLFS	STA LA
	STX FA
	STY SA
	RTS
.SKI 5
;READ/WRITE STATUS
;
;CARRY SET -- READ DEVICE STATUS INTO .A
;
READST	BCC STORST
	LDA FA          ;SEE WHICH DEVICES' TO READ
	CMP #2
	BNE READSS      ;NOT RS-232
	LDA RSSTAT      ;YES GET IT
	PHA
	LDA #00         ;CLEAR STATUS WHEN READ
	BEQ STATXT      ;JUMP
;
SETMSG	STA MSGFLG
READSS	LDA STATUS
UDST	ORA STATUS
	STA STATUS
	RTS
;
;CARRY CLEAR -- SET DEVICE STATUS WITH .A
;
STORST	PHA
	LDA FA
	CMP #2
	BNE STORSS      ;NOT RS-232
STATXT	PLA
	STA RSSTAT
	RTS
;
STORSS	PLA
	STA STATUS
	RTS
.SKI 5
SETTMO	STA TIMOUT
	RTS
.SKI 5
MEMTOP	BCC SETTOP
;
;CARRY SET--READ TOP OF MEMORY
;
	LDA MEMSIZ+2
	LDX MEMSIZ
	LDY MEMSIZ+1
;
;CARRY CLEAR--SET TOP OF MEMORY
;
SETTOP	STX MEMSIZ
	STY MEMSIZ+1
	STA MEMSIZ+2
	RTS
.SKI 5
;MANAGE BOTTOM OF MEMORY
;
MEMBOT	BCC SETBOT
;
;CARRY SET--READ BOTTOM OF MEMORY
;
	LDA MEMSTR+2
	LDX MEMSTR
	LDY MEMSTR+1
;
;CARRY CLEAR--SET BOTTOM OF MEMORY
;
SETBOT	STX MEMSTR
	STY MEMSTR+1
	STA MEMSTR+2
	RTS
.SKI 5
;RESTORE RAM I/O VECTORS
;
RESTOR	LDX #<JMPTAB
	LDY #>JMPTAB
	LDA #IROM
	CLC
;
;MANAGE RAM I/O VECTORS
;
VECTOR	STX SAL
	STY SAH
	LDX I6509       ;SAVE INDIRECT
	STA I6509
;
	BCC VECT50
;
;CARRY SET--READ VECTORS
;
	LDY #TABEND-JMPTAB-1
VECT20	LDA CINV,Y      ;FROM RAM TABLE
	STA (SAL)Y      ;INTO USER AREA
	DEY
	BPL VECT20
;
;CARRY CLEAR--SET VECTORS
;
VECT50	LDY #TABEND-JMPTAB-1
VECT60	LDA (SAL)Y      ;FROM USER AREA
	STA CINV,Y      ;INTO RAM TABLE
	DEY
	BPL VECT60
;
	STX I6509       ;RESTORE INDIRECT
	RTS
;
; VRESET - RESET VECTOR FLAGS AND CONTROL
;   .X - LOW VECTOR ADDRESS  .Y - HIGH VECTOR ADDRESS
;
VRESET	STX EVECT
	STY EVECT+1
	LDA #WINIT
	STA EVECT+3
	RTS
.END
; -------------------------------------------------------------
; ##### IRQ #####
.PAG 'INTERRUPT HANDLER'
;**********************************************
;* NIRQ - HANDLER FOR:       10/30/81 RSR     *
;* 6525 IRQ'S:::::::::::::::::::::::::::::::::*
;* 6551 IRQ'S                                 *
;*   (RECEIVER,TRANSMITTER,DCD & DSR CHANGES) *
;* 6526 IRQ'S                                 *
;*   (ALARM, TIMERA, TIMERB)                  *
;* 6526 IRQ'S                                 *
;*   (2ND PROCESSOR)                          *
;* IEEE SRQ                                   *
;* KEYBOARD SCAN (50/60HZ IRQ)                *
;*                                            *
;* ALSO AT PRESENT DOES NOT HANDLE ANY OF THE *
;* 6566 (VIC) INTERRUPTS.                     *
;*                                            *
;**********************************************
NIRQ	PHA             ;SAVE REGISTERS
	TXA
	PHA
	TYA
	PHA
	TSX             ;CHECK FOR BRK...
	LDA $104,X
	AND #$10
	BNE BRKIRQ      ;YES...
PULS	JMP (CINV)
BRKIRQ	JMP (CBINV)     ;YES...
;
YIRQ	LDA I6509       ;SAVE INDIRECT SEGMENT #
	PHA
; LDA PASS ;EXTERNAL BREAK HANDLER
; PHA
; LDA #0 ;CLEAR FOR NORMAL RETURN
; STA PASS
.SKI 2
	CLD             ;CLEAR DEC TO PREVENT FUTURE PROBLEMS
	LDA TPI1+AIR
	BNE IRQ000      ;HANDLE PRIORITY IRQ'S
;
; EXTERNAL IRQ (VIC AND OTHERS)
;  (NO CODE!!!!!!!!!!)
;
	JMP PRENDN
.SKI4
IRQ000	CMP #$10        ;FIND IRQ SOURCE
	BEQ IRQ002      ;NOT 6551...
	JMP IRQ100
;
; 6551 INTERRUPT HANDLER
;
IRQ002	LDA ACIA+SRSN   ;FIND IRQ SOURCE
	TAX
	AND #$60        ;DCD/DSR CHANGES ??
	TAY
	EOR DCDSR
	BEQ IRQ004      ;NO CHANGE...
	TYA
	STA DCDSR       ;UPDATE OLD DSR/DCD STATUS
	ORA RSSTAT      ;UPDATE RS232 STATUS
	STA RSSTAT
	JMP IRQ900      ;DONE!
;
IRQ004	TXA
	AND #$08        ;RECEIVER ??
	BEQ IRQ010      ;NO...
;
; RECEIVER SERVICE
;
	LDY RIDBE       ;CHECK BUFFERS
	INY
	CPY RIDBS       ;HAVE WE PASSED START?
	BNE IRQ005      ;NO...
;
	LDA #DOVERR     ;INPUT BUFFER FULL ERROR
	BNE IRQ007      ;BRA...SET STATUS
;
IRQ005	STY RIDBE       ;MOVE END FOWARD
	DEY
	LDX RIBUF+2
	STX I6509
	LDX ACIA+SRSN   ;GET STATUS REGISTER
	LDA ACIA+DRSN
	STA (RIBUF)Y    ;DATA TO BUFFER
	TXA             ;SET STATUS
	AND #$07
IRQ007	ORA RSSTAT      ;SET STATUS
	STA RSSTAT
.SKI 2
IRQ010	LDA ACIA+SRSN   ;FIND IRQ SOURCE
	AND #$10        ;TRANSMITTER ?
	BEQ IRQ090      ;NO...
	LDA ACIA+CDR    ;CHECK FOR TRANSMITTER ON
	AND #$0C
	CMP #$04        ;BITS(32)=01 => XMITTER INT ENABLED
	BNE IRQ090      ;OFF...
;
; TRANSMITTER SERVICE (NO INTERRRUPT DRIVEN TRANSMISSIONS)
;
	LDA #%11110011  ;TURN OF TRANSMITTER
	AND ACIA+CDR
	STA ACIA+CDR
IRQ090	JMP IRQ900      ;EXIT..POP PRIORITY...
.SKI 3
IRQ100
	CMP #$08        ;CHECK IF INTER-PROCESS IRQ
	BNE IRQ110      ;NO...
	LDA IPCIA+ICR   ;CLEAR IRQ CONDITION
	CLI             ;THIS IRQ CAN BE INTERRUPTED
	JSR IPSERV      ;DO THE REQUEST
	JMP IRQ900      ;DONE!
.SKI
IRQ110	CLI             ;ALL OTHER IRQ'S MAY BE INTERRUPTED, TOO
	CMP #$04        ;CHECK IF 6526
	BNE IRQ200      ;NO...
;
; 6526 INTERRUPT RECONIZED
;
	LDA CIA+ICR     ;GET ACTIVE INTERRUPTS
	ORA ALARM       ;IN CASE WE LOSE SOMETHING
	STA ALARM
;
; NOTHING TO DO AT PRESENT....NEED CODE ********
;
	JMP IRQ900      ;...DUMP INTERRUPT
.SKI 3
IRQ200	CMP #$02        ;CHECK FOR IEEE SRQ
	BNE IRQ300
;
; NEED CODE ************
;
	JMP IRQ900      ;...DUMP INTERRUPT
.SKI 3
IRQ300	JSR KEY         ;SCAN THE KEYBOARD
	JSR UDTIM       ;SET STOPKEY FLAG
;
; TEST FOR CASSETTE SWITCH
;
	LDA TPI1+PB     ;GET CASS SWITCH
	BPL IRQ310      ;SWITCH IS DOWN...
	LDY #0          ;FLAG MOTOR OFF...
	STY CAS1
	ORA #$40        ;TURN MOTOR OFF...
	BNE IRQ320      ;JUMP
IRQ310	LDY CAS1        ;TEST FOR FLAG ON...
	BNE IRQ900      ;YES COMPUTER CONTROL..LEAVE ALONE
	AND #$FF-$40    ;TURN MOTOR ON...
IRQ320	STA TPI1+PB     ;STORE MODS INTO PORT
.SKI 3
IRQ900	STA TPI1+AIR    ;POP THE INTERRUPT...
PRENDN	;LDA PASS ;CHECK FOR FORIEGN CALL
; BNE SEGRTI ;YES...RETURN
; PLA
; STA PASS ;RESTORE INTERRUPTED INTERRUPT
	PLA             ;RESTORE REGISTERS
	STA I6509
PREND	PLA             ;ENTRY POINT FOR REGISTER ONLY
	TAY
	PLA
	TAX
	PLA
PANIC	RTI             ;COME HERE IF NO NEW NMI VECTOR.
;
.END
; -------------------------------------------------------------
; ##### IPCOM #####
.PAGE 'INTERPROCESS COMMUNICATION'
;--------------------------------------------------------------
;
; SEND A REQUEST
;   ENTER:   IPB BUFFER IS INITIALIZED TO HOLD THE
;            COMMAND
;            INPUT PARAMETER BYTES
;
;   EXIT:    IPB BUFFER HOLDS
;            OUTPUT PARAMETER BYTES
;            ALL OTHER BYTES IN IPB UNCHANGED
;
;---------------------------------------------------------------
IPRQST
	LDA IPB+IPCCMD
	AND #$7F
	TAY
	JSR GETPAR      ;GET #INS,OUTS
	LDA #SEM88      ;CHECK 8088 SEMAPHORE
	AND IPCIA+PRB
	BNE IPRQST      ;LOCKED OUT BY OTHER PROCESSOR
	LDA #SEM65
	ORA IPCIA+PRB   ;LOCK 6509 SEMAPHORE
	STA IPCIA+PRB
	NOP             ;A PAUSE
;
	LDA IPCIA+PRB   ;COLLISIONS WITH 8088?
	TAX
	AND #SEM88
	BEQ IPR100      ;OK...
	TXA
	EOR #SEM65
	STA IPCIA+PRB   ;NOPE, CLEAR 6509 SEMAPHORE
	TXA             ;KILL SOME TIME
	NOP
	NOP
	NOP
	BNE IPRQST      ;TRY AGAIN (BR ALWAYS)
;
;     SEND CMD BYTE AND CAUSE IRQ
;
IPR100
	LDA #$FF
	STA IPCIA+DDRA  ;PORT DIRECTION = OUT
	LDA IPB+IPCCMD
	STA IPCIA+PRA   ;WRITE CMD BYTE TO PORT
;; CAUSE IRQ
	JSR FREBUS      ;GIVE UP BUS
	LDA IPCIA+PRB   ;PB6 := 0
	AND #$BF
	STA IPCIA+PRB
	ORA #$40        ;KEEP LOW FOR 4US (8 CYCLES)
	CLI
	NOP
	NOP
	NOP
	STA IPCIA+PRB   ;PB6 := HIGH
;
	JSR WAITHI      ;SEM8088 -> HI (CMD BYTE RECVD)
	LDA #$00
	STA IPCIA+DDRA  ;PORT DIRECTION = IN
	JSR ACKLO       ;SEM6509 -> LO (ACK)
	JSR WAITLO      ;SEM8088 -> LO (ACK ACK)
;
;    SEND DATA BYTES, IF ANY
;
	LDY #0
	BEQ IPR250      ;ALWAYS
IPR200
	LDA #$FF
	STA IPCIA+DDRA  ;PORT DIRECTION = OUT
	LDA IPB+IPCDAT,Y ;GET NEXT DATA BYTE
	STA IPCIA+PRA   ;WRITE CMD OUT
	JSR ACKHI       ;SEM6509 -> HI (DATA READY)
	JSR WAITHI      ;SEM8088 -> HI (DATA RECVD)
	LDA #$00
	STA IPCIA+DDRA  ;PORT DIRECTION = IN
	JSR ACKLO       ;SEM6509 -> LO (ACK)
	JSR WAITLO      ;SEM8088 -> LO (ACK ACK)
	INY             ;BUMP INDEX TO NEXT DATA BYTE
IPR250	CPY IPB+IPCIN   ;ANY MORE ??
	BNE IPR200      ;YES...
;
;    RECEIVE DATA BYTES, IF ANY
;
	LDY #0
	BEQ IPR350      ;ALWAYS
IPR300
	JSR ACKHI       ;SEM6509 -> HI (RDY TO RECEIVE)
	JSR WAITHI      ;SEM8088 -> HI (DATA AVAILABLE)
	LDA IPCIA+PRA   ;GET DATA FROM PORT
	STA IPB+IPCDAT,Y ;STUFF IT AWAY
	JSR ACKLO       ;SEM6509 -> LO (DATA RECVD)
	JSR WAITLO      ;SEM8088 -> LO (ACK)
	INY
IPR350
	CPY IPB+IPCOUT  ;MORE?
	BNE IPR300      ;YES...
	RTS             ;DONE!!
.PAGE
;-------------------------------------------------------------------
;
; SERVICE AN 8088 REQUEST
;
;-------------------------------------------------------------------
IPSERV
;; LDY #IPBSIZ-1 ;COPY IP BUFFER TO STACK
;;IPS050 LDA IPB,Y
;; PHA
;; DEY
;; BPL IPS050
;
	LDA #0
	STA IPCIA+DDRA  ;PORT DIR=IN, JUST IN CASE...
	LDA IPCIA+PRA   ;READ CMD FROM PORT
	STA IPB+IPCCMD  ;STORE CMD AND DECODE IT
	AND #$7F        ;MASK OFF BUS BIT
	TAY
	JSR GETPAR      ;GET PARAM COUNTS
	TYA             ;ADJUST OFFSET FOR JUMP TABLE
	ASL A
	TAY
	LDA IPJTAB,Y    ;JUMP ADDRESS(LO)
	STA IPB+IPCJMP
	INY
	LDA IPJTAB,Y    ;JUMP ADDRESS (HI)
	STA IPB+IPCJMP+1
	JSR ACKHI       ;SEM6509 -> HI (CMD RECVD)
	JSR WAITLO      ;SEM8088 -> LO (ACK)
;
;    RECEIVE INPUT BYTES, IF ANY
;
	LDY #0
IPS100
	CPY IPB+IPCIN   ;ANY MORE?
	BEQ IPS200      ;NO...
	JSR ACKLO       ;SEM6509 ->LO (ACK ACK)
	JSR WAITHI      ;SEM8088 -> HI (DATA AVAILABLE)
	LDA IPCIA+PRA   ;READ DATA BYTE
	STA IPB+IPCDAT,Y ;STORE IT
	JSR ACKHI       ;SEM6509 -> HI (DATA RECVD)
	JSR WAITLO      ;SEM8088 -> LO (ACK)
	INY
	BNE IPS100      ;ALWAYS...
;
;    PROCESS CMD
;
IPS200
	BIT IPB+IPCCMD  ;CMD REQUIRES BUS?
	BMI IPS500      ;YES...
	LDA #>IPSRET    ;PUSH RETURN
	PHA
	LDA #<IPSRET
	PHA
	JMP (IPB+IPCJMP) ;GONE!!!
;
;    SEND RETURN BYTES, IF ANY
;
IPS300
IPSRET=IPS300-1
	JSR ACKLO       ;SEM6509 -> LO
	LDY #0
	BEQ IPS350      ;ALWAYS
IPS310
	JSR WAITHI      ;SEM8088 -> HI (8088 RDY TO RECV)
	LDA #$FF
	STA IPCIA+DDRA  ;PORT DIRECTION = OUT
	LDA IPB+IPCDAT,Y
	STA IPCIA+PRA   ;WRITE DATA TO PORT
	JSR ACKHI       ;SEM6509 -> HI (DATA AVAILABLE)
	JSR WAITLO      ;SEM8088 -> LO (DATA RECVD)
	LDA #0
	STA IPCIA+DDRA  ;PORT DIRECTION = IN
	JSR ACKLO       ;SEM6509 -> LO (ACK)
	INY
IPS350	CPY IPB+IPCOUT  ;ANY MORE?
	BNE IPS310      ;YES, REPEAT...
;
IPS400
;; LDY #0
;;IPS450 PLA ;RESTORE IP BUFFER
;; STA IPB,Y
;; INY
;; CPY #IPBSIZ
;; BNE IPS450
	RTS             ;DONE!
.SKI 3
;      SPECIAL,   FOR COMMANDS REQUIRING THE BUS
IPS500	LDA #>BURET
	PHA
	LDA #<BURET
	PHA             ;PUSH RETURN
	JSR GETBUS      ;GRAB BUS
	JMP (IPB+IPCJMP) ;GONE!
;
IPS600
BURET=IPS600-1
	JSR FREBUS      ;GIVE UP BUS
	LDA IPB+IPCOUT  ;#BYTES TO RETURN
	STA IPB+IPCIN
	STA IPB+IPCCMD  ;RETURN OP=#BYTES TO RETURN
	LDA #0
	STA IPB+IPCOUT  ;JUST SEND TO 8088
	JSR IPRQST
	JMP IPS400      ;DONE!
.PAGE
;
; WAITLO - WAIT UNTIL SEM88 GOES LOW
;
WAITLO
	LDA IPCIA+PRB
	AND #SEM88
	BNE WAITLO
	RTS
.SKI 3
;
; WAITHI - WAIT UNTIL SEM88 GOES HIGH
;
WAITHI
	LDA IPCIA+PRB
	AND #SEM88
	BEQ WAITHI
	RTS
.SKI 3
;
; ACKLO - ACKNOWLEGDE SEM65 LOW
;
ACKLO
	LDA IPCIA+PRB
	AND #$FF-SEM65
	STA IPCIA+PRB
	RTS
.SKI 3
;
; ACKHI - ACKNOWLEDGE SEM6509 HI
;
ACKHI
	LDA #SEM65
	ORA IPCIA+PRB
	STA IPCIA+PRB
	RTS
.SKI 3
;
; FREBUS - GIVE UP BUS
; GETBUS - GRAB BUS
;
FREBUS
	LDA TPI1+PB     ;PB4 := 0
	AND #$EF
	STA TPI1+PB
	RTS
;
GETBUS
	LDA IPCIA+PRB   ;CHECK NBUSY2
	AND #$02
	BEQ GETBUS      ;2ND PROC NOT OFF
;
	LDA TPI1+PB     ;PB4 := 1
	ORA #$10
	STA TPI1+PB
	RTS
;
; GETPAR
;  ENTER - .Y = TABLE OFFSET
;  EXIT:   .Y = TABLE OFFSET
;          #INS,#OUTS PUT INTO IPB BUFFER
GETPAR
	LDA IPPTAB,Y    ;BREAK APART NIBBLES
	PHA
	AND #$0F
	STA IPB+IPCIN   ;#INPUT BYTES
	PLA
	LSR A
	LSR A
	LSR A
	LSR A
	STA IPB+IPCOUT  ;#OUTPUT BYTES
	RTS
;
; IPCGO - FREE BUS, INTERRUPT 2ND PROCESSOR
;         GO INTO A LOOP, WAITING FOR REQUESTS.
;  * RETURNS IF BUS ERROR OCCURS
;
IPCGO	LDX #$FF
	STX I6509       ;INDIRECTS TO BANK F ONLY
	LDA TPI1+PB     ;TPI1 PB4:=0 FREES DBUS
	AND #$EF
	STA TPI1+PB
	NOP             ;A PAUSE
	LDA IPCIA+PRB   ;CHECK NBUSY1
	ROR A
	BCS IPCGX
	RTS             ;BUS NOT FREE!, ERROR...
;
IPCGX	LDA #0          ;PB6 LO->HI IN 4US...
	SEI
	STA IPCIA+PRB   ;INTERRUPT 2ND PROCESSEOR
	LDA #$40        ;2 CYCLES (4US=8CYCLES)
	NOP
	NOP
	NOP
	NOP             ;8 CYCLES OF GARB. 5US SAFER THAN 4!
	STA IPCIA+PRB   ;TURN PB6 BACK ON
	CLI
IPLOOP	JMP IPLOOP      ;SIT DOWN
.END
; -------------------------------------------------------------
; ##### KTEMP #####
.PAG 'TEMPORARIES'
;EQUATE SCREEN EDITOR TEMPORARILY
;
CINT	=$E000+4
LP2	=$E003+4
LOOP5	=$E006+4
PRT	=$E009+4
SCNKEY	=$E00F+4
KEY	=$E00F+4
;
; NO ROUTINES IN 8032 SCREEN EDITOR
;
SCRORG	=$E00C+4
PLOT	=$E015+4
IOBASE	=$E018+4
ESCRTS	=$E01B+4
FUNKEY	=$E022
;
; NO CASSETTE ROUTINES AVALIABLE
;
XTAPE	JMP (ITAPE)     ;GOTO TAPE DEVICE INDIRECT
NOCASS	PLA             ;REMOVE JSR XTAPE AND RETURN
	PLA
	JMP ERROR5      ;SEND BACK ?DEVICE NOT PRESENT
;
; SOME NEEDED ROUTINES
;
RD300	LDA STAH
	STA SAH
	LDA STAL
	STA SAL
	LDA STAS
	STA SAS
	STA I6509
	RTS
;
CMPSTE	SEC
	LDA SAL
	SBC EAL
	LDA SAH
	SBC EAH
	LDA SAS
	SBC EAS
	RTS
;
INCSAL	INC SAL
	BNE INCR20
	INC SAH
INCR10	BNE INCR20
	INC SAS
	LDA SAS
	STA I6509
	LDA #$02        ;SKIP $0000 AND $0001
	STA SAL
INCR20	RTS
.SKI 5
;-------------------------------------
; TAPERY - GET FROM THE TAPE BUFFER
;   LDA (TAPE1)Y ;REPLACEMENT
;-------------------------------------
;TAPIRY INY
;TAPERY LDX I6509
; LDA TAPE1+2
; STA I6509
; LDA (TAPE1)Y
; STX I6509
; RTS
;-------------------------------------
; TAPEWY - PUT CHAR IN THE TAPE BUFFER
;   STA (TAPE1)Y ;REPLACEMENT
;-------------------------------------
;TAPZWY LDY #$FF ;FIRST BYTE IN BUFFER
;TAPIWY INY ;AUTO INC INTO BUFFER
;TAPEWY LDX I6509
; PHA
; LDA TAPE1+2
; STA I6509
; PLA
; STA (TAPE1)Y
; STX I6509
; RTS
;-------------------------------------
; FNADRY - GET FROM FILE NAME BUFFER
;   LDA (FNADR)Y ;REPLACEMENT
;-------------------------------------
FNADRY	LDX I6509
	LDA FNADR+2
	STA I6509
	LDA (FNADR)Y
	STX I6509
	RTS
.END
; -------------------------------------------------------------
; ##### TRANSX #####
.PAG 'TRANSX 5/02/83'
; TXJMP - TRANSFER-OF-EXECUTION JUMPER
;   ENTRY - .A=SEG # .X=LOW .Y=HIGH
;   CALLER MUST BE A JSR TXJMP
;   ALL REGISTERS AND I6509 DESTROYED
;   RETURNS DIRECTLY TO CALLER...
;
TXJMP	;BP ROUTINE
 STA I6509
 TXA
 CLC
 ADC #2
 BCC TXJMP1
 INY
TXJMP1	TAX
 TYA
 PHA
 TXA
 PHA
 JSR IPINIT ;GO INITILIZE IPOINT
 LDA #$FE
 STA (IPOINT)Y
;
; 04/14/83 BP
; TRANSFER EXEC ROUTINES FOR CBM2
;
EXSUB	PHP             ;SAVE STATUS
	SEI
	PHA             ;.A
	TXA
	PHA             ;.X
	TYA
	PHA             ;.Y
	JSR IPINIT      ;INIT IPOINT AND LOAD STACK FROM XFER SEG
	TAY             ;.Y IS XFER SEG STACK POINTER
	LDA E6509       ;PUSH RETURN SEGMENT TO USER STACK
	JSR PUTAS       ;PUSH .A TO OTHER STACK
	LDA #<EXCRT2    ;XFER SEG RTS ROUTN
	LDX #>EXCRT2    ;XFER SEG RTS ROUTN
	JSR PUTAXS      ;PUT .A.X TO XFER SEG STACK
	TSX
	LDA $0105,X     ;.SP +5 IS ACTUAL ROUTN ADDR LO
	SEC
	SBC #03         ;-3 FOR JSR TO THIS ROUTN
	PHA             ;SAVE .A
	LDA $0106,X     ;HI ADDR
	SBC #00
	TAX             ;.X HI
	PLA             ;RESTORE .A LO
	JSR PUTAXS      ;SAVE .A.X ONTO XFER SEG STACK
	TYA             ;XFER SEG STACK POINTER
EXCOMM	SEC
	SBC #04         ;4 BYTES .Y.X.A.P
	STA STACKP      ;XFER SEG NEW STACK POINTER TEMP STORAGE
	TAY             ;USE THIS AS NEW POINTER ALSO
	LDX #04         ;4 BYTES .Y.X.A.P
EXSU10	PLA
	INY
	STA (IPOINT),Y  ;PUSH REGS FROM THIS STACK TO XFER SEG STACK
	DEX
	BNE EXSU10
	LDY STACKP      ;RESTORE .Y AS STACK POINTER FOR XFER SEG
	LDA #<EXPUL2    ;PULL REGS AND RTS ROUTN
	LDX #>EXPUL2    ;.HI PRENDN ROUTN IN XFER SEG
	JSR PUTAXS      ;PUT .A.X ON XFER SEG STACK
	PLA             ;FIX STACK
	PLA             ;FIX STACK
EXGBYE	TSX
	STX STACKP      ;SAVE CURRENT STACK POINTER THIS SEG
	TYA             ;.Y IS STACK POINTER FOR XFER SEG
	TAX
	TXS             ;NEW STACK FOR XFER SEG
	LDA I6509       ;XFER SEG #
	JMP GBYE        ;GOOD BYE
;
	NOP             ;RETURNS HERE IF RTI
EXCRTS	PHP             ;.P
	PHP             ;.P
      SEI             ;DIS INTS
	PHA             ;.A
	TXA
	PHA             ;.X
	TYA
	PHA             ;.Y
	TSX
	LDA $0106,X     ;.SP +7 IS RETURN SEG
	STA I6509       ;RESTORE I6509 TO RETURN SEG
	JSR IPINIT      ;INIT IPOINT AND LOAD STACK FROM XFER SEG
	JMP EXCOMM
;
IPINIT	LDY #01
	STY IPOINT+1
	DEY
	STY IPOINT      ;IPOINT=$0100
	DEY             ;.Y =$FF
	LDA (IPOINT),Y  ;LOAD STACK POINTER FROM $001FF
	RTS
PUTAXS	PHA             ;SAVE .A
	TXA
	STA (IPOINT),Y  ;.X HI
	DEY
	PLA
PUTAS	STA (IPOINT),Y  ;.A LO
	DEY
	RTS
;
EXPULL	PLA
	TAY             ;.Y
	PLA
	TAX             ;.X
	PLA             ;.A
	PLP             ;.P
	RTS             ;.P
EXNMI	PHP             ;.P
	JMP ($FFFA)     ;DO NMI PROC
EXBRK	BRK
	NOP
	RTS
EXIRQ	CLI
	RTS
EXEND
;
EXCRT2=EXCRTS-1
EXPUL2=EXPULL-1
.END
; -------------------------------------------------------------
; ##### VECTORS #####
.PAG 'JUMP TABLE/VECTORS'
	* =$FF6C
	JMP TXJMP       ;TRANSFER-OF-EXECUTION JUMPER
	JMP VRESET      ;POWER-ON/OFF VECTOR RESET
IPCGOV	JMP IPCGO       ;LOOP FOR IPC SYSTEM
	JMP FUNKEY      ;FUNCTION KEY VECTOR
	JMP IPRQST      ;SEND IPC REQUEST
	JMP IOINIT      ;I/O INITIALIZATION
	JMP CINT        ;SCREEN INITIALIZATION
	JMP ALOCAT      ;ALLOCATION ROUTINE
	JMP VECTOR      ;READ/SET I/O VECTORS
	JMP RESTOR      ;RESTORE I/O VECTORS
	JMP LKUPSA      ;MATCH SA--RETURN SA,FA
	JMP LKUPLA      ;MATCH LA--RETURN SA,FA
	JMP SETMSG      ;CONTROL O.S. MESSAGES
SECND	JMP (ISECND)    ;SEND SA AFTER LISTEN
TKSA	JMP (ITKSA)     ;SEND SA AFTER TALK
	JMP MEMTOP      ;SET/READ TOP OF MEMORY
	JMP MEMBOT      ;SET/READ BOTTOM OF MEMORY
	JMP SCNKEY      ;SCAN KEYBOARD
	JMP SETTMO      ;SET TIMEOUT IN IEEE
ACPTR	JMP (IACPTR)    ;HANDSHAKE IEEE BYTE IN
CIOUT	JMP (ICIOUT)    ;HANDSHAKE IEEE BYTE OUT
UNTLK	JMP (IUNTLK)    ;SEND UNTALK OUT IEEE
UNLSN	JMP (IUNLSN)    ;SEND UNLISTEN OUT IEEE
LISTN	JMP (ILISTN)    ;SEND LISTEN OUT IEEE
TALK	JMP (ITALK)     ;SEND TALK OUT IEEE
	JMP READST      ;READ/WRITE I/O STATUS BYTE
	JMP SETLFS      ;SET LA, FA, SA
	JMP SETNAM      ;SET LENGTH AND FN ADR
OPEN	JMP (IOPEN)     ;OPEN LOGICAL FILE/TRANSMIT COMMAND
CLOSE	JMP (ICLOSE)    ;CLOSE LOGICAL FILE
CHKIN	JMP (ICHKIN)    ;OPEN CHANNEL IN
CKOUT	JMP (ICKOUT)    ;OPEN CHANNEL OUT
CLRCH	JMP (ICLRCH)    ;CLOSE I/O CHANNEL
BASIN	JMP (IBASIN)    ;INPUT FROM CHANNEL
BSOUT	JMP (IBSOUT)    ;OUTPUT TO CHANNEL
LOAD	JMP (ILOAD)     ;LOAD FROM FILE
SAVE	JMP (ISAVE)     ;SAVE TO FILE
	JMP SETTIM      ;SET INTERNAL CLOCK
	JMP RDTIM       ;READ INTERNAL CLOCK
STOP	JMP (ISTOP)     ;SCAN STOP KEY
GETIN	JMP (IGETIN)    ;GET CHAR FROM Q
CLALL	JMP (ICLALL)    ;CLOSE ALL FILES
	JMP UDTIM       ;INCREMENT CLOCK
	JMP SCRORG      ;SCREEN ORG
	JMP PLOT        ;READ/SET X,Y COORD
	JMP IOBASE      ;RETURN I/O BASE
.SKI 5
GBYE	STA E6509       ;GOODBYE...
	RTS
.PAG 'JUMP TABLE/VECTORS'
	*=$FFFA
	.WOR NMI        ;PROGRAM DEFINEABLE
	.WOR START      ;INITIALIZATION CODE
	.WOR NIRQ       ;INTERRUPT HANDLER
.END
