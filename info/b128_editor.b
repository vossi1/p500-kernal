.OPT NOSYM
; -------------------------------------------------------------
; ##### DISCLAIMER #####
;***************************************
;*                                     *
;* EEEEE DDD   IIIII TTTTT  OOO  RRRR  *
;* E     D  D    I     T   O   O R   R *
;* E     D   D   I     T   O   O R   R *
;* EEE   D   D   I     T   O   O RRRR  *
;* E     D   D   I     T   O   O R R   *
;* E     D  D    I     T   O   O R  R  *
;* EEEE  DDD   IIIII   T    OOO  R   R *
;*                                     *
;***************************************
;
;***************************************
;* CBM EDITOR FOR B/BX-SERIES SYSTEMS  *
;*   KEYBOARD AND SCREEN EDIT ROUTINES *
;* DRIVING THE HARDWARE OF THE         *
;* FOLLOWING CBM MODELS:               *
;*   B/BX-SERIES OR B128/256           *
;* COPYRIGHT (C) 1983 BY               *
;* COMMODORE BUSINESS MACHINES (CBM)   *
;***************************************
.SKI 3
;*****LISTING DATE --15:00 31 MAY 1983
.SKI 3
;***************************************
;* THIS SOFTWARE IS FURNISHED FOR USE  *
;* USE IN THE CBM B/BX COMPUTERS.      *
;*                                     *
;* COPIES THEREOF MAY NOT BE PROVIDED  *
;* OR MADE AVAILABLE FOR USE ON ANY    *
;* OTHER SYSTEM.                       *
;*                                     *
;* THE INFORMATION IN THIS DOCUMENT IS *
;* SUBJECT TO CHANGE WITHOUT NOTICE.   *
;*                                     *
;* NO RESPONSIBILITY IS ASSUMED FOR    *
;* RELIABILITY OF THIS SOFTWARE.       *
;*                                RSR  *
;***************************************
.END
; -------------------------------------------------------------
; ##### DECLARE #####
.PAG 'DECLARE 05/01/83'
	* =$0
;------------------------------------------------------
; 6509  USED TO EXTEND MEMORY ON BC2 & P2 SYSTEMS
;   BITS 0-5 USED TO DIRECT:
;     EXECUTION REGISTER (4 BITS)
;     INDIRECT  REGISTER (4 BITS)
;
;   THESE BITS CAN BE EXPANDED TO SIXTEEN (16) SEGMENT
;   CONTROL LINES.  ON 6509 RESET ALL LINES ARE HIGH.
;
; CURRENT MEMORY MAP:
;   SEGMENT 15- $FFFF-$E000  ROM (KERNAL)
;               $DFFF-$DF00  I/O  6525 TPI2
;               $DEFF-$DE00  I/O  6525 TPI1
;               $DDFF-$DD00  I/O  6551 ACIA
;               $DCFF-$DC00  I/O  6526 CIA
;               $DBFF-$DB00  I/O  UNUSED (Z80,8088,6809)
;               $DAFF-$DA00  I/O  6581 SID
;               $D9FF-$D900  I/O  UNUSED (DISKS)
;               $D8FF-$D800  I/O  6566 VIC/ 6845 80-COL
;               $D7FF-$D400  COLOR NYBLES/80-COL SCREEN
;               $D3FF-$D000  VIDEO MATRIX/80-COL SCREEN
;               $CFFF-$C000  CHARACTER DOT ROM (P2 ONLY)
;               $BFFF-$8000  ROMS EXTERNAL (LANGUAGE)
;               $7FFF-$4000  ROMS EXTERNAL (EXTENSIONS)
;               $3FFF-$2000  ROM  EXTERNAL
;               $1FFF-$1000  ROM  INTERNAL
;               $0FFF-$0400  UNUSED
;               $03FF-$0002  RAM (KERNAL/BASIC SYSTEM)
;   SEGMENT 14- SEGMENT 8 OPEN (FUTURE EXPANSION)
;   SEGMENT 7 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 6 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 5 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 4 - $FFFF-$0002  RAM EXPANSION (EXTERNAL)
;   SEGMENT 3 - $FFFF-$0002  RAM EXPANSION
;   SEGMENT 2 - $FFFF-$0002  RAM EXPANSION
;   SEGMENT 1 - $FFFF-$0002  RAM EXPANSION
;   SEGMENT 0 - $FFFF-$0002  RAM USER/BASIC SYSTEM
;
; THE 6509 REGISTERS APPEAR IN LOCATIONS $0000 AND
; $0001 IN ALL SEGMENTS OF MEMORY.
;
;------------------------------------------------------
E6509	*=*+1           ;6509 EXECUTION   REGISTER
I6509	*=*+1           ;6509 INDIRECTION REGISTER
.SKI 2
IROM	=$F             ;INDIRECT=ROM OR EXECUTION=ROM
.PAG 'DECLARE - KERNAL'
	* =$90
;KERNAL PAGE ZERO VARIABLES
;
;KERNAL INDIRECT ADDRESS VARIABLES
;
FNADR	*=*+3           ;ADDRESS OF FILE NAME STRING
SAL	*=*+1           ;CURRENT LOAD/STORE ADDRESS
SAH	*=*+1
SAS	*=*+1
EAL	*=*+1           ;END OF LOAD/SAVE
EAH	*=*+1
EAS	*=*+1
STAL	*=*+1           ;START OF LOAD/SAVE
STAH	*=*+1
STAS	*=*+1
;
;FREQUENTLY USED KERNAL VARIABLES
;
STATUS	*=*+1           ;I/O OPERATION STATUS
FNLEN	*=*+1           ;FILE NAME LENGTH
LA	*=*+1           ;CURRENT LOGICAL INDEX
FA	*=*+1           ;CURRENT FIRST ADDRESS
SA	*=*+1           ;CURRENT SECOND ADDRESS
DFLTN	*=*+1           ;DEFAULT INPUT DEVICE
DFLTO	*=*+1           ;DEFAULT OUTPUT DEVICE
;
;TAPE BUFFER POINTER
;
TAPE1	*=*+3           ;ADDRESS OF TAPE BUFFER
;
; SEE KERNAL LISTING FOR ALLOCATION INFORMATION
;
.PAG 'DECLARE-EDITOR'
;SCREEN EDITOR PAGE ZERO VARIABLES
;
;EDITOR INDIRECT ADDRESS VARIABLES
;
	*=$C0           ;LEAVE SOME SPACE
PKYBUF	*=*+2           ;START ADR OF PGM KEY
KEYPNT	*=*+2           ;CURRENT PGM KEY BUF
SEDSAL	*=*+2           ;SCROLL PTR
SEDEAL	*=*+2           ;SCROLL PTR
PNT	*=*+2           ;CURRENT CHARACTER POINTER
;
;EDITOR VARIABLES FOR SPEED & SIZE
;
TBLX	*=*+1           ;CURSOR LINE
PNTR	*=*+1           ;CURSOR COLUMN
GRMODE	*=*+1           ;GRAPHIC/TEXT MODE FLAG
LSTX	*=*+1           ;LAST CHARACTER INDEX
LSTP	*=*+1           ;SCREEN EDIT START POSITION
LSXP	*=*+1
CRSW	*=*+1           ;
NDX	*=*+1           ;INDEX TO KEYD QUEUE
QTSW	*=*+1           ;QUOTE MODE FLAG
INSRT	*=*+1           ;BORDER COLOR
CONFIG	*=*+1           ;CURSOR TYPE
INDX	*=*+1           ;LAST BYTE POSISTION OF LINE
KYNDX	*=*+1           ;COUNT OF PROGRAM KEY STRING
RPTCNT	*=*+1           ;DELAY TWEEN CHARS
DELAY	*=*+1           ;DELAY TO NEXT REPEAT
;
SEDT1	*=*+1           ;FREQUENTLY USED TEMP VARIABLES
SEDT2	*=*+1
;
;FREQUENTLY USED EDITOR VARIABLES
;
DATA	*=*+1           ;CURRENT PRINT DATA
SCTOP	*=*+1           ;TOP SCREEN 0-25
SCBOT	*=*+1           ;BOTTOM 0-25
SCLF	*=*+1           ;LEFT MARGIN
SCRT	*=*+1           ;RIGHT MARGIN
MODKEY	*=*+1           ;KEYSCANNER MODE   BYTE ($FF - NO KEY DOWN LAST SCAN)
NORKEY	*=*+1           ;KEYSCANNER NORMAL BYTE ($FF - NO KEY DOWN LAST SCAN)
BITABL	*=*+4           ;WRAP BITMAP
ZPEND
.PAG 'DECLARE ABSOLUTE'
;
	* =$100
; STACK SPACE
	* =$200
BUF	*=*+256         ;BASIC'S LINE INPUT
;
; THIS AREA RESERVED FOR KERNAL ABSOLUTES
;  SEE KERNAL LISTING FOR OTHER LOCATIONS
;
CTLVEC	=$0322
ESCVEC	=$0320
HIADR	=$0355
BSOUT	=$FFD2          ;KERNAL VECTOR
.PAG 'DECLARE ABSOLUTE'
;
;SCREEN EDITOR ABSOLUTE
;
	*=$380          ;BLOCK SOME AREA FOR EDITOR
PKYEND	*=*+2           ;PROGRAM KEY BUFFER END ADDRESS
KEYSEG	*=*+1           ;SEGMENT NUMBER FOR FUNCTION KEY RAM PAGE
KEYSIZ	*=*+20          ;FUNCTION KEY SIZES ...DON'T CLEAR...
RVS	*=*+1           ;REVERSE FIELD FLAG
LINTMP	*=*+1           ;LINE # TWEEN IN AND OUT
LSTCHR	*=*+1           ;LAST CHAR PRINTED
INSFLG	*=*+1           ;AUTO INSERT FLAG
SCRDIS	*=*+1           ;SCROLL DISABLE FLAG
FKTMP	;ALSO USED FOR FUNCTION KEY TEMPORARY
BITMSK	*=*+1           ;TEMPORARY BITMASK
KEYIDX	*=*+1           ;INDEX TO PROGRAMMABLES
LOGSCR	*=*+1           ;LOGICAL/PHYSICAL SCROLL FLAG
BELLMD	*=*+1           ;FLAG TO TURN ON END OF LINE BELL
PAGSAV	*=*+1           ;TEMP RAM PAGE
;
TAB	*=*+10          ;TABSTOP FLAGS (80 MAX)
;
KEYD	*=*+10          ;KEY CHARACTER QUEUE
FUNVEC	*=*+2           ;INDIRECT JUMP VECTOR FOR FUNCTION KEYS
SEDT3	*=*+1           ;ANOTHER TEMP USED DURING FUNCTION KEY LISTING
ABSEND
;
; SYSTEM WARM START VARIABLES AND VECTORS
;
	* =$3F8
EVECT	*=*+5
WARM	=$A5            ;WARM START FLAG
WINIT	=$5A            ;INITILIZATION COMPLETE FLAG
	* =$400
RAMLOC
.END
; -------------------------------------------------------------
; ##### EQUATE #####
.PAG 'EQUATE 11/12/82'
;TAPE BLOCK TYPES
;
EOT	= 5             ;END OF TAPE
BLF	= 1             ;BASIC LOAD FILE
BDF	= 2             ;BASIC DATA FILE
BDFH	= 4             ;BASIC DATA FILE HEADER
BUFSZ	= 192           ;BUFFER SIZE
CR	= $D            ;CARRIAGE RETURN
BASIC	= $8000         ;START OF ROM (LANGUAGE)
KERNAL	= $E000         ;START OF ROM (KERNAL)
.SKI 5
; 6845 VIDEO DISPLAY CONTROLLER FOR BC2
;
VDC	= $D800
ADREG	= $0            ;ADDRESS REGISTER
DAREG	= $1            ;DATA REGISTER
.SKI 3
; 6581 SID SOUND INTERFACE DEVICE
;   REGISTER LIST
SID	= $DA00
;
; BASE ADDRESSES OSC1, OSC2, OSC3
OSC1	= $00
OSC2	= $07
OSC3	= $0E
;
; OSC REGISTERS
FREQLO	= $00
FREQHI	= $01
PULSEF	= $02
PULSEC	= $03
OSCCTL	= $04
ATKDCY	= $05
SUSREL	= $06
;
; FILTER CONTROL
FCLOW	= $15
FCHI	= $16
RESNCE	= $17
VOLUME	= $18
;
; POTS, RANDOM NUMBER, AND ENV3 OUT
POTX	= $19
POTY	= $1A
RANDOM	= $1B
ENV3	= $1C
.PAG 'EQUATE 6526'
; 6526 CIA  COMPLEX INTERFACE ADAPTER
;  GAME / IEEE DATA / USER
;
;   TIMER A: IEEE LOCAL / CASS LOCAL / MUSIC / GAME
;   TIMER B: IEEE DEADM / CASS DEADM / MUSIC / GAME
;
;   PRA0 : IEEE DATA1 / USER
;   PRA1 : IEEE DATA2 / USER
;   PRA2 : IEEE DATA3 / USER
;   PRA3 : IEEE DATA4 / USER
;   PRA4 : IEEE DATA5 / USER
;   PRA5 : IEEE DATA6 / USER
;   PRA6 : IEEE DATA7 / USER / GAME TRIGGER 14
;   PRA7 : IEEE DATA8 / USER / GAME TRIGGER 24
;
;   PRB0 : USER / GAME 10
;   PRB1 : USER / GAME 11
;   PRB2 : USER / GAME 12
;   PRB3 : USER / GAME 13
;   PRB4 : USER / GAME 20
;   PRB5 : USER / GAME 21
;   PRB6 : USER / GAME 22
;   PRB7 : USER / GAME 23
;
;   FLAG : USER
;   PC   : USER
;   CT   : USER
;   SP   : USER
;
CIA	= $DC00
PRA	= $0            ;DATA REG A
PRB	= $1            ;DATA REG B
DDRA	= $2            ;DIRECTION REG A
DDRB	= $3            ;DIRECTION REG B
TALO	= $4            ;TIMER A LOW  BYTE
TAHI	= $5            ;TIMER A HIGH BYTE
TBLO	= $6            ;TIMER B LOW  BYTE
TBHI	= $7            ;TIMER B HIGH BYTE
TOD10	= $8            ;10THS OF SECONDS
TODSEC	= $9            ;SECONDS
TODMIN	= $A            ;MINUTES
TODHR	= $B            ;HOURS
SDR	= $C            ;SERIAL DATA REGISTER
ICR	= $D            ;INTERRUPT CONTROL REGISTER
CRA	= $E            ;CONTROL REGISTER A
CRB	= $F            ;CONTROL REGISTER B
.PAGE 'EQUATE 6551'
; 6551 ACIA  RS-232C AND NETWORK INTERFACE
;
ACIA	= $DD00
DRSN	= $00           ;TRANSMITT/RECEIVE DATA REGISTER
SRSN	= $01           ;STATUS REGISTER
CDR	= $02           ;COMMAND REGISTER
CTR	= $03           ;CONTROL REGISTER
.SKI 5
DSRERR	= $40           ;DATA SET READY ERROR
DCDERR	= $20           ;DATA CARRIER DETECT ERROR
DOVERR	= $08           ;RECEIVER OUTER BUFFER OVERRUN
.PAGE 'EQUATE 6525/D1'
; 6525 TPI1  TRIPORT INTERFACE DEVICE #1
;  IEEE CONTROL / CASSETTE / NETWORK / VIC / IRQ
;
;   PA0 : IEEE DC CONTROL (TI PARTS)
;   PA1 : IEEE TE CONTROL (TI PARTS) (T/R)
;   PA2 : IEEE REN
;   PA3 : IEEE ATN
;   PA4 : IEEE DAV
;   PA5 : IEEE EOI
;   PA6 : IEEE NDAC
;   PA7 : IEEE NRFD
;
;   PB0 : IEEE IFC
;   PB1 : IEEE SRQ
;   PB2 : NETWORK TRANSMITTER ENABLE
;   PB3 : NETWORK RECEIVER ENABLE
;   PB4 : ARBITRATION LOGIC SWITCH
;   PB5 : CASSETTE WRITE
;   PB6 : CASSETTE MOTOR
;   PB7 : CASSETTE SWITCH
;
;   IRQ0: 50/60 HZ IRQ
;   IRQ1: IEEE SRQ
;   IRQ2: 6526 IRQ
;   IRQ3: CASSETTE READ
;   IRQ4: 6551
;   *IRQ: 6566 (VIC) / USER DEVICES
;   CB  : VIC DOT SELECT
;   CA  : VIC MATRIX SELECT
;
TPI1	= $DE00
PA	= $0            ;PORT REGISTER A
PB	= $1            ;PORT REGISTER B
PC	= $2            ;PORT REGISTER C
LIR	= $2            ;INTERRUPT LATCH REGISTER MC= 1
DDPA	= $3            ;DATA DIRECTION REGISTER A
DDPB	= $4            ;DATA DIRECTION REGISTER B
DDPC	= $5            ;DATA DIRECTION REGISTER C
MIR	= $5            ;INTERRUPT MASK REGISTER MC= 1
CREG	= $6            ;CONTROL REGISTER
AIR	= $7            ;ACTIVE INTERRUPT REGISTER
;
FREQ	= $01           ;IRQ LINE 50/60 HZ FOUND ON...
ID55HZ	= 27            ;55 HZ VALUE REQUIRED BY IOINIT
.PAGE 'EQUATE 6525/D2'
; 6525 TPI2 TIRPORT INTERFACE DEVICE #2
;  KEYBOARD / VIC 16K CONTROL
;
;   PA0 : KYBD OUT 8
;   PA1 : KYBD OUT 9
;   PA2 : KYBD OUT 10
;   PA3 : KYBD OUT 11
;   PA4 : KYBD OUT 12
;   PA5 : KYBD OUT 13
;   PA6 : KYBD OUT 14
;   PA7 : KYBD OUT 15
;
;   PB0 : KYBD OUT 0
;   PB1 : KYBD OUT 1
;   PB2 : KYBD OUT 2
;   PB3 : KYBD OUT 3
;   PB4 : KYBD OUT 4
;   PB5 : KYBD OUT 5
;   PB6 : KYBD OUT 6
;   PB7 : KYBD OUT 7
;
;   PC0 : KYBD IN 0
;   PC1 : KYBD IN 1
;   PC2 : KYBD IN 2
;   PC3 : KYBD IN 3
;   PC4 : KYBD IN 4
;   PC5 : KYBD IN 5
;   PC6 : SELECT FOR MONITOR HIGH=NTSC  LOW=PAL
;   PC7 : SELECT FOR HEAD HIGH=BUILT-IN LOW=MONITOR
;
TPI2	= $DF00
.PAGE 'EQUATE IEEE LINES'
; IEEE LINE EQUATES
;
DC	= $01           ;75160/75161 CONTROL LINE
TE	= $02           ;75160/75161 CONTROL LINE
REN	= $04           ;REMOTE ENABLE
ATN	= $08           ;ATTENTION
DAV	= $10           ;DATA AVAILABLE
EOI	= $20           ;END OR IDENTIFY
NDAC	= $40           ;NOT DATA ACCEPTED
NRFD	= $80           ;NOT READY FOR DATA
IFC	= $01           ;INTERFACE CLEAR
SRQ	= $02           ;SERVICE REQUEST
;       
RDDB	= NRFD+NDAC+TE+DC ;DIRECTIONS FOR RECEIVER
TDDB	= EOI+DAV+ATN+TE+DC ;DIRECTIONS FOR TRANSMITT
;
EOIST	= $40           ;EOI STATUS TEST
TLKR	= $40           ;DEVICE IS TALKER
LSTNR	= $20           ;DEVICE IS LISTENER
UTLKR	= $5F           ;DEVICE UNTALK
ULSTN	= $3F           ;DEVICE UNLISTEN
;       
TOOUT	= $01           ;TIMEOUT STATUS ON OUTPUT
TOIN	= $02           ;TIMEOUT STATUS ON INPUT
EOIST	= $40           ;EOI ON INPUT
NODEV	= $80           ;NO DEVICE ON BUS.
SPERR	= $10           ;VERIFY ERROR
;       
;        EQUATES FOR C3P0 FLAG BITS 6 AND 7.
;       
SLOCK	= $40           ;SCREEN EDITOR LOCK-OUT
DIBF	= $80           ;DATA IN OUTPUT BUFFER
.END
; -------------------------------------------------------------
; ##### BWINIT #####
.PAG 'BWINIT 05/01/83'
;****************************************
;
;  80 COLUMN CBM II SCREEN EDITOR
;
;    WITH UNLIMITED SCREEN LINE WRAP
;
;****************************************
.SKIP 3
SCNRAM	= $D000         ;START OF SCREEN MEMORY
SIDREG	= $DA00         ;SID REGISTERS
LLEN	= 80            ;SCREEN LENGTH
NROWS	= 25            ;SCRREN LENGTH
SCXMAX	= LLEN-1        ;MAX COLUMN NUMBER
SCYMAX	= NROWS-1       ;MAX LINE NUMBER
KEYMAX	= 9             ;KEYBOARD BUFFER SIZE - 1
DBLZER	= 89            ;KEY CODE FOR DOUBLE ZERO
PGMKYS	= 20            ;NUMBER OF PROGAM KEYS
ALOCAT	= $FF81
IERROR	= $0280         ;BASIC ERROR INDIRECT
CURSOR	= $60           ;INIT TO FULL FLASHING CURSOR
ROMIMG	= $00           ;INIT TO NORMAL IMAGE & CHAR ROM
.SKI 3
	*=$E004
;************ JUMP TABLE ****************
;
JCINT	JMP CINT
JLP2	JMP LP2
JLOOP5	JMP LOOP5
JPRT	JMP PRT
JSCROR	JMP SCRORG
JKEY	JMP KEY
JMVCUR	JMP MOVCUR      ;JMP PREND CODE REMOVED...MOV CURSOR
JPLOT	JMP PLOT
JIOBAS	JMP IOBASE
JESCRT	JMP ESCAPE
PGMKEY	JMP KEYFUN
;
PLOT
	BCS RDPLT
	STX TBLX
	STX LSXP
	STY PNTR
	STY LSTP
; JSR SRESET ;ALWAYS RESET THE WINDOW
	JSR STUPT       ;CHANGE POINTER TO THIS NEW LINE
	JSR MOVCUR      ;MOVE THE CURSOR THERE
RDPLT
	LDX TBLX
	LDY PNTR
	RTS
;
IOBASE
	LDX #<CIA
	LDY #>CIA
	RTS
;
SCRORG
	LDX #LLEN
	LDY #NROWS
	RTS
;
.PAG
CINT
	LDA #0
	LDX #ZPEND-KEYPNT-1 ;ERASE ALL BUT FKEY ALLOCATION
CLOOP1	STA KEYPNT,X    ;CLEAR PAGE 0 VARIABLES
	DEX
	BPL CLOOP1
	LDX #ABSEND-RVS-1
CLOOP2	STA RVS,X       ;CLEAR ABSOLUTE VARIABLES BUT FKEY ALLOCATIONS
	DEX
	BPL CLOOP2
	LDA #$C
	STA DELAY       ;INIT REPEAT CTR
	LDA #CURSOR
	STA CONFIG      ;SET FULL FLASHING CURSOR
	LDA #<DOKEYF
	STA FUNVEC      ;SET UP INDIRECVCT FOR FUNCTION KEYS
	LDA #>DOKEYF
	STA FUNVEC+1
	LDA PKYBUF      ;CHECK IF BUFFERS ARE ALLOCATED
	ORA PKYBUF+1
	BNE NOROOM      ;YES...JUST RESET THE SCREEN
	LDA HIADR       ;GET END OF KEY AREA
	STA PKYEND
	LDA HIADR+1
	STA PKYEND+1
	LDA #$40
	LDX #0
	LDY #2
	JSR ALOCAT      ;GET 512 BYTES
	BCS NOROOM
	STA KEYSEG
	INX
	STX PKYBUF
	BNE ROOM10
	INY
ROOM10
	STY PKYBUF+1    ;SAVE START ADDRESS
KYSET
	LDY #KEYEND-KEYDEF
	JSR PAGST2
KYSET1
	LDA KEYDEF-1,Y
	DEY
	STA (PKYBUF),Y
	BNE KYSET1
	JSR PAGRES
	LDY #KEYDEF-KEYLEN
KYSET2
	LDA KEYLEN-1,Y
	STA KEYSIZ-1,Y
	DEY
	BNE KYSET2
NOROOM
	JSR SRESET      ;SET FULL SCREEN WINDOW
	JSR TXCRT       ;SET TEXT MODE/CHAR ROM
	JSR CRTINT      ;INITIALIZE CRT
;
CLSR
	JSR NXTD        ;START AT TOP OF WINDOW
CLS10
	JSR SCRSET
	JSR CLRLN       ;CLEAR THE LINE
	CPX SCBOT       ;DONE ?
	INX
	BCC CLS10       ;NO
;
NXTD
	LDX SCTOP       ;MOVE TO TOP
	STX TBLX
	STX LSXP        ;FOR INPUT AFTER HOME OR CLEAR
STU10	LDY SCLF        ;LEFT OF THE SCREEN WINDOW
	STY PNTR
	STY LSTP
STUPT
	LDX TBLX        ;RESET PTR TO LINE BEGIN
;
SCRSET
	LDA LDTB2,X
	STA PNT
	LDA LDTB1,X
	STA PNT+1
	RTS
;
; MOVCUR - MOVE THE CURSOR ROUTINE
;   WATCH OUT .Y IS NOW ZAPPED
;
MOVCUR
	LDY #15
	CLC
	LDA PNT
	ADC PNTR
	STY VDC+ADREG
	STA VDC+DAREG   ;SET LOW BYTE OF CURSOR ADDRESS
	DEY
	STY VDC+ADREG
	LDA VDC+DAREG   ;GET OLD HIGH BYTE OF CURSOR ADDRESS
	AND #$F8        ;MASK OUT 3 LOW ORDER BITS
	STA SEDT1       ;SAVE IT
	LDA PNT+1
	ADC #0
	AND #07         ;GET NEW LOW ORDER BITS
	ORA SEDT1       ;ADD IN MASKED BITS
	STA VDC+DAREG   ;SET HIGH BYTE OF CURSOR ADDRESS
	RTS
.SKI 2
; *** INPUT ROUTINES ***
;
LP2	LDX KYNDX       ;ARE THERE ANY PGM KEYS
	BEQ LP3         ;BRANCH IF NOT
	LDY KEYIDX      ;GET INDEX TO CURRENT CHAR
	JSR PAGST2      ;MAKE SURE RAM 0
	LDA (KEYPNT)Y   ;GET CURRENT BYT
	JSR PAGRES      ;RESTORE RAM PAGE
	DEC KYNDX       ;1 BYTE DOWN
	INC KEYIDX      ;BUMP INDEX TO NEXT CHAR
	CLI
	RTS
LP3	LDY KEYD        ;GET KEY FROM IRQ BUFFER
	LDX #0
LP1	LDA KEYD+1,X
	STA KEYD,X
	INX
	CPX NDX
	BNE LP1
	DEC NDX
	TYA
	CLI
	RTS
;
LOOP4	JSR PRT         ;PRINT THE CHARACTER
LOOP3
	LDY #10
	LDA CONFIG
	STY VDC+ADREG
	STA VDC+DAREG   ;SET CURSOR TYPE
LOOP3A
	LDA NDX
	ORA KYNDX
	BEQ LOOP3A      ;LOOP - WAIT FOR KEY INPUT
	SEI
; LDY #10  FROM LOOP3
	LDA #$20
	STY VDC+ADREG
	STA VDC+DAREG   ;TURN OFF CURSOR
LP21
	JSR LP2         ;GET KEY INPUT
	CMP #$D
	BNE LOOP4
	STA CRSW        ;FLAG - WE PASS CHARS NOW
	JSR FNDEND      ;CHECK NXT LINE FOR CONT
	STX LINTMP      ;SAVE LAST LINE NUMBER OF SENTENCE
	JSR FISTRT      ;FIND BEGINING OF LINE
	LDA #0
	STA QTSW        ;CLEAR QUOTE MODE
	LDY SCLF        ;RETRIEVE FROM LINE START IF LEFT IT
	LDA LSXP        ;INPUT STARTED ROW
	BMI LP80        ;FLAG WE LEFT START LINE
	CMP TBLX
	BCC LP80
	LDY LSTP        ;INPUT STARTED COLUMN
	CMP LINTMP      ;ON START LINE
	BNE LP70
	CPY INDX        ;PAST START COLUMN
	BEQ LP75        ;OK IF THE SAME
LP70	BCS CLP2        ;YES - NULL INPUT
LP75
	STA TBLX        ;START FROM HERE ON INPUT
LP80	STY PNTR
	JMP LOP5
;
LOOP5	TYA
	PHA
	TXA
	PHA
	LDA CRSW        ;PASSING CHARS TO INPUT
	BEQ LOOP3       ;NO - BUFFER ON SCREEN
	BPL LOP5        ;NOT DONE - GET NEXT CHAR
CLP2
	LDA #0          ;INPUT DONE CLEAR FLAG
	STA CRSW
	LDA #$D         ;PASS A RETURN
	BNE CLP7
LOP5
	JSR STUPT       ;SET PNT AND USER
	JSR GET1CH      ;GET A SCREEN CHAR
	STA DATA
	AND #$3F
	ASL DATA
	BIT DATA
	BPL LOP54
	ORA #$80
LOP54	BCC LOP52
	LDX QTSW
	BNE LOP53
LOP52	BVS LOP53
	ORA #$40
LOP53	JSR QTSWC
	LDY TBLX        ;ON INPUT END LINE ?
	CPY LINTMP
	BCC CLP00       ;NO
	LDY PNTR        ;ON INPUT END COLUMN ?
	CPY INDX
	BCC CLP00       ;NO
	ROR CRSW        ;C=1 MINUS FLAGS LAST CHAR SENT
	BMI CLP1        ;ALWAYS
;
CLP00
	JSR NXTCHR      ;AT NEXT CHAR
CLP1
	CMP #$DE        ;A PI ?
	BNE CLP7        ;NO
	LDA #$FF        ;TRANSLATE
CLP7
	STA DATA
	PLA
	TAX
	PLA
	TAY
	LDA DATA
	RTS
.SKIP 3
; *** TEST FOR QUOTE MODE ***
QTSWC	CMP #$22
	BNE QTSWL
	LDA INSRT       ;IF WE ARE IN INSERT MODE...
	BNE QTSWI       ;DON'T MESS WITH QUOTE MODE...
	LDA QTSW
	EOR #$1
	STA QTSW
QTSWI	LDA #$22
QTSWL	RTS
.SKIP 3
; *** OUTPUT CHARS ***
NXT3
	BIT RVS
	BPL NVS
NC3	ORA #$80
NVS	LDX INSRT
	BEQ NVSA
	DEC INSRT
NVSA	BIT INSFLG      ;ARE WE IN AUTO INSERT MODE?
	BPL NVS1        ;BRANCH IF NOT
	PHA             ;SAVE THE CHAR
	JSR INSERT      ;MAKE ROOM FOR THIS CHAR
	LDX #0
	STX INSRT       ;MAKE SURE WE TURN OFF INSERT MODE.
	PLA             ;RESTORE CHAR
NVS1
	JSR DSPP        ;DISPLAY THE CHARACTER
	CPY #69
	BNE NVS2        ;DO NOT RING BELL
	JSR BELL        ;RING END OF LINE BELL
NVS2
	JSR MOVCHR      ;MOVE TO NEXT CHAR POS
;
; ********* EXIT FROM PRT *********
;
LOOP2	LDA DATA        ;COPY LAST CHAR
	STA LSTCHR
	JSR MOVCUR      ;MOVE THE CURSOR
	PLA
	TAY
	LDA INSRT
	BEQ LOP2
	LSR QTSW
LOP2	PLA
	TAX
	PLA
	RTS
.END
; -------------------------------------------------------------
; ##### BWDISP #####
.PAG 'BWDISP 01/17/83'
;********************************
;
; DISPLAY A CHARACTER
;
;********************************
;
DOBLNK
	LDA #$20
;
DSPP
	LDY PNTR        ;GET CHAR INDEX
	JSR PAGSET      ;MAKE SURE RAM 0
	STA (PNT)Y      ;PUT CHAR ON SCREEN
	JSR PAGRES      ;RESTORE RAM PAGE
	RTS
.SKIP 3
;SUBROUTINE TO CLEAR ONE LINE
;                  X = LINE NUMBER
;         CLRLN :  BLANK ENTIRE LINE
;         CLRPRT:  Y = STARTING COLUMN POSITION
;
CLRLN
	LDY SCLF
	JSR CLRBIT      ;MAKE SURE NON-CONTINUED LINE
CLRPRT
	TXA             ;SAVE .X
	PHA
	LDA PNTR
	PHA
	DEY
CLR10
	INY
	STY PNTR
	JSR DOBLNK      ;PRINT A BLANK
	CPY SCRT        ;LINE COMPLETELY BLANK?
	BNE CLR10       ;BRANCH IF NOT
	PLA
	STA PNTR
	PLA
	TAX
	RTS
.SKIP 3
; GRAB A CHARACTER
;
GET1CH
	LDY PNTR        ;GET CHAR/COLOR INDEX
GETYCH
	JSR PAGSET      ;MAKE SURE RAM PAGE 0
	LDA (PNT)Y      ;GET THE CHARACTER
	JSR PAGRES      ;RESTORE RAM PAGE
	RTS
.SKIP 3
;*******************************************
;
;       SET TEXT/GRAPHIC MODE
;
CTEXT
	LDY #$10
	BCS CRTSET      ;SKIP IF GRAPHIC MODE
TXCRT
	LDY #0
CRTSET
	STY GRMODE      ;SET TEXT/GRAPHIC MODE
	LDA TPI1+CREG
	AND #$EF        ;MASK OUT TEXT/GRAPHIC BIT
	ORA GRMODE      ;ADD NEW TEXT/GRAPHIC BIT
	STA TPI1+CREG
	RTS
;
;  CRTINT  --  INTIALIZE CRT
;
CRTINT
	LDY #17         ;18 BYTE TABLE BUILT IN -1 FOR OFFSET
	BIT TPI2+PC     ;CHECK FOR TYPE
	BMI CRT10       ;BUIT-IN
	LDY #18+17      ;VALUES FOR NTSC
	BVS CRT10
	LDY #18+18+17   ;VALUES FOR PAL
CRT10
	LDX #17
CRT20
	LDA ATEXT,Y
	STX VDC+ADREG   ;INDEX TO REG.
	STA VDC+DAREG
	DEY
	DEX
	BPL CRT20
	RTS
.SKI 3
;**************************************************
;
;   HANDLE RAM PAGING
;
;**************************************************
PAGSET
	PHA
	LDA #$3F        ;FOR ROM PAGE
	BNE PAGSUB
PAGST2
	PHA
	LDA KEYSEG      ;FOR FUNCTION KEY PAGE
PAGSUB
	PHA
	LDA I6509       ;GET CURRENT PAGE NUMBER
	STA PAGSAV      ;- AND SAVE IT
	PLA
	STA I6509       ;SET TO RAM PAGE 0
	PLA             ;RESTORE A-REG
	RTS
.SKI 2
PAGRES	PHA             ;SAVE A-REG
	LDA PAGSAV      ;GET SAVED RAM PAGE NUMBER
	STA I6509       ;RESTORE RAM PAGE NUMBER
	PLA             ;RESTORE A-REG
	RTS
.SKI
.END
; -------------------------------------------------------------
; ##### BWFUN1 #####
.PAG 'FUNCS1 05/02/83'
; *** PRINT A CHAR ***
;
;
PRT	PHA
	CMP #$FF
	BNE PRT10
	LDA #$DE        ;CONVERT PI CHARACTER
PRT10
	STA DATA        ;SAVE CHAR
	TXA             ;SAVE REGS.
	PHA
	TYA
	PHA
	LDA #0
	STA CRSW
	LDY PNTR        ;COLUMN WE ARE IN
	LDA DATA
	AND #$7F
	CMP #$20        ;TEST IF CONTROL CHARACTER
	BCC NTCN        ;YES
	LDX LSTCHR      ;WAS LAST CHAR AN ESC
	CPX #$1B
	BNE NJT10       ;NO
	JSR SEQUEN      ;YES - DO ESC SEQUENCE
	JMP GETOUT
NJT10
	AND #$3F        ;NO - MAKE A SCREEN CHAR
NJT20
	BIT DATA
	BPL NJT30       ;SKIP AHEAD IF NORMAL SET - 00 - 3F
	ORA #$40        ; CONVERT A0 - BF TO 60 - 7F & C0 - DF TO 40 - 5F
NJT30
	JSR QTSWC       ;TEST FOR QUOTE
	JMP NXT3        ;PUT ON SCREEN
.SKIP 3
; ********* CONTROL KEYS *********
;
NTCN
	CMP #$0D        ;TEST IF A RETURN
	BEQ NTCN20      ;NO INVERSE IF YES
	CMP #$14        ;TEST IF INSERT OR DELETE
	BEQ NTCN20      ;ALLOW IN INSERT OR QUOTE MODE
	CMP #$1B        ;TEST IF ESCAPE KEY
	BNE NTCN1
	BIT DATA
	BMI NTCN1       ;ITS A $9B
	LDA QTSW        ;TEST IF IN QUOTE MODE...
	ORA INSRT       ;...OR INSERT MODE
	BEQ NTCN20      ;IF NOT, GO EXECUTE REMAINING CODE
	JSR TOQM        ;ELSE GO TURN OFF ALL MODES
	STA DATA        ;AND FORGET ABOUT THIS CHARACTER
	BEQ NTCN20      ;ALWAYS
NTCN1	CMP #$03        ;TEST IF A RUN/LOAD OR STOP
	BEQ NTCN20      ;NO INVERSE IF YES
	LDY INSRT       ;TEST IF IN INSERT MODE
	BNE NTCN10      ;GO REVERSE - IF YES
	LDY QTSW        ;CHECK FOR QUOTE MODE
	BEQ NTCN20      ;DO NOT REVERSE IF NOT
NTCN10
	ORA #$80        ;MAKE REVERSE
	BNE NJT20
.SKI
NTCN20
	LDA DATA
	ASL A           ;SET CARRY IF SHIFTED CTRL
	TAX
	JSR CTDSP       ;INDIRECT JSR
GETOUT
	JMP LOOP2
;
CTDSP	LDA CTABLE+1,X  ;HI BYTE
	PHA
	LDA CTABLE,X    ;LOW BYTE
	PHA
	LDA DATA
	RTS             ;INDIRECT JMP
.SKIP 3
;
CUSER	JMP (CTLVEC)
.SKIP 3
; CURSOR DOWN/UP
;
CDNUP	BCS CUP         ;CURSOR UP
;
CDWN	JSR NXLN        ;CURSOR DOWN
CDN10	JSR GETBIT      ;A WRAPPED LINE ?
	BCS CDRTS       ;SKIP IF YES
	SEC             ;FLAG WE LEFT LINE
	ROR LSXP
CDRTS
	CLC
	RTS
;
CUP	LDX SCTOP       ;CURSOR UP
	CPX TBLX        ;AT TOP OF WINDOW ?
	BCS CRITGO      ; YES - DO NOTHING
CUP10	JSR CDN10       ;ABOUT TO WRAP TO A NEW LINE ?
	DEC TBLX        ;UP A LINE
	JMP STUPT
.SKIP 3
; CURSOR RIGHT/LEFT
;
CRTLF	BCS CLEFT       ;CURSOR LEFT
;
CRIT	JSR NXTCHR      ;CURSOR RIGHT
	BCS CDN10       ;YES - TEST FOR WRAP
CRITGO
	RTS
;
CLEFT	JSR BAKCHR      ;MOVE BACK
	BCS CRITGO      ;ABORT IF AT TOP LEFT
	BNE CDRTS       ;NO - EXIT
	INC TBLX
	BNE CUP10       ;GO SET FLAG IF NEEDED
.SKIP 3
; RVS ON/OFF
;
RVSF	EOR #$80
	STA RVS
	RTS
.SKIP 3
; HOME/CLEAR
;
HOMCLR	BCC HOMES       ;HOME
	JMP CLSR        ;CLEAR SCREEN
;
HOMES	CMP LSTCHR      ;LAST CHAR A HOME ?
	BNE HM110       ;NO
	JSR SRESET      ;TOP=0,LEFT=0,BOT=NROWS-1,RT=COLS-1
HM110	JMP NXTD        ;SET TO TOP LEFT
.SKIP 3
; TAB FUNCTION
;
TABIT
	LDY PNTR
	BCS TABTOG      ; A TAB TOGGLE
TAB1	CPY SCRT        ;AT RIGHT OF WINDOW
	BCC TAB2        ;NO - TAB TO NEXT
	LDA SCRT        ;SET TO SCREEN RIGHT
	STA PNTR
	RTS
;
TAB2	INY             ;FIND NEXT TAB STOP
	JSR GETTAB
	BEQ TAB1        ;NOT YET !
	STY PNTR
	RTS
.SKIP 2
TABTOG
	JSR GETTAB      ;FLIP TAB STOP
	EOR BITMSK
	STA TAB,X
	RTS
.SKIP 3
;
; SKIP TO NEXT LINE
; WRAP TO TOP IF SCROLL DISABLED
;
NXLN
	LDX TBLX
	CPX SCBOT       ;OF THE BOTTOM OF WINDOW ?
	BCC NXLN1       ;NO
	BIT SCRDIS      ;WHAT IF SCROLLING IS DISABLED?
	BPL DOSCRL      ;BRANCH IF SCROLL IS ENABLED
	LDA SCTOP       ;WRAP TO TOP
	STA TBLX
	BCS NOWHOP      ;ALWAYS
;
DOSCRL
	JSR SCRUP       ;SCROLL IT ALL
	CLC             ;INDICATE SCROLL OK
NXLN1	INC TBLX
NOWHOP	JMP STUPT       ;SET LINE BASE ADR
.SKIP 3
; A RETURN OR SHIFT RETURN
;
NXT1	JSR FNDEND      ;FIND THE END OF THE CURRENT LINE
	INX
	JSR CLRBIT      ;SET NEXT LINE AS NON-CONTINUED
	LDY SCLF        ;ELSE POINT TO START OF NEXT LINE
	STY PNTR
	JSR NXLN        ;SET UP NEXT LINE
;**************************************
; TURN OFF ALL MODES
;   INCLUDE SOUND IF ENABLED
;   EXPECTED TO RETURN ZERO
;**************************************
TOQM
	LDA #0
	STA INSRT
	STA RVS
	STA QTSW
	CMP BELLMD      ;CHECK FOR BELL ENABLED
	BNE TOQMX       ;NO...
	STA SIDREG+VOLUME ;TURN OFF SID
TOQMX	RTS
.SKIP 3
; ****** SCROLL ROUTINES ******
;
.SKIP 2
; MOVE ONE LINE
;
MOVLIN
	LDA LDTB2,X
	STA SEDSAL
	LDA LDTB1,X
	STA SEDSAL+1
	JSR PAGSET      ;SET TO ROM PAGE
MOVL10
	LDA (SEDSAL),Y
	STA (PNT),Y
	CPY SCRT        ;DONE A WHOLE LINE ?
	INY
	BCC MOVL10      ;NO
	JMP PAGRES      ;RESTORE RAM PAGE
.SKIP 3
; ****** SCROLL DOWN ******
;
SCRDWN
	LDX LSXP
	BMI SCD30       ;SKIP IF NEW LINE FLAG ALREADY SET
	CPX TBLX
	BCC SCD30       ;SKIP IF OLD LINE IS BELOW SCROLL AREA
	INC LSXP        ;ELSE INC START LINE NUMBER
SCD30
	LDX SCBOT       ;SCROLL DOWN, START BOTTOM
SCD10
	JSR SCRSET      ;SET PNT TO LINE
	LDY SCLF
	CPX TBLX        ;TEST IF AT DESTINATION LINE
	BEQ SCD20       ;DONE IF YES
	DEX             ;POINT TO PREVIOUS LINE AS SOURCE
	JSR GETBT1
	INX
	JSR PUTBT1      ;MOVE CONTINUATION BYTE
	DEX
	JSR MOVLIN      ;MOVE ONE LINE
	BCS SCD10       ;ALWAYS
SCD20
	JSR CLRLN       ;SET LINE TO BLANKS
	JMP SETBIT      ;MARK AS CONTINUATION LINE
.SKIP 3
; ****** SCROLL UP ******
;
SCRUP
	LDX SCTOP
SCRU00
	INX
	JSR GETBT1      ;FIND FIRST NON-CONTINUED LINE
	BCC SCRU15
	CPX SCBOT       ;IS ENTIRE SCREEN 1 LINE?
	BCC SCRU00      ;DO NORMAL SCROLL IF NOT
	LDX SCTOP
	INX
	JSR CLRBIT      ;CLEAR TO ONLY SCROLL 1 LINE
SCRU15
	DEC TBLX
	BIT LSXP
	BMI SCRU20      ;NO CHANGE IF ALREADY NEW LINE
	DEC LSXP        ;MOVE INPUT UP ONE
SCRU20
	LDX SCTOP
	CPX SEDT2
	BCS SCRU30
	DEC SEDT2       ;IN CASE DOING INSERT
SCRU30
	JSR SCR10       ;SCROLL
	LDX SCTOP
	JSR GETBT1
	PHP
	JSR CLRBIT      ;MAKE SURE TOP LINE IS NOT CONTINUATION
	PLP
	BCC SCRU10      ;DONE IF TOP LINE OFF
	BIT LOGSCR      ;LOGICAL SCROLL ?
	BMI SCRU15      ;YES - KEEP SCROLLING
SCRU10	RTS
;
;
SCR10
	JSR SCRSET      ;POINT TO START OF LINE
	LDY SCLF
	CPX SCBOT       ;AT LAST LINE ?
	BCS SCR40       ;YES
	INX             ;POINT TO NEXT LINE
	JSR GETBT1
	DEX
	JSR PUTBT1      ;MOVE CONTINUATION BYTE
	INX
	JSR MOVLIN      ;MOVE ONE LINE
	BCS SCR10
;
SCR40
	JSR CLRLN       ;MAKE LAST LINE BLANK
	LDX #$FF
	LDY #$FE        ;ALLOW ONLY OUTPUT LINE 0
	JSR GETLIN      ;GET INPUT
	AND #$20        ;CHECK IF INTERRUPT I5 = CONTROL
	BNE SCR80       ;IF NOT SKIP AHEAD - NOT SLOW SCROLL
SCR60
	NOP             ;YES - WASTE TIME
	NOP
	DEX
	BNE SCR60
	DEY
	BNE SCR60
SCR70
	STY NDX
SCR75
	JMP KEYXT2      ;EXIT...SETUP LINES FOR STOP KEY CHECK
;
SCR80
	LDX #$F7        ;ALLOW ONLY OUTPUT LINE 11
	LDY #$FF
	JSR GETLIN      ;GET INPUT LINES KEY
	AND #$10        ;CHECK FOR THE COMMODORE KEY
	BNE SCR75       ;EXIT IF NOT - NO STOP SCROLL
SCR90
	JSR GETLIN      ;GET INPUT LINES
	AND #$10        ;CHECK FOR THE COMMODORE KEY
	BEQ SCR90       ;WAIT UNTIL COM.KEY NOT DEPRESSED
SCR95
	LDY #0
	LDX #0          ;ALLOW ALL OUTPUT LINES
	JSR GETLIN      ;GET INPUTS
	AND #$3F        ;CHECK FOR ANY INPUT
	EOR #$3F
	BEQ SCR95       ;WAIT
	BNE SCR70       ;ALWAYS
.SKI 3
GETLIN
	PHP             ;PRESERVE THE IRQ FLAG
	SEI
	STX TPI2+PA     ;SET PORT-A OUTPUT
	STY TPI2+PB     ;SET PORT-B OUTPUTS
	JSR GETKEY      ;GET PORT-C INPUTS
	PLP
	RTS
.SKI  5
;RING THE BELL, IF ENABLED
BELL
     LDA BELLMD
     BNE BELLGO
     LDA #$0F
     STA SIDREG+24 ;TURN UP VOLUME
     LDY #00
     STY SIDREG+5 ;ATTACK=0-DECAY=9
     LDA #10
     STA SIDREG+6 ;SUSTAIN=0-RELEASE=0
     LDA #48
     STA SIDREG+1 ;VOICE 1 FREQ.
     LDA #96
     STA SIDREG+15 ;VOICE 3 FREQ.
     LDX #$15
     STX SIDREG+4
BELL10
     NOP
     NOP ;WAIT TO REACH SUSTAIN LEVEL
     INY
     BNE BELL10
     DEX
     STX SIDREG+4 ;GATE OFF
BELLGO
     RTS
;
; CE - CLEAR ENTRY
;   ALWAYS DELETES LAST CHARACTER ENTERED
;   WILL DELETE ALL <#>S. (0 1 2 3 4 5 6 7 8 9 .)
;   WILL DELETE IF (<#>E<+/->)
;   CURSOR MUST BE NEXT POSISTION BEYOND ENTRY BEING DELETED.
;
CE	LDA PNTR        ;GET INDEX ON LINE
	PHA             ;SAVE FOR FINAL DELETE IF NECESSARY
CET0	LDY PNTR
	DEY
	JSR GETYCH      ;GET PREVIOUS CHARACTER
	CMP #43         ;(+)
	BEQ CET1
	CMP #45         ;(-)
	BNE CET2
;
CET1	DEY             ;TRY FOR AN <#>E
	JSR GETYCH
	CMP #5          ;(E)
	BNE CET4        ;EXIT IF NOT...IT CAN ONLY BE AN <#>E
;
CET2	CMP #5          ;(E)
	BNE CET3
	DEY
	JSR GETYCH
;
CET3	CMP #46         ;TRY FOR A <#>
	BCC CET4        ;(.)
	CMP #47
	BEQ CET4
	CMP #58         ; (0-9)
	BCS CET4
;
	JSR DELEET
	JMP CET0
;
CET4	PLA             ;CHECK IF ANY DELETES OCCURED
	CMP PNTR
	BNE BELLGO      ;YES...EXIT
	JMP DELEET      ;ELSE... GO DELETE A CHARACTER
.END
; -------------------------------------------------------------
; ##### BWSUBS #####
.PAG 'BWSUBS 05/31/83'
;  WRAP TABLE SUBROUTINES
;
GETBIT
	LDX TBLX
GETBT1
	JSR BITPOS      ;GET BYTE & BIT POSITIONS
	AND BITABL,X
	CMP #1          ;MAKE CARRY CLEAR IF ZERO
	JMP BITOUT
;
; PUTBIT - SET BIT ACCORDING TO CARRY
;
PUTBIT
	LDX TBLX
PUTBT1
	BCS SETBIT      ;GO IF TO MARK AS WRAPPPED LINE
;
; CLRBIT - CLEAR WRAP BIT
;
CLRBIT
	JSR BITPOS      ;GET BYTE & BIT POSITIONS
	EOR #$FF        ;INVERT BIT POSITION
	AND BITABL,X    ;CLEAR BIT
BITSAV
	STA BITABL,X
BITOUT
	LDX BITMSK
	RTS
;
; SETBIT  -  SET BIT TO MARK AS WRAPPED LINE
;
SETBIT
	BIT SCRDIS      ;AUTO LINE LINK DISABLE...
	BVS GETBT1
	JSR BITPOS      ;GET BYTE & BIT POSITION
	ORA BITABL,X    ;SET WRAP BIT
	BNE BITSAV      ;ALWAYS
;
; BITPOS - GET BYTE & BIT POSITION OF WRAP BIT
;          INPUT - X = ROW NUMBER
;          OUTPUT - X = BYTE NUMBER
;                   A = BIT MASK
;
BITPOS
	STX BITMSK
	TXA
	AND #$07        ;GET BIT POSITION
	TAX
	LDA BITS,X      ;GET BIT MASK
	PHA
	LDA BITMSK
	LSR A
	LSR A           ;SHIFT TO GET BYTE POSITION
	LSR A
	TAX
	PLA
	RTS
.SKI 3
;**********************************
;  MOVE TO START OF LINE
;
FNDFST
	LDY SCLF
	STY PNTR        ;SET TO LEFTMOST COLUMN
;
FISTRT
	JSR GETBIT      ;FIND START OF CURRENT LINE
	BCC FND0        ;BRANCH IF FOUND
	DEC TBLX        ;UP A LINE
	BPL FISTRT      ;ALWAYS
	INC TBLX        ;WHOOPS WENT TOO FAR
FND0
	JMP STUPT       ;SET LINE BASE ADR
.SKIP 3
; ****** FIND LAST NON-BLANK CHAR OF LINE
;
; PNTR= COLUMN #
; TBLX= LINE #
;
FNDEND	LDA TBLX        ;CHECK IF WE ARE AT THE BOTTOM
	CMP SCBOT
	BCS ELOUPP      ;YES...
	INC TBLX
	JSR GETBIT      ;IS THIS LINE CONTINUED
	BCS FNDEND      ;BRANCH IF SO
ELOUP0	DEC TBLX        ;FOUND IT - COMPENSATE FOR INC TBLX
ELOUPP	JSR STUPT
	LDY SCRT        ;GET RIGHT MARGIN
	STY PNTR        ;POINT TO RIGHT MARGIN
	BPL ELOUP2      ;ALWAYS
;
ELOUP1	JSR BAKCHR
	BCS ENDBYE      ;IF AT TOP LEFT GET OUT
ELOUP2	JSR GET1CH
	CMP #$20
	BNE ENDBYE      ;YES
	CPY SCLF        ;ARE WE AT THE LEFT MARGIN?
	BNE ELOUP1      ;BRANCH IF NOT
	JSR GETBIT      ;IF WE'RE ON A WRAPED LINE
	BCS ELOUP1      ; ALWAYS SCAN THE ABOVE LINE
;
ENDBYE
	STY INDX        ;REMEMBER THIS
	RTS
.SKIP 3
; ****** MOVE TO NEXT CHAR
; SCROLL IF ENABLED
; WRAP TO TOP IF DISABLED
;
NXTCHR
	PHA
	LDY PNTR
	CPY SCRT        ;ARE WE AT THE RIGHT MARGIN?
	BCC BUMPNT      ;BRANCH IF NOT
.SKI
	JSR NXLN        ;POINT TO NEXTLINE
	LDY SCLF        ;POINT TO FIRST CHAR OF 1ST LINE
	DEY
	SEC             ;SET TO SHOW MOVED TO NEW LINE
BUMPNT	INY             ;INCREMENT CHAR INDEX
	STY PNTR
	PLA
	RTS
.SKIP 3
; ****** BACKUP ONE CHAR
; WRAP UP AND STOP A TOP LEFT
;
BAKCHR
	LDY PNTR
	DEY
	BMI BAKOT1
	CPY SCLF        ;ARE WE AT THE LEFT MARGIN
	BCS BAKOUT      ;NO - PAST IT
BAKOT1
	LDY SCTOP
	CPY TBLX        ;ARE WE AT TOP LINE LAST CHARACTER?
	BCS BAKOT2      ;LEAVE WITH CARRY SET
	DEC TBLX        ;ELSE BACKUP A LINE
	PHA
	JSR STUPT       ;SET LINE BASE ADR
	PLA
	LDY SCRT        ;MOVE CURSOR TO RIGHT SIDE
BAKOUT
	STY PNTR
	CPY SCRT        ;SET Z-FLAG IF MOVED TO NEW LINE
	CLC             ;ALWAYS CLEAR
BAKOT2	RTS
.SKI 3
;  SAVPOS - SAVE ROW & COLUMN POSITION
;
SAVPOS
	LDY PNTR
	STY SEDT1
	LDX TBLX
	STX SEDT2
	RTS
.PAG
DELINS
	BCS INSERT
.SKI
; DELETE A CHARACTER
;
DELEET
	JSR CLEFT       ;MOVE BACK 1 POSITION
	JSR SAVPOS      ;SAVE COLUMN & ROW POSITIONS
	BCS DELOUT      ;ABORT IF AT TOP LEFT CORNER
DELOOP
	CPY SCRT        ;AT RIGHT MARGIN?
	BCC DELOP1      ;NO - SKIP AHEAD
	LDX TBLX
	INX
	JSR GETBT1      ;IS NEXT LINE A WRAPPED LINE?
	BCS DELOP1      ;YES - CONTINUE WITH DELETE
	JSR DOBLNK      ;NO - BALNK LAST CHARACTER
DELOUT
	LDA SEDT1       ;RESTORE COLUMN AND ROW POSITIONS
	STA PNTR
	LDA SEDT2
	STA TBLX
	JMP STUPT       ;RESTORE PNT AND EXIT
DELOP1
	JSR NXTCHR
	JSR GET1CH      ;GET NEXT CHARACTER
	JSR BAKCHR
	JSR DSPP        ;MOVE IT BACK 1 POSITION
	JSR NXTCHR      ;MOVE UP 1 POSITION
	JMP DELOOP      ;LOOP UNTIL AT END OF LINE
.SKI 3
; INSERT A CHARACTER
;
INSERT
	JSR SAVPOS      ;SAVE COLUMN & ROW POSITIONS
	JSR FNDEND      ;MOVE TO LAST CHAR ON THE LINE
	CPX SEDT2       ;LAST ROW EQUAL TO STARTING ROW?
	BNE INS10       ;NO - SKIP AHEAD
	CPY SEDT1       ;IS LAST POSITION BEFORE STARTING POSITION?
INS10
	BCC INS50       ;YES - NO NEED TO MOVE ANYTHING
	JSR MOVCHR      ;MOVE TO NEXT CHAR POSITION
	BCS INSOUT      ;ABORT IF SCROLL NEEDED BUT DISABLED
INS30
	JSR BAKCHR
	JSR GET1CH      ;MOVE CHAR FORWARD 1 POSITION
	JSR NXTCHR
	JSR DSPP
	JSR BAKCHR
	LDX TBLX
	CPX SEDT2       ;AT ORIGINAL POSITION
	BNE INS30
	CPY SEDT1
	BNE INS30       ;NO - LOOP TILL WE ARE
	JSR DOBLNK      ;INSERT A BLANK
INS50
	INC INSRT       ;INC INSERT COUNT
	BNE INSOUT      ;ONLY ALLOW UP TO 255
	DEC INSRT
INSOUT
	JMP DELOUT      ;RESTORE ORIGINAL POSITION
.SKI 3
;
;  STOP/RUN
;
STPRUN
	BCC RUNRTS      ;EXIT IF A STOP CODE
	SEI             ;DISABLE INTERRUPTS
	LDX #9
	STX NDX         ;SET KEYBOARD QUEUE SIZE
RUNLOP
	LDA RUNTB-1,X
	STA KEYD-1,X    ;LOAD RUN CHARACTER SEQUENCE INTO KYBD QUEUE
	DEX
	BNE RUNLOP
	CLI             ;ENABLE INTERRUPTS
RUNRTS
	RTS
.SKI 3
;  MOVCHR  -  MOVE TO NEXT CHAR POSITION
;             INSERT BLANK LINE IF AT END OF LINE
;             Y = COLUMN POSITION
;              ON EXIT - CARRY SET = ABORT - SCROLL DISABLED
;
MOVCHR
	CPY SCRT
	BCC MOVC10      ;EASY IF NOT AT END OF LINE
	LDX TBLX
	CPX SCBOT
	BCC MOVC10      ;SKIP IF NOT LAST LINE OF SCREEN
	BIT SCRDIS
	BMI MOVC30      ;ABORT IF SCROLLING DISABLED
MOVC10
	JSR STUPT       ;SET PNT ADDRESS
	JSR NXTCHR      ;MOVE TO NEXT CHAR POSITION
	BCC MOVC30      ;DONE IF NOT MOVE TO NEW LINE
	JSR GETBIT      ;CHECK IF ON A CONTINUED LINE
	BCS MOVC20      ;SKIP AHEAD IF NOT
	JSR PATCH1      ;PATCH IN A CHECK FOR SINGLE LINE SCREEN
	SEC             ;PREP FOR ABORT...
	BVS MOVC30
	JSR SCRDWN      ;ELSE INSERT A BLANK LINE
MOVC20
	CLC             ;FOR CLEAN EXIT
MOVC30
	RTS
.SKI 2
.END
; -------------------------------------------------------------
; ##### BWFUN2 #####
.PAG 'FUNCS2 05/01/83'
SEQUEN
	JMP (ESCVEC)    ;ESCAPE INDIRECT
.SKIP 3
;******************************
;
;  INSERT LINE
;
;*****************************
;
ILINE
	JSR SCRDWN      ;INSERT A BLANK LINE
	JSR STU10       ;MOVE TO START OF LINE
	INX
	JSR GETBT1
	PHP
	JSR PUTBIT      ;SET CONTINUATION SAME AS IN PREVIOUS LINE
	PLP
	BCS LINRTS      ;SKIP IF WAS WRAPPED
	SEC
	ROR LSXP        ;SET FLAG - NEW LINE
LINRTS
	RTS
.SKI 3
;**************************
;
; DELETE LINE
;
;**************************
DLINE	JSR FISTRT      ;FIND START OF LINE
	LDA SCTOP       ;SAVE CURRENT OF WINDOW
	PHA
	LDA TBLX        ;MAKE 1ST DISPLAY LINE TOP OF WINDOW
	STA SCTOP
	LDA LOGSCR      ;MAKE SURE LOGICAL SCRL IS OFF
	PHA
	LDA #$80
	STA LOGSCR
	JSR SCRU15      ;SCROLL THE TOP LINE AWAY
	PLA
	STA LOGSCR
	LDA SCTOP       ;MAKE OLD 1ST LINE OF THIS 1 CURRENT
	STA TBLX
	PLA
	STA SCTOP
	SEC
	ROR LSXP        ;SET FLAG - NEW LINE
	JMP STU10       ;MAKE THIS LINE THE CURRENT ONE
.SKI 3
;******************************
;
; ERASE TO END OF LINE
;
;******************************
.SKI
ETOEOL	JSR SAVPOS
ETOL	JSR CLRPRT      ;BLANK REST OF LINE
	INC TBLX        ;MOVE TO NEXT LINE
	JSR STUPT
	LDY SCLF
	JSR GETBIT      ;CHECK IF NEXT IS WRAPPED LINE
	BCS ETOL        ;YES - BLANK NEXT LINE
ETOUT
	JMP DELOUT      ;EXIT AND RESTORE ORIGINAL POSITION
.SKI 3
;*****************************
;
; ERASE TO START OF LINE
;
;*****************************
.SKI
ETOSOL	JSR SAVPOS
ETSTOL	JSR DOBLNK      ;DO A BLANK
	CPY SCLF        ;DONE A LINE ?
	BNE ETS100      ;NO
	JSR GETBIT      ;AT TOP OF LINE
	BCC ETOUT       ;YES - EXIT
ETS100	JSR BAKCHR      ;BACK UP
	BCC ETSTOL      ;ALWAYS
.SKI 3
;*****************************
;
; SCROLL UP
;
;*****************************
;
SUUP	JSR SAVPOS
	TXA
	PHA
	JSR SCRUP
	PLA
	STA SEDT2
	JMP ETOUT       ;ALWAYS
.SKIP 3
;*****************************
;
; SCROLL DOWN
;
;*****************************
;
SDDN	JSR SAVPOS
	JSR GETBIT
	BCS SDDN2
	SEC
	ROR LSXP        ;SET FLAG - LEFT LINE
SDDN2
	LDA SCTOP
	STA TBLX        ;SCROLL FROM SCREEN TOP
	JSR SCRDWN
	JSR CLRBIT      ;MAKE FIRST LINE NON-CONTINUED
	JMP ETOUT       ;ALWAYS
.SKI
;
; SCROLLING ENABLE/DISABLE
;           CARRY SET = DISABLE
SCRSW0
	CLC             ;ENABLE SCROLLING
	.BYTE $24
SCRSW1
	SEC             ;DISABLE SCROLLING
SCRSW
	LDA #0
	ROR A
	STA SCRDIS
	RTS
.SKI
;
; LOGICAL SCROLL ENABLE/DISABLE
;              CARRY SET = ENABLE
LOGSW0
	CLC             ;DISABLE LOGICAL SCROLL (SINGLE LINE SCROLL)
	BCC LOGSW
LOGSW1
	SEC             ;ENABLE LOGICAL SCROLL (SCROLL A SET OF LINES)
LOGSW
	LDA #0
	ROR A
	STA LOGSCR
	RTS
.SKI 3
;******************************************
;
; PROGRAMMABLE KEY FUNCTIONS
;
;******************************************
;
KEYFUN
	SEI             ;PREVENT FIGHT OVER VARIABLES WITH KEYSCAN...
	DEY
	BMI LISTKY      ;DO LIST IF NO PARAMETERS GIVEN
	JMP ADDKEY      ;- ELSE GO ADD A NEW KEY DEFINITION
;
;   LIST KEY DEFINTIONS
;
LISTKY	LDY #0          ;INITIALIZE KEY COUNTER
;
LISTLP
	INY
	STY SEDT3
	DEY             ;MINUS 1 FOR INDEXING
	LDA KEYSIZ,Y    ;GET KEY LENGTH
	BEQ NODEFN      ;NO LISTING IF NO DEFINTION
	STA KEYIDX      ;SAVE KEY LENGTH
	JSR FINDKY      ;GET BUFFER START ADDR FOR FUNCTION KEY
	STA KEYPNT
	STX KEYPNT+1    ;SAVE 2 BYTE ADDRESS IN TEMP LOC
	LDX #3
;
PREAMB	LDA KEWORD,X    ;PRINT 'KEY ' PREAMBLE
	JSR BSOUT
	DEX
	BPL PREAMB
;
	LDX #$2F
	LDA SEDT3       ;GET KEY NUMBER
	SEC
KY2ASC	INX             ;CONVERT TO 1 OR 2 DIGIT ASCII
	SBC #10
	BCS KY2ASC
	ADC #$3A        ;ADD 10 & MAKE ASCII
	CPX #$30
	BEQ NOSEC       ;SKIP 2ND DIGIT PRINT
	PHA             ;SAVE FIRST DIGIT-10
	TXA
	JSR BSOUT       ;PRINT SECOND DIGIT
	PLA             ;RESTORE FIRST DIGIT-10
;
NOSEC
	JSR BSOUT       ;PRINT FIRST DIGIT
	LDY #0          ;INIT STRING POSITION COUNTER
	LDA #',         ;FOR COMMA PRINT
LSTK20	JSR BSOUT       ;PRINT CHAR - COMMA OR PLUS-SIGN
	LDX #7          ;FOR CHR$ PRINTING - NO PLUS-SIGN OR QUOTE TO PRECEED
TXTPRT
	JSR PAGST2      ;MAKE SURE FUNCTION KEY RAM PAGE
	LDA (KEYPNT),Y  ;GET BYTE
	JSR PAGRES
	CMP #13
	BEQ LSTKCR      ;PRINT CHR$(13) FOR RETURN
	CMP #141
	BEQ LSTKSC      ;PRINT CHR$(141) FOR RETURN
	CMP #34
	BEQ LSTKQT      ;PRINT CHR$(34) FOR QUOTE
	CPX #9          ;WAS A NORMAL CHAR PRINTED LAST TIME
	BEQ LSTK10      ;YES - SKIP AHEAD
	PHA             ;SAVE CHAR
	LDA #'"
	JSR BSOUT       ;PRINT A QUOTE
	PLA             ;RESTORE THE CHAR
;
LSTK10	JSR BSOUT       ;PRINT THE CHAR
	LDX #9          ;FOR CHR$ - PRINT QUOTE AND PLUS NEXT TIME
	INY
	CPY KEYIDX
	BNE TXTPRT      ;LOOP TO END OF STRING
;
	LDA #'"
	JSR BSOUT       ;PRINT ENDING QUOTE
;
LSTK30
	LDA #$0D
	JSR BSOUT       ;DO A RETURN
NODEFN
	LDY SEDT3       ;GET KEY NUMBER
	CPY #PGMKYS
	BNE LISTLP      ;LOOP TIL ALL KEYS CHECKED
	CLI             ;ALL DONE...CLEAR THE KEYSCAN HOLDOFF
	CLC             ;OKAY RETURN ALWAYS
	RTS
;
LSTKCR	LDX #QTWORD-CDWORD-1 ;INDEX FOR RETURN
	.BYT $2C        ;SKIP 2
LSTKSC	LDX #ADDKEY-CDWORD-1 ;INDEX FOR SHIFTED-RETURN
	.BYT $2C        ;SKIP 2
LSTKQT	LDX #SCWORD-CDWORD-1 ;INDEX FOR QUOTE
;
LSTK	TXA             ;SAVE VALUE INDEX....
	PHA             ;SAVE .X
	LDX #CRWORD-CDWORD-1 ;PRINT CHR$(
LSTKLP	LDA CDWORD,X    ;PRINT LOOP
	BEQ LSTK40      ;ZERO IS END...
	JSR BSOUT       ;
	DEX
	BPL LSTKLP
	PLA             ;MOVE NUMBER AND REPEAT
	TAX
	BNE LSTKLP
;
LSTK40	INY
	CPY KEYIDX
	BEQ LSTK30      ;EXIT IF ALL STRING PRINTED
	LDA #'+         ;SET TO PRINT PLUS SIGN
	BNE LSTK20      ;RETURN TO ROUTINE
;
;
KEWORD	.BYTE ' YEK'
CDWORD	.BYTE '($RHC+' ; hinter dem + noch "
CRWORD	.BYTE 0,')31'
QTWORD	.BYTE 0,')43'
SCWORD	.BYTE 0,')141'
.SKI 3
;
;   INSERT A NEW KEY DEFINTION
;
ADDKEY
	PHA             ;SAVE ZERO PAGE ADDRESS OF PARAMS
	TAX
	STY SEDT1       ;SAVE KEY NUMBER IN TEMP LOC
	LDA $0,X        ;GET NEW STRING LENGTH
	SEC
	SBC KEYSIZ,Y    ;SUBTRACT OLD LENGTH
	STA SEDT2       ;SAVE DIFFERENCE IN TEMP LOCATION
	ROR FKTMP       ;SAVE THE CARRY
	INY
	JSR FINDKY      ;FIND START ADDR OF NEXT FUNCTION KEY
	STA SEDSAL
	STX SEDSAL+1    ;SAVE 2 BYTE ADDRESS IN TEMP LOC
	LDY #PGMKYS
	JSR FINDKY      ;FIND END OF LAST FUNCTION KEY
	STA SEDEAL
	STX SEDEAL+1    ;SAVE NEXT FREE BYTE ADDR IN TEMP LOC
	LDY FKTMP       ;CHECK IF NEW STRING IS LONGER OR SHORTER
	BPL KEYSHO      ;SKIP AHEAD IF SHORTER
	CLC
	SBC PKYEND      ;SUBTRACT LAST AVAILABLE ADRESS
	TAY
	TXA
	SBC PKYEND+1
	TAX
	TYA
	CLC
	ADC SEDT2       ;ADD DIFFERENCE
	TXA
	ADC #0
	BCS KYXIT       ;SKIP IF MEMORY NOT FULL
;
; EXPAND OR CONTRACT KEY AREA TO MAKE ROOM FOR NEW
;   KEY DEFINITION.
;
KEYSHO
	JSR PAGST2      ;SET UP FUNCTION KEY RAM PAGE
KYMOVE
	LDA SEDEAL
	CLC             ;CHECK IF ENTIRE AREA EXPANDED OR CONTRACTED
	SBC SEDSAL
	LDA SEDEAL+1
	SBC SEDSAL+1
	BCC KEYINS      ;GO INSERT NEW KEY DEFINTION IF YES
	LDY #0
	LDA FKTMP       ;CHECK IF EXPAND OR CONTRACT
	BPL KSHORT      ;SKIP IF NEEDS TO BE CONTRACTED
	LDA SEDEAL
	BNE NEWKY4      ;DEC 1 FROM SOURCE ADDR
	DEC SEDEAL+1    ;SUB 1 FOR BORROW
NEWKY4
	DEC SEDEAL
	LDA (SEDEAL),Y  ;MOVE 1 BYTE UP TO EXPAND
	LDY SEDT2       ;GET OFFSET = DIFFERENCE
	STA (SEDEAL),Y  ;MOVE BYTE UP
	JMP KYMOVE      ;LOOP UNTIL ALL BYTES MOVED
KSHORT
	LDA (SEDSAL),Y  ;GET SOURCE BYTE
	LDY SEDT2       ;GET OFFSET = DIFFERENCE
	DEC SEDSAL+1    ;SUB 1 TO MOVE DOWN
	STA (SEDSAL),Y  ;MOVE THE BYTE DOWN
	INC SEDSAL+1
	INC SEDSAL      ;MOVE SOURCE UP 1 BYTE
	BNE KYMOVE
	INC SEDSAL+1    ;ADD 1 FOR CARRY
	BNE KYMOVE      ;ALWAYS
;
;  INSERT THE NEW STRING DEFINTION
;
KEYINS
	LDY SEDT1       ;GET THE KEY INDEX
	JSR FINDKY      ;FIND BUFFER START ADDRESS FOR THIS KEY
	STA SEDSAL
	STX SEDSAL+1    ;SAVE 2 BYTE ADDRESS IN TEMP LOC
	LDY SEDT1
	PLA
	PHA
	TAX             ;GET ZERO PAGE ADDR OF PARAMS
	LDA $0,X
	STA KEYSIZ,Y    ;SAVE KEY LENGTH
	TAY
	BEQ KYINOK      ;EQUAL TO ZERO NO KEYS...EXIT
	LDA $1,X        ;GET & SAVE LOW BYTE OF STRING ADDRESS
	STA SEDEAL
	LDA $2,X        ;GET & SAVE HIGH BYTE OF STRING ADDRESS
	STA SEDEAL+1
KYINLP
	DEY
	LDA $3,X        ;GET STRING RAM PAGE
	STA I6509
	LDA (SEDEAL),Y  ;GET BYTE
	JSR PAGRES      ;RESTORE ORIGINAL RAM PAGE
	JSR PAGST2      ;SET UP FUNCTION KEY RAM PAGE
	STA (SEDSAL),Y  ;STORE INTO BUFFER
	TYA             ;.Y FLAGS...END?
	BNE KYINLP      ;NO... LOOP
KYINOK
	JSR PAGRES
	CLC             ;FOR GOOD EXIT CARRY CLEAR
KYXIT	PLA             ;POP ZERO PAGE ADDRESS FOR PARAMS
	CLI             ;ALL DONE...RELEASE KEYSCAN
	RTS             ; C-SET IS MEMORY FULL ERROR
.END
; -------------------------------------------------------------
; ##### BWKYBD #####
.PAG 'KEYBD  01/18/83'
;*******************************
;
; KEYBOARD SCANNER
;
;*******************************
KEY
	LDY #$FF        ;SAY NO KEYS PRESSED (REAL-TIME KEYSCAN)
	STY MODKEY
	STY NORKEY
	INY             ;INIT BASE KYBD INDEX = 0
	STY TPI2+PB     ;ALLOW ALL OUTPUT LINES
	STY TPI2+PA
	JSR GETKEY      ;GET KEYBD INPUT
	AND #$3F        ;CHECK IF ANY INPUTS
	EOR #$3F
	BNE *+5         ;HOP OVER LONG BRANCH
	JMP NULXIT      ;EXIT IF NONE
	LDA #$FF
	STA TPI2+PA     ;ALLOW ONLY OUTPUT LINE 0
	ASL A
	STA TPI2+PB
	JSR GETKEY      ;GET INPUT FROM LINE 0
	PHA             ;SAVE SHIFT & CONTROL BITS
	STA MODKEY      ;SHIFT KEYS ARE DOWN
	ORA #$30        ;MASK THEM BY SETTING BITS
	BNE LINE01
LINELP
	JSR GETKEY      ;GET LINE INPUTS
LINE01
	LDX #5          ;LOOP FOR 6 INPUT LINES
KYLOOP
	LSR A           ;CHECK LINE
	BCC HAVKEY      ;SKIP AHEAD IF HAVE INPUT
	INY             ;INC KEYD CODE COUNT
	DEX
	BPL KYLOOP
	SEC
	ROL TPI2+PB     ;ROTATE TO ACTIVATE NEXT
	ROL TPI2+PA     ; - OUTPUT LINE
	BCS LINELP      ;LOOP UNTIL ALL LINES DONE
	PLA             ;CLEAR SHIFT/CONTROL BYTE
	BCC NULXIT      ;EXIT IF NO KEY
;
;      GET PET-ASCII USING KEYBOARD INDEX
;      AND SHIFT AND CONTROL INPUTS
;
HAVKEY
	STY NORKEY      ;HAVE A NORMAL KEYPRESS
	LDX NORMTB,Y
	PLA             ;GET SHIFT/CONTROL BYTE
	ASL A
	ASL A           ;MOVE BITS LEFT
	ASL A
	BCC DOCTL       ;SKIP AHEAD IF CONTROL DEPRESSED
	BMI HAVASC      ;SKIP AHEAD IF NOT SHIFTED - HAVE ASCII
	LDX SHFTTB,Y    ;ASSUME SHITED TEXTUAL
	LDA GRMODE      ;TEST TEXT OR GRAPHIC MODE
	BEQ HAVASC      ;HAVE KEY IF TEXT MODE
	LDX SHFTGR,Y    ;GET SHIFTED GRAPHIC
	BNE HAVASC      ;GO PROCESS ASCII KEY
;
DOCTL
     LDX CTLTBL,Y ;GET PET-ASCII CHAR FOR THIS KEY
;
;     Y-REG HAS KEYBOARD INDEX VALUE
;     X-REG HAS PET-ASCII VALUE
;
HAVASC	CPX #$FF
	BEQ KEYXIT      ;EXIT IF NULL PET-ASCII
	CPX #$E0        ;CHECK IF FUNCTION KEY
	BCC NOTFUN      ;SKIP - NOT A FUNCTION KEY
	TYA
	PHA
	JSR FUNJMP      ;DO FUNCTION KEY INDIRECT
	PLA
	TAY
	BCS KEYXIT      ;DONE IF CARRY FLAG SET
NOTFUN
	TXA             ;GET PET-ASCII CODE
	CPY LSTX        ;CHECK IF SAME KEY AS LAST
;         TIME THROUGH
	BEQ DORPT       ;SKIP AHEAD IF SO
;
;     A NEW KEY INPUT - CHECK QUEUE AVAILABILITY
;
	LDX #19
	STX DELAY       ;RESET INITIAL DELAY COUNT
	LDX NDX         ;GET KEY-IN QUEUE SIZE
	CPX #KEYMAX     ;CHECK IF QUEUE FULL
	BEQ NULXIT      ;EXIT IF YES
	CPY #DBLZER     ;CHECK IF KEYPAD - 00
	BNE SAVKEY      ;GO SAVE KEY-IN IF NOT
	CPX #KEYMAX-1   ;CHECK IF ROOM FOR TWO
	BEQ NULXIT      ;EXIT IF NOT
	STA KEYD,X      ;SAVE FIRST ZERO
	INX             ;UPDATE QUEUE SIZE
	BNE SAVKEY      ;ALWAYS
;
NULXIT	LDY #$FF
KEYXIT	STY LSTX        ;SAVE LAST KEY NUMBER
KEYXT2	LDX #$7F
	STX TPI2+PA     ;RESET OUTPUT LINES TO ALLOW
	LDX #$FF        ;- STOP KEY INPUT
	STX TPI2+PB
	RTS
;
;     CHECK REPEAT DELAYS
;
DORPT
	DEC DELAY       ;DEC INITIAL DELAY COUNT
	BPL KEYXT2      ;EXIT IF WAS NOT ZERO - STILL ON 1ST DELAY
	INC DELAY       ; - ELSE RESET COUNT TO ZERO
;
;     CHECK IF SECONDARY COUNT DOWN TO ZERO
;
	DEC RPTCNT      ;DEC REPEAT BTWN KEYS
	BPL KEYXT2      ;EXIT IF WAS NOT ZERO - STILL ON DELAY
	INC RPTCNT      ;RESET BACK TO ZERO
;
;     TIME TO REPEAT - CHECK IF KEY QUEUE EMPTY
;
	LDX NDX         ;GET KYBD QUEUE SIZE
	BNE KEYXT2      ;EXIT IF KYBD QUEUE NOT EMPTY
;
;     SAVE PET-ASCII INTO KEY BUFFER
;
SAVKEY
	STA KEYD,X      ;STORE PET-ASCII IN KYBD BUFFER
	INX
	STX NDX
	LDX #3
	STX RPTCNT      ;RESET DELAY BTWN KEYS
	BNE KEYXIT
;
GETKEY
	LDA TPI2+PC     ;DEBOUNCE KEYBOARD INPUT
	CMP TPI2+PC
	BNE GETKEY
	RTS
;
FUNJMP
	JMP (FUNVEC)    ;FUNCTION KEY INDIRECT
;
DOKEYF	CPY LSTX
	BEQ FUNRTS      ;EXIT NOT ALLOWED TO REPEAT
	LDA NDX
	ORA KYNDX
	BNE FUNRTS      ;EXIT - FUNCTION QUEUE NOT EMPTY
	STA KEYIDX      ;INIT POINTER INDEX INTO FUNCTION AREA
	TXA
	AND #$1F        ;MASK OUT TO GET FUNCTION KEY NUMBER
	TAY
	LDA KEYSIZ,Y    ;GET FUNCTION KEY SIZE
	STA KYNDX       ;- AND STORE IT FOR KEY SCAN
	JSR FINDKY
	STA KEYPNT      ;GET FUNCTION START ADDR
	STX KEYPNT+1    ;- AND SAVE IN KEYPNT
FUNRTS
	SEC
	RTS
.SKI 3
;
;   FIND ADDRESS OF FUNCTION KEY GIVEN IN Y-REG
;
FINDKY	LDA PKYBUF
	LDX PKYBUF+1
;
FINDLP	CLC
	DEY             ;FOUND KEY YET?
	BMI FNDOUT      ;YES - DONE
	ADC KEYSIZ,Y    ;ADD FUNCTION KEY SIZE
	BCC FINDLP      ;LOOP IF NO HIGH BYTE CARRY-OVER
	INX
	BNE FINDLP      ;LOOP - ALWAYS
;
FNDOUT
	RTS
.SKI 4
;
;TAB SET-UP (TAB POSITIONER)
; Y=COLUMN IN QUESTION
;
GETTAB
	TYA             ;GET BIT IN QUESTION
	AND #$07
	TAX
	LDA BITS,X
	STA BITMSK
	TYA             ;GET 8 BIT BLOCK
	LSR A
	LSR A
	LSR A
	TAX
	LDA TAB,X
	BIT BITMSK      ;SET EQUAL FLAG
	RTS
.SKIP 3
.END
; -------------------------------------------------------------
; ##### ESCAPE #####
.PAG 'ESCAPE - 05/02/83'
;************************************************************
;*
;*  ROUTINES INVOLVED IN EXECUTING ESCAPE FUNCTIONS
;*
;************************************************************
.SKI 2
;MAIN ESCAPE SEQUENCE HANDLER
;  ENTRY: CHARACTER FOLLOWING ESCAPE CHARACTER IN ACC.
ESCAPE
     AND #$7F
     SEC
     SBC #'A  ;TABLE BEGINS AT ASCII A
     CMP #$1A   ;'Z'-'A'+1
     BCC ESCGO ;VALID CHAR, GO GET ADDRESS
ESCRTS	RTS             ;FAILED TO FIND ENTRY...IGNORE IT!
.SKIP
ESCGO	;GET ADDRESS OF ESCAPE ROUTINE, AND GO TO IT.
     ASL A ;MULTIPLY INDEX BY 2
     TAX
     LDA ESCVCT+1,X  ;GET HIGH BYTE
     PHA
     LDA ESCVCT,X  ;AND LOW
     PHA
     RTS  ;AND GO TO THAT ADDRESS
.SKI 3
ESCVCT
  .WORD AUTON-1  ;A AUTO INSERT
  .WORD SETHTB-1 ;B SET BOTTOM
  .WORD AUTOFF-1 ;C CANCEL AUTO INSERT
  .WORD DLINE-1  ;D DELETE LINE
  .WORD SETCR4-1 ;E SELECT NON-FLASHING CURSOR
  .WORD SETCR2-1 ;F FLASHING CURSOR
  .WORD BELLON-1 ;G ENABLE BELL
  .WORD BELLOF-1 ;H DISABLE BELL
  .WORD ILINE-1  ;I INSERT LINE
  .WORD FNDFST-1 ;J MOVE TO START OF LINE
  .WORD FNDEND-1 ;K MOVE TO END OF LINE
  .WORD SCRSW0-1 ;L ENABLE SCROLLING
  .WORD SCRSW1-1 ;M DISABLE SCROLLING
  .WORD NRMSCR-1 ;N NORMAL SCREEN (NOT REVERSE)
  .WORD TOQM-1   ;O CANCEL INSERT,QUOTE, AND REVERSE
  .WORD ETOSOL-1 ;P ERASE TO START OF LINE
  .WORD ETOEOL-1 ;Q ERASE TO END OF LINE
  .WORD REVSCR-1 ;R REVERSE SCREEN
  .WORD SETCR3-1 ;S SOLID CURSOR (NOT UNDERSCORE)
  .WORD SETHTT-1 ;T SET TOP OF PAGE
  .WORD SETCR1-1 ;U UNDERSCORE CURSOR
  .WORD SUUP-1   ;V SCROLL UP
  .WORD SDDN-1   ;W SCROLL DOWN
  .WORD ESCRTS-1 ;X CANCEL ESCAPE SEQUENCE
  .WORD NRMSET-1 ;Y NORMAL CHARACTER SET
  .WORD ALTSET-1 ;Z ALTERNATE CHARACTER SET
.SKIP
;SET TOP OR BOTTOM
SETHTT
    CLC
    .BYTE $24
SETHTB
    SEC
WINDOW	LDX PNTR
     LDA TBLX
     BCC SETTOP
SETBOT
     STA SCBOT
     STX SCRT
     RTS
SRESET
     LDA #SCYMAX ;MAX # OF ROWS
     LDX #SCXMAX ;MAX # OF COLUMNS
     JSR SETBOT
     LDA #0
     TAX
SETTOP
     STA SCTOP
     STX SCLF
     RTS
.SKI
; TURN BELL ON OR OFF
BELLON
     LDA #0
BELLOF
     STA BELLMD
     RTS
.SKIP 3
;ALTER SCREEN OR CURSOR
SETCR1	;UNDERSCORE CURSOR
	LDA #$0B
	BIT TPI2+PC     ;CHECK MACHINE TYPE
	BMI SETUNS      ;BUIT-IN DISPLAY
	LDA #$06        ;ON OTHERS START CURSOR ON LINE 6
     .BYTE $2C
SETCR2	;FLASHING CURSOR
     LDA #$60
SETUNS
     ORA CONFIG
     BNE SETCR5 ;ALWAYS
SETCR3	;FULL CURSOR
     LDA #$F0
     .BYTE $2C
SETCR4	;STEADY CURSOR
     LDA #$0F
     AND CONFIG
SETCR5	STA CONFIG
     RTS ;WAIT UNTILL CURSOR ON TO UPDATE
.SKIP
REVSCR	;REVERSE SCREEN IMAGE
     LDA #$20
     .BYTE $2C
ALTSET	;ALTERNATE CHARACTER SET
     LDA #$10
     LDX #14
     STX VDC+ADREG
     ORA VDC+DAREG
     BNE SETSCR ;ALWAYS
NRMSCR	;NON-REVERSE SCREEN
     LDA #$DF
     .BYTE $2C
NRMSET	;NORMAL CHARACTER SET
     LDA #$EF
     LDX #14
     STX VDC+ADREG
     AND VDC+DAREG
SETSCR
     STA VDC+DAREG
     AND #$30 ;USE ONLY BITS 4 & 5 FOR STARTING ADDRESS HIGH
     LDX #12
CH6845
     STX VDC+ADREG
     STA VDC+DAREG
     RTS
.SKIP 3
;AUTO INSERT ON/OFF
AUTOFF
     LDA #0
     .BYTE $2C
AUTON
     LDA #$FF
     STA INSFLG
     RTS
.SKI
.END
; -------------------------------------------------------------
; ##### BWTABS #####
.PAG 'TABLES 05/31/83'
NORMTB
;
;     KEYBOARD TABLE - NO CONTROL/NO SHIFT
;
;LINE 0: F1, ESCAPE, TAB, NULL, SHIFT, CONTROL
 .BYTE $E0,$1B,$09,$FF,$00,$01
;LINE 1: F2, 1, Q, A, Z, NULL
 .BYTE $E1,$31,$51,$41,$5A,$FF
;LINE 2: F3, 2, W, S, X, C
 .BYTE $E2,$32,$57,$53,$58,$43
;LINE 3: F4, 3, E, D, F, V
 .BYTE $E3,$33,$45,$44,$46,$56
;LINE 4: F5, 4, R, T, G, B
 .BYTE $E4,$34,$52,$54,$47,$42
;LINE 5: F6, 5, 6, Y, H, N
 .BYTE $E5,$35,$36,$59,$48,$4E
;LINE 6: F7, 7, U, J, M, SPACE
 .BYTE $E6,$37,$55,$4A,$4D,$20
;LINE 7: F8, 8, I, K, "," , .
 .BYTE $E7,$38,$49,$4B,$2C,$2E
;LINE 8: F9, 9, O, L, ;, /
 .BYTE $E8,$39,$4F,$4C,$3B,$2F
;LINE 9: F10, 0, -, P, [, '
 .BYTE $E9,$30,$2D,$50,$5B,$27
;LINE 10: DOWN CURSOR, =, _, ], RETURN, PI
 .BYTE $11,$3D,$5F,$5D,$0D,$DE
;LINE 11: UP CUR, LT CUR, RT CUR, DEL, CMDR, NULL
 .BYTE $91,$9D,$1D,$14,$02,$FF
;LINE 12: HOME, ?, 7, 4, 1, 0
 .BYTE $13,$3F,$37,$34,$31,$30
;LINE 13: RVS ON, CANCEL, 8, 5, 2, DECIMAL POINT
 .BYTE $12,$04,$38,$35,$32,$2E
;LINE 14: GRAPHIC, MULT, 9, 6, 3, 00
 .BYTE $8E,$2A,$39,$36,$33,$30
;LINE 15: STOP, DIV, SUBTR, ADD, ENTER, NULL
 .BYTE $03,$2F,$2D,$2B,$0D,$FF
.SKI 4
SHFTTB
;
;     KEYBOARD TABLE - SHIFT ONLY & TEXT MODE
;
;LINE 0: F11, SHT ESC, TAB TOGGLE, NULL, SHIFT, CTL
 .BYTE $EA,$1B,$89,$FF,$00,$01
;LINE 1: F12, !, Q, A, Z, NULL
 .BYTE $EB,$21,$D1,$C1,$DA,$FF
;LINE 2: F13, @, W, S, X, C
 .BYTE $EC,$40,$D7,$D3,$D8,$C3
;LINE 3: F14, #, E, D, F, V
 .BYTE $ED,$23,$C5,$C4,$C6,$D6
;LINE 4: F15, $, R, T, G, B
 .BYTE $EE,$24,$D2,$D4,$C7,$C2
;LINE 5: F16, %, ^, Y, H, N
 .BYTE $EF,$25,$5E,$D9,$C8,$CE
;LINE 6: F17, &, U, J, M, SHIFTED SPACE
 .BYTE $F0,$26,$D5,$CA,$CD,$A0
;LINE 7: F18, *, I, K, <, >
 .BYTE $F1,$2A,$C9,$CB,$3C,$3E
;LINE 8: F19, (, O, L, :, ?
 .BYTE $F2,$28,$CF,$CC,$3A,$3F
;LINE 9: F20, ), -, P, [, "
 .BYTE $F3,$29,$2D,$D0,$5B,$22
;LINE 10: DOWN CURSOR, +, POUND SIGN, ], SHT RETURN, PI
 .BYTE $11,$2B,$5C,$5D,$8D,$DE
;LINE 11: UP CURSOR,LEFT CURSOR,RIGHT CURSOR, INS, CMDR, NULL
 .BYTE $91,$9D,$1D,$94,$82,$FF
;LINE 12: CLEAR/HOME, ?, 7, 4, 1, 0
 .BYTE $93,$3F,$37,$34,$31,$30
;LINE 13: RVS OFF, SHFT CANCEL, 8, 5, 2, DECIMAL POINT
 .BYTE $92,$84,$38,$35,$32,$2E
;LINE 14: TEXT, MULT, 9, 6, 3, 00
 .BYTE $0E,$2A,$39,$36,$33,$30
;LINE 15: RUN, DIV, SUBTR, ADD, ENTER, NULL
 .BYTE $83,$2F,$2D,$2B,$8D,$FF
.SKI 4
SHFTGR
;
;     KEYBOARD TABLE - SHIFT ONLY & GRAPHIC MODE
;
;LINE 0: F11, SHT ESC, TAB TOGGLE, NULL, SHIFT, CTL
 .BYTE $EA,$1B,$89,$FF,$00,$01
;LINE 1: F12, !, GR, GR, GR, NULL
 .BYTE $EB,$21,$D1,$C1,$DA,$FF
;LINE 2: F13, @, GR, GR, GR, GR
 .BYTE $EC,$40,$D7,$D3,$D8,$C0
;LINE 3: F14, #, GR, GR, GR, GR
 .BYTE $ED,$23,$C5,$C4,$C6,$C3
;LINE 4: F15, $, GR, GR, GR, GR
 .BYTE $EE,$24,$D2,$D4,$C7,$C2
;LINE 5: F16, %, ^, GR, GR, GR
 .BYTE $EF,$25,$5E,$D9,$C8,$DD
;LINE 6: F17, &, GR, GR, GR, SHIFTED SPACE
 .BYTE $F0,$26,$D5,$CA,$CD,$A0
;LINE 7: F18, *, GR, GR, <, >
 .BYTE $F1,$2A,$C9,$CB,$3C,$3E
;LINE 8: F19, (, GR, GR, :, ?
 .BYTE $F2,$28,$CF,$D6,$3A,$3F
;LINE 9: F20, ), -, GR, [, "
 .BYTE $F3,$29,$2D,$D0,$5B,$22
;LINE 10: DOWN CURSOR, +, POUND, ], SHIFTED RETURN, PI
 .BYTE $11,$2B,$5C,$5D,$8D,$DE
;LINE 11: UP CURSOR,LEFT CURSOR,RIGHT CURSOR, INS, CMDR, NULL
 .BYTE $91,$9D,$1A,$94,$82,$FF
;LINE 12: CLEAR/HOME, ?, 7, 4, 1, 0
 .BYTE $93,$3F,$37,$34,$31,$30
;LINE 13: RVS OFF, SHIFT CANCEL, 8, 5, 2, DP
 .BYTE $92,$04,$38,$35,$32,$2E
;LINE 14: TEXT, MULT, 9, 6, 3, 00
 .BYTE $0E,$2A,$39,$36,$33,$30
;LINE 15: RUN, DIV, SUBTR, ADD, ENTER, NULL
 .BYTE $83,$2F,$2D,$2B,$8D,$FF
.SKI 4
CTLTBL
;KEYBOARD TABLE... CONTROL CHARACTERS, ANY MODE
;LINE 0: NULL,NULL,NULL,NULL,NULL
 .BYTE $FF,$FF,$FF,$FF,$FF,$FF
;LINE 1: NULL,GR,Q,A,Z,NULL
 .BYTE $FF,$A1,$11,$01,$1A,$FF
;LINE 2: NULL,GR,W,S,X,C
 .BYTE $FF,$A2,$17,$13,$18,$03
;LINE 3: NULL,GR,E,D,F,V
 .BYTE $FF,$A3,$05,$04,$06,$16
;LINE 4: NULL,GR,R,T,G,B
 .BYTE $FF,$A4,$12,$14,$07,$02
;LINE 5: NULL,GR,GR,Y,H,N
 .BYTE $FF,$A5,$A7,$19,$08,$0E
;LINE 6: NULL,GR,U,J,M,NULL
 .BYTE $FF,$BE,$15,$0A,$0D,$FF
;LINE 7: NULL,GR,I,K,GR,NULL
 .BYTE $FF,$BB,$09,$0B,$CE,$FF
;LINE 8: NULL,GR,O,L,GR,NULL
 .BYTE $FF,$BF,$0F,$0C,$DC,$FF
;LINE 9: NULL,GR,GR,P,GR,GR
 .BYTE $FF,$AC,$BC,$10,$CC,$A8
;LINE 10: NULL,GR,GR,GR,NULL,GR
 .BYTE $FF,$A9,$DF,$BA,$FF,$A6
;LINE 11: NULL,NULL,NULL,NULL,NULL,NULL
 .BYTE $FF,$FF,$FF,$FF,$FF,$FF
;LINE 12: NULL,GR,GR,GR,GR,GR
 .BYTE $FF,$B7,$B4,$B1,$B0,$AD
;LINE 13: NULL,GR,GR,GR,GR,GR
 .BYTE $FF,$B8,$B5,$B2,$AE,$BD
;LINE 14: NULL,GR,GR,GR,GR,NULL
 .BYTE $FF,$B9,$B6,$B3,$DB,$FF
;LINE 15: NULL,GR,GR,GR,NULL,NULL
 .BYTE $FF,$AF,$AA,$AB,$FF,$FF
.SKI 3
RUNTB	.BYT 'D',$CC,'*',$D,'RUN',$D	; vor * noch "
.SKIP 3
;****** ADDRESS OF SCREEN LINES ******
;
LINZ0	= SCNRAM
LINZ1	= LINZ0+LLEN
LINZ2	= LINZ1+LLEN
LINZ3	= LINZ2+LLEN
LINZ4	= LINZ3+LLEN
LINZ5	= LINZ4+LLEN
LINZ6	= LINZ5+LLEN
LINZ7	= LINZ6+LLEN
LINZ8	= LINZ7+LLEN
LINZ9	= LINZ8+LLEN
LINZ10	= LINZ9+LLEN
LINZ11	= LINZ10+LLEN
LINZ12	= LINZ11+LLEN
LINZ13	= LINZ12+LLEN
LINZ14	= LINZ13+LLEN
LINZ15	= LINZ14+LLEN
LINZ16	= LINZ15+LLEN
LINZ17	= LINZ16+LLEN
LINZ18	= LINZ17+LLEN
LINZ19	= LINZ18+LLEN
LINZ20	= LINZ19+LLEN
LINZ21	= LINZ20+LLEN
LINZ22	= LINZ21+LLEN
LINZ23	= LINZ22+LLEN
LINZ24	= LINZ23+LLEN
.SKI 3
;****** SCREEN LINES LO BYTE TABLE ******
;
LDTB2
	.BYT <LINZ0
	.BYT <LINZ1
	.BYT <LINZ2
	.BYT <LINZ3
	.BYT <LINZ4
	.BYT <LINZ5
	.BYT <LINZ6
	.BYT <LINZ7
	.BYT <LINZ8
	.BYT <LINZ9
	.BYT <LINZ10
	.BYT <LINZ11
	.BYT <LINZ12
	.BYT <LINZ13
	.BYT <LINZ14
	.BYT <LINZ15
	.BYT <LINZ16
	.BYT <LINZ17
	.BYT <LINZ18
	.BYT <LINZ19
	.BYT <LINZ20
	.BYT <LINZ21
	.BYT <LINZ22
	.BYT <LINZ23
	.BYT <LINZ24
.SKI 3
;****** SCREEN LINES HI BYTE TABLE ******
;
LDTB1
	.BYT >LINZ0
	.BYT >LINZ1
	.BYT >LINZ2
	.BYT >LINZ3
	.BYT >LINZ4
	.BYT >LINZ5
	.BYT >LINZ6
	.BYT >LINZ7
	.BYT >LINZ8
	.BYT >LINZ9
	.BYT >LINZ10
	.BYT >LINZ11
	.BYT >LINZ12
	.BYT >LINZ13
	.BYT >LINZ14
	.BYT >LINZ15
	.BYT >LINZ16
	.BYT >LINZ17
	.BYT >LINZ18
	.BYT >LINZ19
	.BYT >LINZ20
	.BYT >LINZ21
	.BYT >LINZ22
	.BYT >LINZ23
	.BYT >LINZ24
.SKIP 3
; DISPATCH TABLE
;
CTABLE
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD STPRUN-1  ;STOP/RUN
	.WORD CE-1      ;CANCEL
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD BELL-1    ;BELL/-
	.WORD CUSER-1
	.WORD TABIT-1   ;TAB/TAB TOGGLE
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD NXT1-1    ;RETURN OR SHIFTED RETURN
	.WORD CTEXT-1   ;TEXT/GRAPHIC MODE
	.WORD WINDOW-1  ;SET TOP/BOTTOM
	.WORD CUSER-1
	.WORD CDNUP-1   ;CURSOR DOWN/UP
	.WORD RVSF-1    ;RVS ON/OFF
	.WORD HOMCLR-1  ;HOME/CLR
	.WORD DELINS-1  ;DELETE/INSERT CHARACTER
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CUSER-1
	.WORD CRTLF-1   ;CURSOR RIGHT/LEFT
	.WORD CUSER-1
	.WORD CUSER-1
.SKIP 3
KEYLEN	.BYTE KEY2-KEY1
	.BYTE KEY3-KEY2
	.BYTE KEY4-KEY3
	.BYTE KEY5-KEY4
	.BYTE KEY6-KEY5
	.BYTE KEY7-KEY6
	.BYTE KEY8-KEY7
	.BYTE KEY9-KEY8
	.BYTE KEY10-KEY9
	.BYTE KEYEND-KEY10
KEYDEF
KEY1	.BYTE 'PRINT'
KEY2	.BYTE 'LIST'
KEY3	.BYTE 'DLOAD"'
KEY4	.BYTE 'DSAVE"'
KEY5	.BYTE 'DOPEN'
KEY6	.BYTE 'DCLOSE'
KEY7	.BYTE 'COPY'
KEY8	.BYTE 'DIRECTORY'
KEY9	.BYTE 'SCRATCH'
KEY10	.BYTE 'CHR$('
KEYEND
.SKI 3
;  BITS  -  BIT POSITION TABLE
;
BITS
	.BYTE $80,$40,$20,$10,$08,$04,$02,$01
.PAG
; ****** 6845 CRTC TEXT MODE ******
.SKI 2
ATEXT	.BYT $6C,$50,83,$0F ;PHILLPS, HITACHI BUIT-IN MONITOR
	.BYT $19,$03,$19,$19
	.BYT $00,$0D,CURSOR,$0D
	.BYT ROMIMG,$00,ROMIMG,$00,$00,$00
NTEXT	.BYT 126,80,98,10,31,6,25,28,0,7,0,7 ;NTSC MONITORS
	.BYT ROMIMG,$00,ROMIMG,$00,$00,$00
PTEXT	.BYT 127,80,96,10,38,1,25,30,0,7,0,7 ;PAL MONITORS
	.BYT ROMIMG,$00,ROMIMG,$00,$00,$00
ETEXT
.SKI 2
;**************************************************
.SKI 3
CKSUME	.BYT $FF        ;E-PAGE CHECKSUM
;**************************************************
; PATCH1 - CHECKS FOR A SINGLE LINE WINDOW
;          ABORTS IF SO...
;**************************************************
;
PATCH1	LDX SCBOT       ;CHECK
	CPX SCTOP
	BNE PATCHA      ;NO...PASS THROUGH OLD CODE
	PLA             ;ABORT
	PLA
PATCHA	BIT SCRDIS      ;RESTORE PATCHED AREA (TEST FOR SCROLLING MODE)
	RTS
.END
.END
