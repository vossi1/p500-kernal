
; ******** Source: p500kernal.b
     1                          ; Commodore P500 Kernal 901234-02 with Fastboot Patches from Steve Gray
     2                          ; disassembled with DA65 18.4.2020 (Info-file from Ulrich Bassewitz)
     3                          ; modified for ACME assembling by Vossi 05/2020, last update 05/2024
     4                          ; v1.1 special f-keys
     5                          ; v1.2 full ramtest selection (fast test checks only byte $0002 in each page)
     6                          ; v1.3 all patches selectable
     7                          ; v1.4 new F-keys for petsd+
     8                          ; v1.5 superfast video if always in indirect bank 15
     9                          ; v1.6 add txjmp routine from b-series rev -03 kernal (diagtest detects too much RAM - only vice!)
    10                          ; v1.7 moved tx-routines in the correct place = 100% identical to cbm2 04a kernal
    11                          ; v1.8 basic SYS patched - now to selected bank -> Basic $8063 csys vector =  $EDDC-1: $DB, $ED
    12                          ; v1.9 movchar single line screen, slow scroll preserve flags patches rev -03 kernal
    13                          ; v2.0 added complete rev -03 new patched key functions in the editor
    14                          ; v2.1 optional solid Atari Style cursor ;)
    15                          ; v2.2 optional IEEE rev -03 patch with ren
    16                          ; v2.3 dclose patch from b-series rev -03 kernal
    17                          ; v2.4 patch rev. -03 reserves two top pages for swapping system
    18                          ; v2.5 finished all comments, labels, patches
    19                          ; v2.6 correct cbm checksum $e0
    20                          ; v2.7 reset sid
    21                          ; v2.8 patch rev. 04a clear insert flag, rs232
    22                          ; v2.9 SRAM patch - checks warm flags reliable to allow usage of any SRAM chip type
    23                          ; v3.0 Checksum byte constant
    24                          !cpu 6502
    25                          !ct pet		; Standard text/char conversion table -> pet = petscii
    26                          !to "kernal.bin", plain
    27                          ; * switches
    28                          ;STANDARD_FKEYS	= 1	; Standard F-keys
    29                          ;FULL_RAMTEST	= 1	; Standard full and slow RAM-test
    30                          ;STANDARD_VIDEO	= 1	; Standard doublechecked video writes (original kernal unfinished)
    31                          CBMPATCH	= 1	; CBM B-series patches -03/-04, Vossi $3BF patches
    32                          CBMPATCH4A	= 1	; CBM B-series patches -04a
    33                          IEEEPATCH	= 1	; CBM-B-series ieee-patches -03 (with ren)
    34                          BANK15_VIDEO	= 1	; Superfast Video with standard vram in bank15
    35                          			;   with vram in bank 0 the kernal doesnt write the color in bank 15!
    36                          SYSPATCH	= 1	; patched Basic SYS command to start code in all banks
    37                          			;   for a return is the txjump kernal part in the ram bank necessary! 
    38                          			;   the patched basic lo with the new sys-vector is also necessary 
    39                          SRAMPATCH	= 1	; checks warm flags reliable to allow usage of any SRAM chip type
    40                          ; the checksum must be adjusted for each individual configuration!
    41                          ; * constants
    42                          FILL		= $AA	; Fills free memory areas with $AA
    43                          TEXTCOL		= $06	; Default text color:   $06 = blue
    44                          BGRCOL		= $01	; background color      $01 = white
    45                          EXTCOL		= $03	; exterior color        $03 = cyan
    46                          CHECKSUM	= $28	; ROM checksum byte (original $00)
    47                          ; ########################################### INFO ################################################
    48                          ; ROM-CHECKSUM-BYTE: cksume
    49                          ; loop3 E129 = Main loop - wait for key input
    50                          ; **************************************** DISCLAIMER *********************************************
    51                          ;***************************************
    52                          ;*                                     *
    53                          ;* KK  K EEEEE RRRR  NN  N  AAA  LL    *
    54                          ;* KK KK EE    RR  R NNN N AA  A LL    *
    55                          ;* KKK   EE    RR  R NNN N AA  A LL    *
    56                          ;* KKK   EEEE  RRRR  NNNNN AAAAA LL    *
    57                          ;* KK K  EE    RR  R NN NN AA  A LL    *
    58                          ;* KK KK EE    RR  R NN NN AA  A LL    *
    59                          ;* KK KK EEEEE RR  R NN NN AA  A LLLLL *
    60                          ;*                                     *
    61                          ;***************************************
    62                          ;***************************************
    63                          ;* CBM KERNAL                          *
    64                          ;*   MEMORY AND I/O DEPENDENT ROUTINES *
    65                          ;* DRIVING THE HARDWARE OF THE         *
    66                          ;* FOLLOWING CBM MODEL :               *
    67                          ;*   P-SERIES (5XX)                    *
    68                          ;* COPYRIGHT (C) 1983 BY               *
    69                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
    70                          ;***************************************
    71                          ;
    72                          ; 6509  used to extend memory on bc2 & p2 systems
    73                          ;   location - used to direct
    74                          ;   $0000 -  execution register (4 bits)
    75                          ;   $0001 -  indirect  register (4 bits)
    76                          ;
    77                          ;   these registers provide 4 extra high-order address control lines.  
    78                          ;     on 6509 reset all lines are high.
    79                          ;
    80                          ; current memory map:
    81                          ;   segment 15- $ffff-$e000  rom (kernal)
    82                          ;               $dfff-$df00  i/o  6525 tpi2
    83                          ;               $deff-$de00  i/o  6525 tpi1
    84                          ;               $ddff-$dd00  i/o  6551 acia
    85                          ;               $dcff-$dc00  i/o  6526 cia
    86                          ;               $dbff-$db00  i/o  unused (z80,8088,68008)
    87                          ;               $daff-$da00  i/o  6581 sid
    88                          ;               $d9ff-$d900  i/o  unused (disks)
    89                          ;               $d8ff-$d800  i/o  6569 vic
    90                          ;               $d7ff-$d400  color nybles
    91                          ;               $d3ff-$d000  video matrix
    92                          ;               $cfff-$c000  character dot rom
    93                          ;               $bfff-$8000  roms external (language)
    94                          ;               $7fff-$4000  roms external (extensions)
    95                          ;               $3fff-$2000  rom  external
    96                          ;               $1fff-$1000  rom  internal
    97                          ;               $0fff-$0400  unused
    98                          ;               $03ff-$0002  ram (kernal/basic system)
    99                          ;   segment 14- segment 4 open (future expansion)
   100                          ;   segment 3 - $ffff-$0002  ram p2 optinal
   101                          ;   segment 2 - $ffff-$0002  ram p2 optinal
   102                          ;   segment 1 - $ffff-$0002  ram p2 standard
   103                          ;   segment 0 - $ffff-$0002  ram p2 standard
   104                          ;
   105                          ; the 6509 registers appear in locations $0000 and $0001 in all segments of memory.
   106                          ; ***************************************** ZEROPAGE **********************************************
   107                          	e6509		= $00		; 6509 execution bank reg
   108                          	i6509		= $01		; 6509 indirect bank reg
   109                          ;
   110                          ; $02-$8f BASIC zeropage 
   111                          ;
   112                          ; Kernal page zero variables
   113                          ; Kernal indirect address variables
   114                          	fnadr		= $90		; Address of file name string
   115                          	sal		= $93		; Current load/store address
   116                          	sah		= $94		;   low, high, bank
   117                          	sas		= $95
   118                          	eal		= $96		; End of load/save
   119                          	eah		= $97
   120                          	eas		= $98
   121                          	stal		= $99		; Start of load/save
   122                          	stah		= $9A
   123                          	stas		= $9B
   124                          	; Frequently used kernal variables
   125                          	status		= $9C		; I/O operation status
   126                          	fnlen		= $9D		; File name length
   127                          	la		= $9E		; Current logical index
   128                          	fa		= $9F		; Current first address
   129                          	sa		= $A0		; Current secondary address
   130                          	dfltn		= $A1		; Default input device
   131                          	dflto		= $A2		; Default output device
   132                          ; Tape buffer pointer
   133                          	tape1		= $A3		; Address of tape buffer
   134                          ; RS-232 input buffer
   135                          	ribuf		= $A6		; Input buffer
   136                          ; Variables for kernal speed
   137                          	stkey		= $A9		; Stop key flag
   138                          	ctemp		= $A9		; used to reduce cassette read times 
   139                          	c3po		= $AA		; IEEE buffer flag
   140                          	snsw1		= $AA		; used to reduce cassette read times 
   141                          	bsour		= $AB		; IEEE character buffer 
   142                          ; Cassette temps - overlays IPC buffer
   143                          	ipoint		= $AC		; next 2 bytes used for transx code
   144                          	syno		= $AC
   145                          	dpsw		= $AD
   146                          ; next 18 bytes also used for monitor
   147                          	ptr1		= $AE		; index to pass1 errors
   148                          	ptr2		= $AF		; index to pass2 errors
   149                          	pcntr		= $B0
   150                          	firt		= $B1
   151                          	cntdn		= $B2
   152                          	shcnl		= $B3
   153                          	rer		= $B4
   154                          	rez		= $B5
   155                          	rdflg		= $B6
   156                          	flagt1		= $B7		; temp during bit read time
   157                          	shcnh		= $B7
   158                          	cmp0		= $B8
   159                          	diff		= $B9
   160                          	prp		= $BA
   161                          	ochar		= $BB
   162                          	prty		= $BC
   163                          	fsblk		= $BD
   164                          	mych		= $BE
   165                          	cdata		= $BF		; how to turn cassette timers on
   166                          ; Monitor virtual registers - Place in these locations temporarly...
   167                          	pch		= $AE		; counter
   168                          	pcl		= $AF
   169                          	flgs		= $B0		; Processor status
   170                          	acc		= $B1		; Accumulator
   171                          	xr		= $B2		; X register
   172                          	yr		= $B3		; Y register
   173                          	sp		= $B4		; Stack pointer
   174                          	xi6509		= $B5		; Old indirection segment
   175                          	re6509		= $B6		; Return execution segment
   176                          	invh		= $B7		; User interrupt vector
   177                          	invl		= $B8
   178                          ; Monitor indirect variables
   179                          	tmp0		= $B9		; Temp pointer
   180                          	tmp2		= $BB		; Temp pointer
   181                          ; Other monitor variables
   182                          	tmpc		= $BD		; Place to save last cmd
   183                          	t6509		= $BE		; Temporary i6509
   184                          	ddisk		= $BF		; Default disk unit # for monitor
   185                          ; Screen editor page zero variables
   186                          ; Editor indirect variables
   187                          	pkybuf		= $C0		; Start adr of pgm key
   188                          	keypnt		= $C2		; Current pgm key buf
   189                          	sedsal		= $C4		; Scroll ptr
   190                          	sedeal		= $C6		; Scroll ptr
   191                          	pnt		= $C8		; Current character pointer
   192                          ; Editor variables for speed & size
   193                          	tblx		= $CA		; Cursor line
   194                          	pntr		= $CB		; Cursor column
   195                          	grmode		= $CC		; Graphic/text mode flag $00=graphic, $02=text
   196                          	lstx		= $CD		; Last character index
   197                          	lstp		= $CE		; Screen editor start position
   198                          	lsxp		= $CF		; Screen editor start row
   199                          	crsw		= $D0		; cr flag - cr pressed -> input from screen
   200                          	ndx		= $D1		; Index to keyd queue
   201                          	qtsw		= $D2		; Quote mode flag
   202                          	insrt		= $D3		; Insert mode flag
   203                          	config		= $D4		; Char before blink (petii)
   204                          	indx		= $D5		; last byte position on line (##234-02##244-02)
   205                          	kyndx		= $D6		; count of program key string
   206                          	rptcnt		= $D7		; Deelay tween chars
   207                          	delay		= $D8		; Delay to next repeat
   208                          	sedt1		= $D9		; Frequently used temp variables
   209                          	sedt2		= $DA
   210                          ; Frequently used editor variables
   211                          	data		= $DB		; Current print data
   212                          	sctop		= $DC		; Top screen 0-24 of current window
   213                          	scbot		= $DD		; Bottom 0-24
   214                          	sclf		= $DE		; Left margin
   215                          	scrt		= $DF		; Right margin
   216                          	modkey		= $E0		; Keyscanner shift/control flags ($ff-nokey)
   217                          	norkey		= $E1		; Keyscanner normal key number ($ff-nokey)
   218                          ; Screen editor usage
   219                          	bitabl		= $E2		; Wrap bitmap
   220                          	blnon		= $E6		; Blinking cursor on = $00
   221                          	blncnt		= $E7		; Blink counter
   222                          	user		= $E8		; Pointer to color RAM
   223                          	tcolor		= $EA		; Temporary color
   224                          	blnsw		= $EB		; Blink switch
   225                          	color		= $EC		; Character color
   226                          	gdcol		= $ED		; Color behind cursor
   227                          	saver		= $EE		; Temp store for output char
   228                          	scrseg		= $EF		; Segment /bank of video RAM
   229                          ; Free zero page space, 16 bytes
   230                          	zpend		= $F0
   231                          ; ***************************************** ABSOLUTE **********************************************
   232                          ; System stack area
   233                          	stack		= $0100		; Stack
   234                          	bad		= $0100		; Cassette bad address table
   235                          	stackp		= $01FF		; System Stack pointer transx code
   236                          ; -------------------------------------------------------------------------------------------------
   237                          ; $200 - $256 Basic's ROM page work area
   238                          	buf		= $0200		; Basic input buffer
   239                          ; Basic RAM vectors
   240                          	ierror		= $0280         ; Basic error indirect
   241                          ; -------------------------------------------------------------------------------------------------
   242                          ; System RAM vectors
   243                          	cinv		= $0300		; IRQ vector
   244                          	cbinv		= $0302		; BRK vector
   245                          	nminv		= $0304		; NMI vector
   246                          	iopen		= $0306		; Open file vector
   247                          	iclose		= $0308		; Close file vector
   248                          	ichkin		= $030A		; Open channel in vector
   249                          	ickout		= $030C		; Open channel out vector
   250                          	iclrch		= $030E		; Close channel vector
   251                          	ibasin		= $0310		; Input from channel vector 
   252                          	ibsout		= $0312		; Output to channel vector
   253                          	istop		= $0314		; Check stop key vector
   254                          	igetin		= $0316		; Get from queue vector
   255                          	iclall		= $0318		; Close all files vector
   256                          	iload		= $031A		; Load from file vector
   257                          	isave		= $031C		; Save to file vector
   258                          	usrcmd		= $031E		; Monitor extension vector
   259                          	escvec		= $0320		; User ESC key vector
   260                          	ctlvec		= $0322		; unused control key vector
   261                          	isecnd		= $0324		; IEEE listen secondary address
   262                          	itksa		= $0326		; IEEE talk secondary address
   263                          	iacptr		= $0328		; IEEE character in routine
   264                          	iciout		= $032A		; IEEE character out routine
   265                          	iuntlk		= $032C		; IEEE bus untalk
   266                          	iunlsn		= $032E		; IEEE bus unlisten
   267                          	ilistn		= $0330		; IEEE listen device primary address
   268                          	italk		= $0332		; IEEE talk device primary address
   269                          ; Kernal absolute variables
   270                          	lat		= $0334		; Logical file numbers / table
   271                          	fat		= $033E		; Device numbers / table
   272                          	sat		= $0348		; Secondary addresses / table
   273                          ;
   274                          	lowadr		= $0352		; Start of system memory: low, high, bank
   275                          	hiadr		= $0355		; Top of system memory: low, high, bank
   276                          	memstr		= $0358		; Start of user memory: low, high, bank
   277                          	memsiz		= $035B		; Top of user memory: low, high, bank
   278                          	timout		= $035E		; IEEE timeout enable
   279                          	verck		= $035F		; load/verify flag
   280                          	ldtnd		= $0360		; Device table index
   281                          	msgflg		= $0361		; Message flag
   282                          	bufpt		= $0362		; Cassette buffer index
   283                          ; Kernal temporary (local) variables
   284                          	t1		= $0363
   285                          	t2		= $0364 
   286                          	xsav		= $0365 
   287                          	savx		= $0366 
   288                          	svxt		= $0367 
   289                          	temp		= $0368 
   290                          	alarm		= $0369		; IRQ variable holds 6526 IRQ's
   291                          ; Kernal cassette variables
   292                          	itape		= $036A		; Indirect for cassette code
   293                          	cassvo		= $036C		; Cassette read variable
   294                          	aservo		= $036D		; Flag1***indicates t1 timeout cassette read
   295                          	caston		= $036E		; How to turn on timers
   296                          	relsal		= $036F		; moveable start load address
   297                          	relsah		= $0370		; 
   298                          	relsas		= $0371		; 
   299                          	oldinv		= $0372		; restore user IRQ and i6509 after cassettes
   300                          	cas1		= $0375		; Cassette switch flag
   301                          ; RS-232 information storage
   302                          	m51ctr		= $0376		; 6551 control image
   303                          	m51cdr		= $0377		; 6551 command image
   304                          	rsstat		= $037A		; perm. RS-232 status
   305                          	dcdsr		= $037B		; last DCD/DSR value
   306                          	ridbs		= $037C		; Input start index
   307                          	ridbe		= $037D		; Input end index
   308                          ; Screen editor absolute
   309                          ; $037E - $037F Block some area for editor
   310                          	pkyend		= $0380		; Program key buffer end address
   311                          	keyseg		= $0382		; Segment / bank of function key texts
   312                          	rvs		= $0383		; Reverse mode flag
   313                          	lintmp		= $0384		; Line # between in and out 
   314                          	lstchr		= $0385		; Last char printed
   315                          	insflg		= $0386		; Insert mode flag
   316                          	scrdis		= $0387		; Scroll disable flag
   317                          	bitmsk		= $0388		; Temorary bitmask
   318                          	fktmp		= $0388		;   also used for function key temporary
   319                          	keyidx		= $0389		; Index to programmables
   320                          	logscr		= $038A		; Logical/physical scroll flag
   321                          	bellmd		= $038B		; Bell on/off flag
   322                          	pagsav		= $038C		; Temp RAM page
   323                          	keysiz		= $038D		; Sizes of function key texts
   324                          	tab		= $03A1		; Tabstop flags
   325                          	keyd		= $03AB		; Keyboard buffer
   326                          	funvec		= $03B5		; Vector: funktion key handler
   327                          	iwrtvrm		= $03B7		; Vector: video ram write routine
   328                          	iwrtcrm		= $03B9		; Vector: color ram write routine
   329                          	iunkwn1		= $03BB		; Vector: -> E039 nofunc
   330                          	iunkwn2		= $03BD		; Vector: -> E039 nofunc
   331                          	unknwn		= $03BF		; unknown from old editor (some flag like quote or insert?)
   332                          ; $03C0 - $3F7 Free absolute space
   333                          	absend		= $03C0
   334                          ; System warm start variables and vectors
   335                          	evect		= $03F8		; Warm start vector and flags 5 bytes
   336                          ; -------------------------------------------------------------------------------------------------
   337                          ; Free bank 15 RAM 1024 bytes
   338                          	ramloc          = $0400		; First free ram location
   339                          ; -------------------------------------------------------------------------------------------------
   340                          ; Kernal inter-process communication variables 
   341                          	ipbsiz		= 16            ; Ipc buffer size
   342                          	ipb		= $0800		; IPC buffer
   343                          	ipjtab		= ipb+ipbsiz	; IPC jump table
   344                          	ipptab		= $0910		; IPC param spec table
   345                          ; Ipc buffer offsets
   346                          	ipccmd		= 0		; Ipc command
   347                          	ipcjmp		= 1		; Ipc jump address
   348                          	ipcin		= 3		; Ipc #input bytes
   349                          	ipcout		= 4		; Ipc #output bytes
   350                          	ipcdat		= 5		; Ipc data buffer (8 bytes max)
   351                          ; *************************************** IO / EQUATES ********************************************
   352                          ; Equates
   353                          	irom	= $F		; System bank
   354                          	id55hz	= 14		; 55hz value required by ioinit
   355                          	warm	= $A5		; Warm start flag
   356                          	winit	= $5A  		; Initialization complete flag
   357                          	llen	= 40            ; Screen length
   358                          	nrows	= 25            ; Screen length
   359                          	scxmax	= llen-1        ; Max column number
   360                          	scymax	= nrows-1       ; Max line number
   361                          	keymax	= 9             ; Keyboard buffer size - 1
   362                          	dblzer	= 89            ; Key code for double zero
   363                          	pgmkys	= 20            ; Number of progam keys
   364                          ; Tape block types
   365                          	eot	= 5             ; End of tape
   366                          	blf	= 1             ; Basic load file
   367                          	bdf	= 2             ; Basic data file
   368                          	bdfh	= 4             ; Basic data file header
   369                          	bufsz	= 192           ; Buffer size
   370                          	cr	= $d            ; Carriage return
   371                          ; ROM / RAM addresses
   372                          	basic	= $8000		; Start of ROM (language)
   373                          	chrrom	= $C000		; Character ROM
   374                          	scnram	= $D000		; Video RAM
   375                          	clrram	= $D400		; Color RAM nibbles
   376                          	kernal	= $E000		; Start of ROM (kernal)
   377                          ; 6569 VIC Video interface device
   378                          	vic	= $D800		; VIC
   379                          	memptr	= $18		; VIC memory pointers register
   380                          ; 6581 SID Sound interface device
   381                          	sid	= $DA00
   382                          	osc1	= $00		; base addresses osc1, osc2, osc3
   383                          	osc2	= $07
   384                          	osc3	= $0E
   385                          	freqlo	= $00		; osc registers
   386                          	freqhi	= $01
   387                          	pulsef	= $02
   388                          	pulsec	= $03
   389                          	oscctl	= $04
   390                          	atkdcy	= $05
   391                          	susrel	= $06
   392                          	fclow	= $15		; filter control
   393                          	fchi	= $16
   394                          	resnce	= $17
   395                          	volume	= $18
   396                          	potx	= $19		; pots, random number and env3 out
   397                          	poty	= $1A
   398                          	random	= $1B
   399                          	env3	= $1C
   400                          ; 6526 CIA for inter-process communication
   401                          	ipcia	= $DB00
   402                          	; pra  = data port
   403                          	; prb0 = busy1 (1=>6509 off dbus)
   404                          	; prb1 = busy2 (1=>8088/z80 off dbus)
   405                          	; prb2 = semaphore 8088/z80
   406                          	; prb3 = semaphore 6509
   407                          	; prb4 = unused
   408                          	; prb5 = unused
   409                          	; prb6 = irq to 8088/z80 (lo)
   410                          	; prb7 = unused
   411                          	sem88	= $04	; prb bit2
   412                          	sem65	= $08	; prb bit3
   413                          ; 6526 CIA Complex interface adapter - game / IEEE data / user
   414                          	; timer a: ieee local / cass local / music / game
   415                          	; timer b: ieee deadm / cass deadm / music / game
   416                          	;
   417                          	; pra0: ieee data1 / user / paddle game 1
   418                          	; pra1: ieee data2 / user / paddle game 2
   419                          	; pra2: ieee data3 / user
   420                          	; pra3: ieee data4 / user
   421                          	; pra4: ieee data5 / user
   422                          	; pra5: ieee data6 / user
   423                          	; pra6: ieee data7 / user / game trigger 14
   424                          	; pra7: ieee data8 / user / game trigger 24
   425                          	;
   426                          	; prb0: user / game 10
   427                          	; prb1: user / game 11
   428                          	; prb2: user / game 12
   429                          	; prb3: user / game 13
   430                          	; prb4: user / game 20
   431                          	; prb5: user / game 21
   432                          	; prb6: user / game 22
   433                          	; prb7: user / game 23
   434                          	;
   435                          	; flag: user / cassette read
   436                          	cia	= $DC00
   437                          	pra	= $0	; Data reg A
   438                          	prb	= $1	; Data reg B
   439                          	ddra	= $2	; Direction reg a
   440                          	ddrb	= $3	; Direction reg b
   441                          	talo	= $4	; Timer A low  byte
   442                          	tahi	= $5	; Timer A high byte
   443                          	tblo	= $6	; Timer B low  byte
   444                          	tbhi	= $7	; Timer B high byte
   445                          	tod10	= $8	; 10ths of seconds
   446                          	todsec	= $9	; Seconds
   447                          	todmin	= $A	; Minutes
   448                          	todhr	= $B	; Hours
   449                          	sdr	= $C	; Serial data register
   450                          	icr	= $D	; Interrupt control register
   451                          	cra	= $E	; Control register A
   452                          	crb	= $F	; Control register B
   453                          ; 6551 ACIA RS-232 and network interface
   454                          	acia	= $DD00
   455                          	drsn	= $0	; Transmitt/receive data register
   456                          	srsn	= $1	; Status register
   457                          	cdr	= $2	; Command register
   458                          	ctr	= $3	; Control register
   459                          	; Equates
   460                          	dsrerr	= $40	; Data set ready error
   461                          	dcderr	= $20	; Data carrier detect error
   462                          	doverr	= $08	; Receiver outer buffer overrun
   463                          ; 6525 TPI1 Triport interface device #1 - IEEE control / cassette / network / vic / irq
   464                          	tpi1	= $DE00
   465                          	; pa0: ieee dc control (ti parts)
   466                          	; pa1: ieee te control (ti parts) (t/r)
   467                          	; pa2: ieee ren
   468                          	; pa3: ieee atn
   469                          	; pa4: ieee dav
   470                          	; pa5: ieee eoi
   471                          	; pa6: ieee ndac
   472                          	; pa7: ieee nrfd
   473                          	;
   474                          	; pb0: ieee ifc
   475                          	; pb1: ieee srq
   476                          	; pb2: network transmitter enable
   477                          	; pb3: network receiver enable
   478                          	; pb4: arbitration logic switch
   479                          	; pb5: cassette write
   480                          	; pb6: cassette motor
   481                          	; pb7: cassette switch
   482                          	;
   483                          	; irq0: 50/60 hz irq
   484                          	; irq1: ieee srq
   485                          	; irq2: 6526 irq
   486                          	; irq3: (opt) 6526 inter-processor
   487                          	; irq4: 6551
   488                          	; *irq: 6569 (vic) / user devices
   489                          	; cb:   vic dot select - cr #7-6 11=bank 15, 01=bank 0
   490                          	; ca:   vic matrix select - cr #5-4 11=bank 15, 01=bank 0
   491                          	pa	= $0	; Port register A
   492                          	pb	= $1	; Port register B
   493                          	pc	= $2	; Port register C
   494                          	lir	= $2	; Interrupt latch register mc=1
   495                          	ddpa	= $3	; Data direction register A
   496                          	ddpb	= $4	; Data direction register B
   497                          	ddpc	= $5	; Data direction register C
   498                          	mir	= $5	; Interrupt mask register mc=1
   499                          	creg	= $6	; Control reg: #0 mc=IRQ mode / #1 ip= IRQ parity / #2-3 edge i3,i4	
   500                          	air	= $7	; Active interrupt register
   501                          	; Equates
   502                          	dc	= $01	; 75160/75161 control line
   503                          	te	= $02	; 75160/75161 control line
   504                          !ifdef IEEEPATCH{
   505                          	ren	= $04	; Remote enable
   506                          } else{
   507                          	ren	= 0	; Remote enable
   508                          }
   509                          	atn	= $08	; Attention
   510                          	dav	= $10	; Data available
   511                          	eoi	= $20	; End or identify
   512                          	ndac	= $40	; Not data accepted
   513                          	nrfd	= $80	; Not ready for data
   514                          	ifc	= $01	; Interface clear
   515                          	srq	= $02	; Service request
   516                          	
   517                          	rddb	= nrfd+ndac+te+dc+ren	;directions for receiver
   518                          	tddb	= eoi+dav+atn+te+dc+ren	;directions for transmitt
   519                          	
   520                          	eoist	= $40	; eoi status test
   521                          	tlkr	= $40	; device is talker
   522                          	lstnr	= $20	; device is listener
   523                          	utlkr	= $5f	; device untalk
   524                          	ulstn	= $3f	; device unlisten
   525                          	       
   526                          	toout	= $01	; timeout status on output
   527                          	toin	= $02	; timeout status on input
   528                          	eoist	= $40	; eoi on input
   529                          	nodev	= $80	; no device on bus.
   530                          	sperr	= $10	; verify error
   531                          	; Equates for c3p0 flag bits 6 and 7.
   532                          	slock	= $40	; screen editor lock-out
   533                          	dibf	= $80	; data in output buffer
   534                          ; 6525 TPI2 Triport interface device #2
   535                          	tpi2	= $DF00
   536                          	; pa: kyrd out 8-15
   537                          	; pb: kybd out 0-7
   538                          	;
   539                          	; pc0: kybd in 0
   540                          	; pc1: kybd in 1
   541                          	; pc2: kybd in 2
   542                          	; pc3: kybd in 3
   543                          	; pc4: kybd in 4
   544                          	; pc5: kybd in 5
   545                          	; pc6: vic 16k bank select low
   546                          	; pc7: vic 16k bank select hi
   547                          ; **************************************** COLD START *********************************************
   548                          !initmem FILL                   ; All unused memory filled with $AA
   549                          !zone cold
   550                          *= kernal
   551  e000 4c09ee             jmoncld:jmp monoff		; Monitor cold start
   552  e003 ea                 	nop
   553                          ; ****************************************** EDITOR ***********************************************
   554                          ;***************************************
   555                          ;*                                     *
   556                          ;* EEEEE DDD   IIIII TTTTT  OOO  RRRR  *
   557                          ;* E     D  D    I     T   O   O R   R *
   558                          ;* E     D   D   I     T   O   O R   R *
   559                          ;* EEE   D   D   I     T   O   O RRRR  *
   560                          ;* E     D   D   I     T   O   O R R   *
   561                          ;* E     D  D    I     T   O   O R  R  *
   562                          ;* EEEE  DDD   IIIII   T    OOO  R   R *
   563                          ;*                                     *
   564                          ;***************************************
   565                          ;***************************************
   566                          ;*   CBM EDITOR FOR P-SERIES SYSTEMS   *
   567                          ;*   KEYBOARD AND SCREEN EDIT ROUTINES *
   568                          ;* DRIVING THE HARDWARE OF THE         *
   569                          ;* FOLLOWING CBM MODELS:               *
   570                          ;*   P-SERIES                          *
   571                          ;* COPYRIGHT (C) 1983 BY               *
   572                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
   573                          ;***************************************
   574                          !zone editor
   575                          *= kernal+4
   576                          ;****************************************
   577                          ;
   578                          ;  40 column pet ii screen editor
   579                          ;    with unlimited screen line wrap
   580                          ;
   581                          ;****************************************
   582                          ; E004 Jump vector table
   583  e004 4c44e0             jcint:  jmp cint		; Init Screen editor, VIC, F-keys
   584  e007 4cf4e0             jlp2:	jmp lp2			; Read a key from keyboard to A
   585  e00a 4c74e1             jloop5:	jmp loop5		; Read character from screen to A
   586  e00d 4c84e2             jprt:	jmp prt			; Print character from A on screen
   587  e010 4c3fe0             jscror:	jmp scrorg		; Return screen dimensions to X, Y
   588  e013 4c0ce9             jkey:	jmp scnkey		; Keyboard scan
   589  e016 4c36e0             jmvcur: jmp nofunc		; not used in P500 - only for CRTC hardware cursor in b-series
   590  e019 4c25e0             jplot:  jmp plot		; Get/set the cursor position to/from X, Y
   591  e01c 4c3ae0             jiobas:	jmp iobase		; Return CIA base address to X, Y
   592  e01f 4c3cea             jescrt:	jmp escape		; Handle an escape sequence
   593  e022 4ca1e7             jfunky:	jmp keyfun		; Get/set/list function keys
   594                          ; -------------------------------------------------------------------------------------------------
   595                          ; E025 Get/set the cursor position
   596  e025 b00b               plot:   bcs rdplt		; if C=1 get cursor position
   597                          ; set cursor
   598  e027 86ca               	stx tblx		; store line, last line 
   599  e029 86cf               	stx lsxp
   600  e02b 84cb               	sty pntr		; store column, last column
   601  e02d 84ce               	sty lstp
   602                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
   603  e02f 20dfe0             	jsr stupt		; Change pointer to this new line
   604  e032 a6ca               rdplt:  ldx tblx
   605  e034 a4cb               	ldy pntr		; load column, row
   606  e036 60                 nofunc: rts
   607                          } else{
   608                          	jsr sreset		; set full screen window
   609                          	jsr stupt		; Change pointer to this new line
   610                          ; get cursor pos
   611                          rdplt:  ldx tblx		; load row, column
   612                          	ldy pntr
   613                          nofunc: rts
   614                          }
   615                          *= $E03A
   616                          ; -------------------------------------------------------------------------------------------------
   617                          ; E03A Return CIA base address
   618  e03a a200               iobase: ldx #<cia
   619  e03c a0dc               	ldy #>cia
   620  e03e 60                 	rts
   621                          ; -------------------------------------------------------------------------------------------------
   622                          ; E03F Return screen dimensions
   623  e03f a228               scrorg: ldx #llen		; 40 columns
   624  e041 a019               	ldy #nrows		; 25 rows
   625  e043 60                 	rts
   626                          ; -------------------------------------------------------------------------------------------------
   627                          ; $E044 Screen editor init (editor, F-Keys, VIC)
   628                          ; Clear editor variables
   629  e044 a900               cint:   lda #0
   630  e046 a22d               	ldx #zpend-keypnt-1	; $C2-$EF
   631  e048 95c2               cloop1: sta keypnt,x		; clear page 0 variables
   632  e04a ca                 	dex
   633  e04b 10fb               	bpl cloop1
   634                          
   635  e04d a23c               	ldx #absend-rvs-1	; $38D-$3C9
   636  e04f 9d8d03             cloop2: sta keysiz,x		; clear absolute variables
   637  e052 ca                 	dex
   638  e053 10fa               	bpl cloop2
   639                          ; init some variables
   640  e055 a90f               	lda #irom
   641  e057 85ef               	sta scrseg		; store bank with video RAM = system bank
   642  e059 a90c               	lda #$C
   643  e05b 85e7               	sta blncnt		; init blink counter
   644  e05d 85e6               	sta blnon
   645                          ; init F-keys
   646  e05f a5c0               	lda pkybuf		; check if buffers are allocated
   647  e061 05c1               	ora pkybuf+1
   648  e063 d022               	bne keycpy		; yes..just copy f-keys (erased with absolute vars)
   649  e065 ad5503             	lda hiadr		; get end of key area
   650  e068 8d8003             	sta pkyend
   651  e06b ad5603             	lda hiadr+1
   652  e06e 8d8103             	sta pkyend+1
   653  e071 a940               	lda #$40		; NO SENSE - will be overwritten in alocat                
   654  e073 a200               	ldx #0	
   655  e075 a002               	ldy #2
   656  e077 2081ff             	jsr aloca		; get 512 bytes at end of system memory $FEFF
   657  e07a b026               	bcs noroom		; no room found...just reset the screen
   658  e07c 8d8203             	sta keyseg		; store bank for F-keys
   659  e07f e8                 	inx
   660  e080 86c0               	stx pkybuf		; save start address (returned X+1)
   661  e082 d001               	bne room10
   662  e084 c8                 	iny
   663  e085 84c1               room10: sty pkybuf+1		; save start address
   664  e087 a039               keycpy: ldy #keyend-keydef	; load size of F-key texts
   665  e089 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   666  e08c b9b5ec             kyset1: lda keydef-1,y
   667  e08f 88                 	dey
   668  e090 91c0               	sta (pkybuf),y		; copy key texts to buffer
   669  e092 d0f8               	bne kyset1
   670                          
   671  e094 207ce2             	jsr pagres		; restore ram page (indirect segment)
   672  e097 a00a               	ldy #keydef-keylen	; 10 F-key length bytes
   673  e099 b9abec             kyset2: lda keylen-1,y
   674  e09c 998c03             	sta keysiz-1,y		; copy F-key text length to $38D
   675  e09f 88                 	dey
   676  e0a0 d0f7               	bne kyset2
   677                          ; init VIC, screen
   678  e0a2 2093ea             noroom: jsr sreset		; set full screen window
   679  e0a5 a211               	ldx #$11		; init vic regs $21-$11
   680  e0a7 a021               	ldy #$21
   681  e0a9 bdf6ec             vicint:	lda tvic-1,x
   682  e0ac 2012e6             	jsr wrtvic		; write A to VIC register Y
   683  e0af 88                 	dey
   684  e0b0 ca                 	dex
   685  e0b1 d0f6               	bne vicint
   686  e0b3 2053e2             	jsr txcrt		; set text mode/char rom
   687                          
   688  e0b6 a20a               	ldx #$0A
   689  e0b8 bd07ed             edvecl: lda edvect-1,x		; copy extended editor vector table to $3B5
   690  e0bb 9db403             	sta funvec-1,x
   691  e0be ca                 	dex
   692  e0bf d0f7               	bne edvecl
   693                          
   694  e0c1 a906               	lda #TEXTCOL
   695  e0c3 85ec               	sta color		; init color
   696                          ; E0C8 Clear screen, cursor home
   697  e0c5 20d3e0             clsr:	jsr nxtd		; Start at top of window
   698  e0c8 20e1e0             cls10:	jsr scrset		; set screen pointers
   699  e0cb 2024e2             	jsr clrln		; clear the line
   700  e0ce e4dd               	cpx scbot		; done ?
   701  e0d0 e8                 	inx
   702  e0d1 90f5               	bcc cls10		; no
   703                          ; E0D3 Cursor home
   704  e0d3 a6dc               nxtd:   ldx sctop		; move to top
   705  e0d5 86ca               	stx tblx
   706  e0d7 86cf               	stx lsxp		; for input after home or clear
   707  e0d9 a4de               stu10:  ldy sclf		; left of the screen window
   708  e0db 84cb               	sty pntr
   709  e0dd 84ce               	sty lstp
   710                          ; E0DF Reset screen ptr to line begin
   711  e0df a6ca               stupt:	ldx tblx		; get curent line index
   712                          ; E0F1 Set screen ptr to line X 
   713  e0e1 bd3aec             scrset: lda ldtb2,x		; load start of screen line low
   714  e0e4 85c8               	sta pnt			; and store to screen, color RAM ptr
   715  e0e6 85e8               	sta user
   716  e0e8 bd53ec             	lda ldtb1,x		; load high
   717  e0eb 85c9               	sta pnt+1		; and store to char pointer
   718  e0ed 2903               	and #$03
   719  e0ef 09d4               	ora #>clrram		; calc color RAM high and store to color RAM ptr
   720  e0f1 85e9               	sta user+1
   721  e0f3 60                 	rts
   722                          ; -------------------------------------------------------------------------------------------------
   723                          ; *** Input routines ***
   724                          ; E0F4 Remove character from queue
   725  e0f4 a6d6               lp2:  	ldx kyndx		; are there any pgm keys
   726  e0f6 f012               	beq lp3			; branch if not
   727  e0f8 ac8903             	ldy keyidx		; get index to current char
   728  e0fb 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   729  e0fe b1c2               	lda (keypnt),y		; get current byt
   730  e100 207ce2             	jsr pagres		; restore ram page (indirect segment)
   731  e103 c6d6               	dec kyndx		; 1 byte down
   732  e105 ee8903             	inc keyidx		; bump index to next char
   733  e108 58                 	cli
   734  e109 60                 	rts
   735                          ; No F-key
   736  e10a acab03             lp3: 	ldy keyd		; get key from irq buffer
   737  e10d a200               	ldx #0
   738  e10f bdac03             lp1:  	lda keyd+1,x		; shift key buffer
   739  e112 9dab03             	sta keyd,x
   740  e115 e8                 	inx
   741  e116 e4d1               	cpx ndx			; shift till last key in buffer
   742  e118 d0f5               	bne lp1
   743  e11a c6d1               	dec ndx			; decrease key index
   744  e11c 98                 	tya			; return char in A
   745  e11d 58                 	cli
   746  e11e 60                 	rts
   747                          ; -------------------------------------------------------------------------------------------------
   748                          ; E11F Screen input - Main loop
   749  e11f 2084e2             loop4:	jsr prt			; print the character
   750                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
   751  e122 4c28e1             	jmp loop3
   752                          } else{
   753                          	asl unknwn
   754                          	lsr unknwn		; clear bit#7 in $03BF
   755                          }
   756                          *= $E128
   757                          ; wait for key input
   758  e128 a5d1               loop3:  lda ndx			; check key and pgm-key index
   759  e12a 05d6               	ora kyndx
   760  e12c 85e6               	sta blnon
   761  e12e f0f8               	beq loop3		; loop - wait for key input
   762                          ; key available
   763  e130 78                 	sei			; disable interrupts
   764  e131 a5eb               	lda blnsw
   765  e133 f00b               	beq lp21		; skip if cursor blink already switched off
   766  e135 a5d4               	lda config		; load char before blink
   767  e137 a000               	ldy #$00
   768  e139 84eb               	sty blnsw		; switch off cursor blink
   769  e13b a6ed               	ldx gdcol		; load color behind cursor
   770  e13d 200fe2             	jsr dspcol		; write char before blink
   771                          ; check key
   772  e140 20f4e0             lp21:	jsr lp2			; get key input
   773  e143 c90d               	cmp #$D
   774  e145 d0d8               	bne loop4		; print char if not cr
   775                          ; return recognized
   776  e147 85d0               	sta crsw		; set cr flag - we pass chars now
   777  e149 20f7e4             	jsr fndend		; check nxt line for cont (double line?)
   778  e14c 8e8403             	stx lintmp		; save last line number of sentence
   779                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
   780  e14f 202fed             	jsr patch4a2		; ***** patch4a-2 - make space for clear insert flag *****
   781  e152 85d3               	sta insrt		; ***** patch4a-2 - clear insert flag *****
   782                          } else{
   783                          	jsr fistrt		; find begining of line
   784                          	lda #0
   785                          }
   786  e154 85d2               	sta qtsw		; clear quote mode
   787  e156 a4de               	ldy sclf		; retrieve from line start if left it
   788  e158 a5cf               	lda lsxp		; input started row
   789  e15a 3013               	bmi lp80		; flag we left start line
   790  e15c c5ca               	cmp tblx
   791  e15e 900f               	bcc lp80
   792  e160 a4ce               	ldy lstp		; input started column
   793  e162 cd8403             	cmp lintmp		; on start line
   794  e165 d004               	bne lp70
   795  e167 c4d5               	cpy indx		; past start column
   796  e169 f002               	beq lp75		; ok if the same
   797  e16b b011               lp70:	bcs clp2		; yes - null input
   798  e16d 85ca               lp75:	sta tblx		; start from here on input
   799  e16f 84cb               lp80:	sty pntr
   800  e171 4c86e1             	jmp lop5		; input a line
   801                          ; -------------------------------------------------------------------------------------------------
   802                          ; E174 Read character from screen
   803  e174 98                 loop5:	tya
   804  e175 48                 	pha
   805  e176 8a                 	txa
   806  e177 48                 	pha
   807  e178 a5d0               	lda crsw		; passing chars to input
   808  e17a f0ac               	beq loop3		; no - buffer on screen
   809  e17c 1008               	bpl lop5		; not done - get next char
   810  e17e a900               clp2:	lda #0			; input done clear flag
   811  e180 85d0               	sta crsw
   812  e182 a90d               	lda #$D			; pass a return
   813  e184 d039               	bne clp7
   814  e186 20dfe0             lop5:	jsr stupt		; set pnt and user
   815  e189 203fe2             	jsr get1ch		; get a screen char
   816                          ; convert screencode to petscii
   817  e18c 85db               	sta data		; store screen code for bit#5,6,7 check temporary
   818  e18e 293f               	and #$3F		; clear bit#6,7 in A
   819  e190 06db               	asl data		; check: scrcode bit#7->C
   820  e192 24db               	bit data		; check: scrcode bit#6->N, #5->V (shiftet to left)
   821  e194 1002               	bpl lop54		; skip if scrcode #6=0 x0x -> 00x
   822  e196 0980               	ora #$80		; x1x -> 10x
   823  e198 9004               lop54:	bcc lop52		; skip if scrcode #7=0 (not reverse)
   824  e19a a6d2               	ldx qtsw
   825  e19c d004               	bne lop53		; skip if bit#7=1 & quote on: 10x -> 00x, 11x -> 10x
   826                          				; if quote off or bit#7=0:
   827  e19e 7002               lop52:	bvs lop53		; skip if scrcode #5=1: 001 -> 001, 011 -> 101
   828  e1a0 0940               	ora #$40		; 000 -> 010, 100 -> 110
   829  e1a2 20c8e1             lop53:	jsr qtswc
   830  e1a5 a4ca               	ldy tblx		; on input end line ?
   831  e1a7 cc8403             	cpy lintmp
   832  e1aa 900a               	bcc clp00		; no
   833  e1ac a4cb               	ldy pntr		; on input end column ?
   834  e1ae c4d5               	cpy indx
   835  e1b0 9004               	bcc clp00		; no
   836  e1b2 66d0               	ror crsw		; c=1 minus flags last char sent
   837  e1b4 3003               	bmi clp1		; always
   838                          
   839  e1b6 2021e5             clp00:	jsr nxtchr		; at next char
   840  e1b9 c9de               clp1:	cmp #$DE		; a pi ?
   841  e1bb d002               	bne clp7		; no
   842  e1bd a9ff               	lda #$FF		; translate
   843  e1bf 85db               clp7:	sta data
   844  e1c1 68                 	pla
   845  e1c2 aa                 	tax
   846  e1c3 68                 	pla
   847  e1c4 a8                 	tay
   848  e1c5 a5db               	lda data		; return petscii char in A
   849  e1c7 60                 	rts
   850                          ; -------------------------------------------------------------------------------------------------
   851                          ; *** Test for quote mode ***
   852                          ; E1C8 Switch quote mode depending on in A
   853  e1c8 c922               qtswc:	cmp #$22 ; "
   854  e1ca d008               	bne qtswl		; skip if no quote-char
   855  e1cc a5d2               	lda qtsw
   856  e1ce 4901               	eor #$1			; toggle quoteswitch
   857  e1d0 85d2               	sta qtsw
   858  e1d2 a922               	lda #$22 ; "		; restore quote in A
   859  e1d4 60                 qtswl:	rts
   860                          ; -------------------------------------------------------------------------------------------------
   861                          ; E1D5 *** Output chars ***
   862  e1d5 2c8303             nxt3:	bit rvs
   863  e1d8 1002               	bpl nvs
   864  e1da 0980               	ora #$80
   865  e1dc a6d3               nvs:	ldx insrt
   866  e1de f002               	beq nvsa
   867  e1e0 c6d3               	dec insrt
   868  e1e2 2c8603             nvsa:	bit insflg		; are we in auto insert mode?
   869  e1e5 1009               	bpl nvs1		; branch if not
   870  e1e7 48                 	pha			; save the char
   871  e1e8 2091e5             	jsr insert		; make room for this char
   872  e1eb a200               	ldx #0
   873  e1ed 86d3               	stx insrt		; make sure we turn off insert mode.
   874  e1ef 68                 	pla			; restore char
   875  e1f0 2009e2             nvs1:	jsr dsppcc		; display the character
   876  e1f3 20dbe5             	jsr movchr		; move to next char pos
   877                          ; -------------------------------------------------------------------------------------------------
   878                          ; E1F6 ********* exit from prt *********
   879  e1f6 a5db               loop2:	lda data		; copy last char
   880  e1f8 8d8503             	sta lstchr
   881  e1fb 68                 	pla
   882  e1fc a8                 	tay
   883  e1fd a5d3               	lda insrt
   884  e1ff f002               	beq lop2
   885  e201 46d2               	lsr qtsw		; clear quote switch if in insert mode
   886  e203 68                 lop2:	pla
   887  e204 aa                 	tax
   888  e205 68                 	pla
   889  e206 60                 	rts
   890                          ; -------------------------------------------------------------------------------------------------
   891                          ;********************************
   892                          ; Display a character
   893                          ;********************************
   894                          ; E207 Write blank ($20) at cusor position
   895  e207 a920               doblnk: lda #' '		; load blank
   896                          ; E209 Write char A with color or tcolor if color bit#7=1
   897  e209 a6ec               dsppcc: ldx color		; load char color
   898  e20b 1002               	bpl dspcol
   899                          ; E20D Write char A with tcolor
   900  e20d a6ea               dsptco: ldx tcolor
   901                          ; E20f Write char A with color X and set blink counter
   902  e20f a002               dspcol: ldy #$02
   903  e211 84e7               	sty blncnt		; blink cusor
   904                          ; E213 Write char A with color X
   905  e213 a4cb               dspp:   ldy pntr		; get char index
   906  e215 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
   907  e218 206fe6             	jsr jwrvrm		; write char to screen
   908  e21b 48                 	pha
   909  e21c 8a                 	txa			; move color to A
   910  e21d 2072e6             	jsr jwrcrm		; write color to color RAM
   911  e220 68                 	pla
   912  e221 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
   913                          ; -------------------------------------------------------------------------------------------------
   914                          ; E224 Subroutine to clear one line
   915                          ;   x = line number
   916                          ;   clrln :  blank entire line
   917                          ;   clrprt:  y = starting column position
   918  e224 a4de               clrln:	ldy sclf		; load left margin
   919  e226 20b6e4             	jsr clrbit		; make sure non-continued line
   920  e229 8a                 clrprt:	txa
   921  e22a 48                 	pha			; save X
   922  e22b a5cb               	lda pntr
   923  e22d 48                 	pha			; remember column
   924  e22e 88                 	dey
   925  e22f c8                 clr10:	iny
   926  e230 84cb               	sty pntr
   927  e232 2007e2             	jsr doblnk		; print a blank
   928  e235 c4df               	cpy scrt		; line completely blank?
   929  e237 d0f6               	bne clr10		; branch if not
   930                          
   931  e239 68                 	pla
   932  e23a 85cb               	sta pntr
   933  e23c 68                 	pla
   934  e23d aa                 	tax
   935  e23e 60                 	rts
   936                          ; -------------------------------------------------------------------------------------------------
   937                          ; E23F Grab a character from screen
   938  e23f a4cb               get1ch: ldy pntr		; get char/color index
   939                          ; E241 Get char from column Y
   940  e241 206ee2             getych: jsr pagscr		; switch to screen memory page (indirect segment)
   941  e244 b1c8               	lda (pnt),y		; get the character
   942  e246 48                 	pha
   943  e247 a900               	lda #$00
   944  e249 11e8               	ora (user),y		; get color (ORA = always systembank)
   945  e24b 85ea               	sta tcolor		; and store it to tcolor
   946  e24d 68                 	pla
   947  e24e 4c7ce2             	jmp pagres      	; restore ram page (indirect segment)
   948                          ; -------------------------------------------------------------------------------------------------
   949                          ; E251 Set text/graphic mode (C=1 graphic)
   950  e251 b004               ctext:	bcs grcrt		; skip if graphic mode
   951  e253 a002               txcrt:	ldy #$02		; set Bit#1 for text character set   
   952  e255 d002               	bne crtset
   953  e257 a000               grcrt:	ldy #$00		; clear Bit#1 for graphic char set
   954  e259 84cc               crtset: sty grmode		; store new mode
   955  e25b ad18d8             	lda vic+memptr		; load vic memory pointers register
   956  e25e 29fd               	and #$FD
   957  e260 05cc               	ora grmode		; clear bit #1 and set to desired mode (char-ROM base-adr bit#11)
   958  e262 a018               	ldy #memptr
   959  e264 4c12e6             	jmp wrtvic		; write VIC memory pointers reg
   960                          ; -------------------------------------------------------------------------------------------------
   961                          ;**************************************************
   962                          ;   Handle ram paging (indirect segment)
   963                          ;**************************************************
   964                          ; E267 Switch to segment with key buffer
   965  e267 48                 pagkey: pha
   966  e268 ad8203             	lda keyseg              ; for function key page (segment)
   967  e26b 4c71e2             	jmp pagsub
   968                          ; E26E Switch to segment with video screen
   969  e26e 48                 pagscr: pha
   970  e26f a5ef               	lda scrseg              ; for screen memory page (segment)
   971  e271 48                 pagsub: pha
   972  e272 a501               	lda i6509		; get current page (segment) number
   973  e274 8d8c03             	sta pagsav              ; - and save it
   974  e277 68                 	pla
   975  e278 8501               	sta i6509               ; switch to new indirect segment
   976  e27a 68                 	pla                     ; restore a-reg
   977  e27b 60                 	rts
   978                          ; -------------------------------------------------------------------------------------------------
   979                          ; E27C Restore indirect segment
   980  e27c 48                 pagres: pha			; save a-reg
   981  e27d ad8c03             	lda pagsav		; get saved ram page (segment) number
   982  e280 8501               	sta i6509               ; restore ram page number
   983  e282 68                 	pla			; restore a-reg
   984  e283 60                 	rts
   985                          ; -------------------------------------------------------------------------------------------------
   986                          ; E284 *** Print a char ***
   987  e284 48                 prt:	pha
   988  e285 c9ff               	cmp #$FF
   989  e287 d002               	bne prt10
   990  e289 a9de               	lda #$DE		; convert pi character
   991  e28b 85db               prt10:	sta data		; save char
   992  e28d 8a                 	txa			; save regs
   993  e28e 48                 	pha
   994  e28f 98                 	tya
   995  e290 48                 	pha
   996  e291 a900               	lda #0			; clear cr flag
   997  e293 85d0               	sta crsw
   998  e295 a4cb               	ldy pntr		; column we are in
   999  e297 a5db               	lda data
  1000  e299 297f               	and #$7F
  1001  e29b c920               	cmp #$20		; test if control character (< $20)
  1002  e29d 9041               	bcc ntcn		; yes
  1003                          !ifndef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1004                          	ldx qtsw		; test if in quote mode...
  1005                          	beq njt1		; if not, skip
  1006                          	ldx unknwn		; ?
  1007                          	beq njt2
  1008                          	jsr junkwn1		; vector -> nofunc (rts)
  1009                          	lda data
  1010                          	jmp njt2
  1011                          njt1:	ldx insrt		; test if in insert mode
  1012                          	bne njt2		; if not, skip
  1013                          	bit unknwn		; ?
  1014                          	bpl njt2
  1015                          	jsr junkwn1		; vector -> nofunc (rts)
  1016                          	lda data
  1017                          	cmp #$22
  1018                          	beq njt10
  1019                          	jmp loop2
  1020                          }
  1021  e29f ae8503             njt2:	ldx lstchr		; was last char an esc
  1022  e2a2 e01b               	cpx #$1B
  1023  e2a4 d006               	bne njt10		; no
  1024  e2a6 20dee6             	jsr sequen		; yes - do esc sequence
  1025  e2a9 4cf6e1             	jmp loop2
  1026  e2ac 293f               njt10:	and #$3F		; no - make a screen char
  1027  e2ae 24db               njt20:	bit data
  1028  e2b0 1002               	bpl njt30		; skip ahead if normal set - 00 - 3f
  1029  e2b2 0940               	ora #$40		; convert a0 - bf to 60 - 7f & c0 - df to 40 - 5f
  1030  e2b4 20c8e1             njt30:	jsr qtswc		; test for quote
  1031  e2b7 4cd5e1             	jmp nxt3		; put on screen
  1032                          *= $E2E0
  1033                          ; E2E0 ********* Control keys *********
  1034  e2e0 c90d               ntcn:	cmp #$0D		; test if a return
  1035  e2e2 f029               	beq ntcn20		; no inverse if yes
  1036                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1037  e2e4 c914               	cmp #$14		; test if insert or delete
  1038  e2e6 f025               	beq ntcn20		; allow in insert or quote mode
  1039  e2e8 c91b               	cmp #$1b		; test if escape key
  1040  e2ea d011               	bne ntcn1
  1041  e2ec 24db               	bit data
  1042  e2ee 300d               	bmi ntcn1		; its a $9b
  1043  e2f0 a5d2               	lda qtsw		; test if in quote mode...
  1044  e2f2 05d3               	ora insrt		; ...or insert mode
  1045  e2f4 f017               	beq ntcn20		; if not, go execute remaining code
  1046  e2f6 2072e7             	jsr toqm		; else go turn off all modes
  1047  e2f9 85db               	sta data		; and forget about this character
  1048  e2fb f010               	beq ntcn20		; always
  1049  e2fd c903               ntcn1	cmp #$03		; test if a run/load or stop
  1050                          } else{
  1051                          	cmp #$1B		; test if escape key
  1052                          	bne ntcn1
  1053                          	bit data
  1054                          	bmi ntcn1		; its a $9b
  1055                          	lda qtsw		; test if in quote mode...
  1056                          	ora insrt		; ...or insert mode
  1057                          	beq ntcn20		; if not, go execute remaining code
  1058                          	jsr toqm		; else go turn off all modes
  1059                          	sta data		; and forget about this character
  1060                          	beq ntcn20		; always
  1061                          ntcn1:	cmp #$03		; test if a run/load or stop
  1062                          	beq ntcn20
  1063                          	cmp #$14		; test if insert or delete
  1064                          }
  1065  e2ff f00c               	beq ntcn20		; no inverse if yes
  1066  e301 a4d3               	ldy insrt		; test if in insert mode
  1067  e303 d004               	bne ntcn10		; go reverse - if yes
  1068  e305 a4d2               	ldy qtsw		; check for quote mode
  1069  e307 f004               	beq ntcn20		; do not reverse if not
  1070  e309 0980               ntcn10:	ora #$80		; make reverse
  1071  e30b d0a1               	bne njt20
  1072  e30d a5db               ntcn20:	lda data
  1073  e30f 0a                 	asl			; set carry if shifted ctrl
  1074  e310 aa                 	tax
  1075  e311 2017e3             	jsr ctdsp		; indirect jsr
  1076  e314 4cf6e1             	jmp loop2
  1077                          *= $E317
  1078                          ; E317 Control code dispatcher
  1079  e317 bd6dec             ctdsp:	lda ctable+1,x		; hi byte
  1080  e31a 48                 	pha
  1081  e31b bd6cec             	lda ctable,x		; low byte
  1082  e31e 48                 	pha
  1083  e31f a5db               	lda data
  1084  e321 60                 	rts			; indirect jmp
  1085                          ; -------------------------------------------------------------------------------------------------
  1086                          ; E322 User control code jump vector
  1087  e322 6c2203             cuser:	jmp (ctlvec)
  1088                          ; -------------------------------------------------------------------------------------------------
  1089                          ; E325 Cursor down/up
  1090  e325 b00d               cdnup:  bcs cup			; cursor up
  1091                          ; cursor down
  1092  e327 208be3             cdwn:	jsr nxln
  1093  e32a 20a6e4             cdn10:	jsr getbit		; a wrapped line ?
  1094  e32d b003               	bcs cdrts		; skip if yes
  1095  e32f 38                 	sec			; flag we left line
  1096  e330 66cf               	ror lsxp
  1097                          
  1098  e332 18                 cdrts:  clc
  1099  e333 60                 	rts
  1100                          ; E334 Cursor up
  1101  e334 a6dc               cup:	ldx sctop		; cursor up
  1102  e336 e4ca               	cpx tblx		; at top of window ?
  1103  e338 b00f               	bcs critgo		; yes - do nothing
  1104  e33a 202ae3             cup10:	jsr cdn10		; about to wrap to a new line ?
  1105  e33d c6ca               	dec tblx		; up a line
  1106  e33f 4cdfe0             	jmp stupt
  1107                          ; -------------------------------------------------------------------------------------------------
  1108                          ; E342 Cursor right/left
  1109  e342 b006               crtlf:  bcs cleft		; cursor left
  1110                          ; cursor right
  1111  e344 2021e5             crit:	jsr nxtchr		; cursor right
  1112  e347 b0e1               	bcs cdn10		; yes - test for wrap
  1113                          
  1114  e349 60                 critgo: rts
  1115                          ; E34A Cursor left
  1116  e34a 2034e5             cleft:  jsr bakchr		; move back
  1117  e34d b0fa               	bcs critgo		; abort if at top left
  1118  e34f d0e1               	bne cdrts		; no - exit
  1119  e351 e6ca               	inc tblx
  1120  e353 d0e5               	bne cup10		; go set flag if needed
  1121                          ; -------------------------------------------------------------------------------------------------
  1122                          ; E355 RVS on/off
  1123  e355 4980               rvsf:   eor #$80
  1124  e357 8d8303             	sta rvs
  1125  e35a 60                 	rts
  1126                          ; -------------------------------------------------------------------------------------------------
  1127                          ; E35B Home/clear
  1128  e35b 9003               homclr:	bcc homes		; if C=0 home
  1129  e35d 4cc5e0             	jmp clsr		; Clear screen, cursor home
  1130                          ; E360 Cursor home
  1131  e360 cd8503             homes:	cmp lstchr		; last char a home ?
  1132  e363 d003               	bne hm110		; no
  1133  e365 2093ea             	jsr sreset		; top=0,left=0,bot=nrows-1,rt=cols-1
  1134  e368 4cd3e0             hm110:  jmp nxtd		; set to top left
  1135                          ; -------------------------------------------------------------------------------------------------
  1136                          ; E36B Tab function
  1137  e36b a4cb               tabit:  ldy pntr
  1138  e36d b012               	bcs tabtog		; a tab toggle
  1139  e36f c4df               tab1:	cpy scrt		; at right of window
  1140  e371 9005               	bcc tab2		; no - tab to next
  1141  e373 a5df               	lda scrt		; set to screen right
  1142  e375 85cb               	sta pntr
  1143  e377 60                 	rts
  1144                          
  1145  e378 c8                 tab2:   iny			; find next tab stop
  1146  e379 2026ea             	jsr gettab
  1147  e37c f0f1               	beq tab1		; not yet !
  1148  e37e 84cb               	sty pntr
  1149  e380 60                 	rts
  1150                          ; E381 Toggle tabulator
  1151  e381 2026ea             tabtog: jsr gettab		; flip tab stop
  1152  e384 4d8803             	eor bitmsk
  1153  e387 9da103             	sta tab,x
  1154  e38a 60                 	rts
  1155                          ; -------------------------------------------------------------------------------------------------
  1156                          ; E38B Skip to next line
  1157                          ;   wrap to top if scroll disabled
  1158  e38b a6ca               nxln:	ldx tblx
  1159  e38d e4dd               	cpx scbot		; of the bottom of window ?
  1160  e38f 900f               	bcc nxln1		; no
  1161  e391 2c8703             	bit scrdis		; what if scrolling is disabled?
  1162  e394 1006               	bpl doscrl		; branch if scroll is enabled
  1163  e396 a5dc               	lda sctop		; wrap to top
  1164  e398 85ca               	sta tblx
  1165  e39a b006               	bcs nowhop		; always
  1166                          
  1167  e39c 2008e4             doscrl:	jsr scrup		; scroll it all
  1168  e39f 18                 	clc			; indicate scroll ok
  1169  e3a0 e6ca               nxln1:	inc tblx
  1170  e3a2 4cdfe0             nowhop:	jmp stupt		; set line base adr
  1171                          ; -------------------------------------------------------------------------------------------------
  1172                          ; E3A5 A return or shift return
  1173  e3a5 20f7e4             nxt1:   jsr fndend		; find the end of the current line
  1174  e3a8 e8                 	inx
  1175  e3a9 20b6e4             	jsr clrbit		; set next line as non-continued
  1176  e3ac a4de               	ldy sclf		; else point to start of next line
  1177  e3ae 84cb               	sty pntr
  1178  e3b0 208be3             	jsr nxln		; set up next line
  1179  e3b3 4c72e7             	jmp toqm		; turn off all modes
  1180                          ; -------------------------------------------------------------------------------------------------
  1181                          ; ****** scroll routines ******
  1182                          ; E3B6 Move one line
  1183  e3b6 bd3aec             movlin:	lda ldtb2,x		; set pointers to line address lo
  1184  e3b9 85c6               	sta sedeal
  1185  e3bb 85c4               	sta sedsal
  1186  e3bd bd53ec             	lda ldtb1,x
  1187  e3c0 85c5               	sta sedsal+1		; set pointer hi to vram
  1188  e3c2 2903               	and #$03
  1189  e3c4 09d4               	ora #>clrram		; calc colorram hi and set second pointer
  1190  e3c6 85c7               	sta sedeal+1
  1191                          
  1192  e3c8 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
  1193  e3cb b1c4               movl10: lda (sedsal),y
  1194  e3cd 206fe6             	jsr jwrvrm		; copy vram
  1195  e3d0 a900               	lda #$00
  1196  e3d2 11c6               	ora (sedeal),y		; read from color ram (ora() always from kernal bank)
  1197  e3d4 2072e6             	jsr jwrcrm		; write color ram
  1198  e3d7 c4df               	cpy scrt		; done a whole line ?
  1199  e3d9 c8                 	iny
  1200  e3da 90ef               	bcc movl10		; no
  1201                          
  1202  e3dc 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
  1203                          ; -------------------------------------------------------------------------------------------------
  1204                          ; E3DF ****** Scroll down ******
  1205  e3df a6cf               scrdwn: ldx lsxp
  1206  e3e1 3006               	bmi scd30		; skip if new line flag already set
  1207  e3e3 e4ca               	cpx tblx
  1208  e3e5 9002               	bcc scd30		; skip if old line is below scroll area
  1209  e3e7 e6cf               	inc lsxp		; else inc start line number
  1210  e3e9 a6dd               scd30:  ldx scbot		; scroll down, start bottom
  1211                          
  1212  e3eb 20e1e0             scd10:  jsr scrset		; set pnt to line
  1213  e3ee a4de               	ldy sclf
  1214  e3f0 e4ca               	cpx tblx		; test if at destination line
  1215  e3f2 f00e               	beq scd20		; done if yes
  1216  e3f4 ca                 	dex			; point to previous line as source
  1217  e3f5 20a8e4             	jsr getbt1
  1218  e3f8 e8                 	inx
  1219  e3f9 20b4e4             	jsr putbt1		; move continuation byte
  1220  e3fc ca                 	dex
  1221  e3fd 20b6e3             	jsr movlin		; move one line
  1222  e400 b0e9               	bcs scd10		; always
  1223                          
  1224  e402 2024e2             scd20:	jsr clrln		; set line to blanks
  1225  e405 4cc3e4             	jmp setbit		; mark as continuation line
  1226                          ; -------------------------------------------------------------------------------------------------
  1227                          ; E408 ****** Scroll up ******
  1228  e408 a6dc               scrup:  ldx sctop
  1229  e40a e8                 scru00: inx
  1230  e40b 20a8e4             	jsr getbt1		; find first non-continued line
  1231  e40e 900a               	bcc scru15
  1232  e410 e4dd               	cpx scbot		; is entire screen 1 line?
  1233  e412 90f6               	bcc scru00		; do normal scroll if not
  1234                          
  1235  e414 a6dc               	ldx sctop
  1236  e416 e8                 	inx
  1237  e417 20b6e4             	jsr clrbit		; clear to only scroll 1 line
  1238                          
  1239  e41a c6ca               scru15:	dec tblx
  1240  e41c 24cf               	bit lsxp
  1241  e41e 3002               	bmi scru20		; no change if already new line
  1242  e420 c6cf               	dec lsxp		; move input up one
  1243  e422 a6dc               scru20:	ldx sctop
  1244  e424 e4da               	cpx sedt2
  1245  e426 b002               	bcs scru30
  1246  e428 c6da               	dec sedt2		; in case doing insert
  1247  e42a 203fe4             scru30:	jsr scr10		; scroll
  1248  e42d a6dc               	ldx sctop
  1249  e42f 20a8e4             	jsr getbt1
  1250  e432 08                 	php
  1251  e433 20b6e4             	jsr clrbit		; make sure top line is not continuation
  1252  e436 28                 	plp
  1253  e437 9005               	bcc scru10		; done if top line off
  1254  e439 2c8a03             	bit logscr		; logical scroll ?
  1255  e43c 30ca               	bmi scrup		; yes - keep scrolling  ********** b128 v4: -> scru15
  1256  e43e 60                 scru10: rts
  1257                          ; E43F
  1258  e43f 20e1e0             scr10:	jsr scrset		; point to start of line
  1259  e442 a4de               	ldy sclf
  1260  e444 e4dd               	cpx scbot		; at last line ?
  1261  e446 b00e               	bcs scr40		; yes
  1262  e448 e8                 	inx			; point to next line
  1263  e449 20a8e4             	jsr getbt1
  1264  e44c ca                 	dex
  1265  e44d 20b4e4             	jsr putbt1		; move continuation byte
  1266  e450 e8                 	inx
  1267  e451 20b6e3             	jsr movlin		; move one line
  1268  e454 b0e9               	bcs scr10
  1269                          ; E456 Test for slow scroll
  1270  e456 2024e2             scr40:  jsr clrln		; make last line blank
  1271  e459 a2ff               	ldx #$FF
  1272  e45b a0fe               	ldy #$FE		; allow only output line 0
  1273  e45d 2098e4             	jsr getlin		; get input
  1274  e460 2920               	and #$20		; check if interrupt i5 = control
  1275  e462 d013               	bne scr80		; if not skip ahead - not slow scroll
  1276                          ; E464 Slow scroll delay loop
  1277                          scr60:
  1278                          !ifndef CBMPATCH{		; ********** PATCH nop's are for 2MHz B-series, P is slow enough ;)
  1279                          				;            get an extra byte for the cbmii patch below!
  1280                          	nop			; yes - waste time
  1281                          	nop
  1282                          }
  1283  e464 ca                 	dex
  1284  e465 d0fd               	bne scr60
  1285  e467 88                 	dey
  1286  e468 d0fa               	bne scr60
  1287                          
  1288  e46a 84d1               scr70:  sty ndx
  1289  e46c a27f               scr75:  ldx #$7F
  1290  e46e 8e00df             	stx tpi2+pa
  1291  e471 a2ff               	ldx #$FF
  1292  e473 8e01df             	stx tpi2+pb
  1293  e476 60                 	rts
  1294                          ; E479 Scroll stop
  1295  e477 a2f7               scr80:  ldx #$F7		; allow only output line 11
  1296  e479 a0ff               	ldy #$FF
  1297  e47b 2098e4             	jsr getlin		; get input lines key
  1298  e47e 2910               	and #$10		; check for the commodore key
  1299  e480 d0ea               	bne scr75		; exit if not - no stop scroll
  1300                          
  1301  e482 2098e4             scr90:	jsr getlin		; get input lines
  1302  e485 2910               	and #$10		; check for the commodore key
  1303  e487 f0f9               	beq scr90		; wait until com.key not depressed
  1304                          
  1305  e489 a000               scr95:	ldy #0
  1306  e48b a200               	ldx #0			; allow all output lines
  1307  e48d 2098e4             	jsr getlin		; get inputs
  1308  e490 293f               	and #$3F		; check for any input
  1309  e492 493f               	eor #$3F
  1310  e494 f0f3               	beq scr95		; wait
  1311  e496 d0d2               	bne scr70		; always
  1312                          ; E49A Keyboard check for slow scroll
  1313                          getlin: 
  1314                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1315  e498 08                  	php			; preserve the irq flag
  1316                          }
  1317  e499 78                 	sei
  1318  e49a 8e00df             	stx tpi2+pa		; set port-a output
  1319  e49d 8c01df             	sty tpi2+pb		; set port-b outputs
  1320  e4a0 20eae9             	jsr getkey		; get port-c inputs
  1321                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1322  e4a3 28                 	plp
  1323                          } else{
  1324                          	cli
  1325                          }
  1326  e4a4 60                 	rts
  1327                          *= $E4A6
  1328                          ; -------------------------------------------------------------------------------------------------
  1329                          ; ****** wrap table subroutines *******
  1330                          ; E4A6 Check for a double length line
  1331  e4a6 a6ca               getbit: ldx tblx		; load current line
  1332                          ; E4a8 Check line X for double length
  1333  e4a8 20cfe4             getbt1: jsr bitpos		; get byte & bit positions
  1334  e4ab 35e2               	and bitabl,x		; check if bit for line is set in table
  1335  e4ad c901               	cmp #1			; make carry clear if zero
  1336  e4af 4cbfe4             	jmp bitout		; return 0 if not a double length line
  1337                          ; -------------------------------------------------------------------------------------------------
  1338                          ; E4B2 Mark current line as double length C=1, unmark C=0
  1339                          ; putbit - set bit according to carry
  1340  e4b2 a6ca               putbit: ldx tblx		; load current line
  1341                          ; Mark line X
  1342  e4b4 b00d               putbt1: bcs setbit		; go if to mark as wrappped line
  1343                          ; clrbit - clear wrap bit
  1344  e4b6 20cfe4             clrbit: jsr bitpos		; get byte & bit positions
  1345  e4b9 49ff               	eor #$FF		; invert bit position
  1346  e4bb 35e2               	and bitabl,x		; clear bit
  1347  e4bd 95e2               bitsav: sta bitabl,x		; and store it to table at byte position X
  1348  e4bf ae8803             bitout: ldx bitmsk		; move byte table position to X
  1349  e4c2 60                 	rts
  1350                          ; setbit  -  set bit to mark as wrapped line
  1351  e4c3 2c8703             setbit: bit scrdis		; auto line link disable...
  1352  e4c6 70e0               	bvs getbt1		; branch if scrolling is disabled
  1353  e4c8 20cfe4             	jsr bitpos		; get byte & bit position
  1354  e4cb 15e2               	ora bitabl,x		; set wrap bit
  1355  e4cd d0ee               	bne bitsav		; always
  1356                          ; Find bit table position for line X
  1357  e4cf 8e8803             bitpos: stx bitmsk		; remember line
  1358  e4d2 8a                 	txa
  1359  e4d3 2907               	and #$07		; get bit position
  1360  e4d5 aa                 	tax
  1361  e4d6 bdefec             	lda bits,x		; get bit mask
  1362  e4d9 48                 	pha			; remember it
  1363  e4da ad8803             	lda bitmsk
  1364  e4dd 4a                 	lsr
  1365  e4de 4a                 	lsr			; shift to get byte position (/8)
  1366  e4df 4a                 	lsr
  1367  e4e0 aa                 	tax			; move byte pos to X
  1368  e4e1 68                 	pla			; return bit value in A
  1369  e4e2 60                 	rts
  1370                          ; -------------------------------------------------------------------------------------------------
  1371                          ; E4E2 ****** Move to start of line
  1372                          ; Find line start/end
  1373  e4e3 9012               	bcc fndend		; if C=0 find line end - NOT USED
  1374                          ; E4E5 cursor to line start (esc-j)
  1375  e4e5 a4de               fndfst:	ldy sclf
  1376  e4e7 84cb               	sty pntr		; set to leftmost column
  1377  e4e9 20a6e4             fistrt:	jsr getbit		; find start of current line
  1378  e4ec 9006               	bcc fnd0		; branch if found
  1379  e4ee c6ca               	dec tblx		; up a line
  1380  e4f0 10f7               	bpl fistrt		; always
  1381  e4f2 e6ca               	inc tblx		; whoops went too far
  1382  e4f4 4cdfe0             fnd0:	jmp stupt		; set line base adr
  1383                          ; -------------------------------------------------------------------------------------------------
  1384                          ; E4F7 ****** Find last non-blank char of line
  1385                          ;   pntr= column #
  1386                          ;   tblx= line #
  1387                          ; cursor to end of line (esc-k)
  1388  e4f7 e6ca               fndend:	inc tblx
  1389  e4f9 20a6e4             	jsr getbit		; is this line continued
  1390  e4fc b0f9               	bcs fndend		; branch if so
  1391  e4fe c6ca               	dec tblx		; found it - compensate for inc tblx
  1392  e500 20dfe0             	jsr stupt		; reset screen pointer to line start
  1393  e503 a4df               	ldy scrt		; get right margin
  1394  e505 84cb               	sty pntr		; point to right margin
  1395  e507 1005               	bpl eloup2		; always
  1396  e509 2034e5             eloup1:	jsr bakchr		; backup one char
  1397  e50c b010               	bcs endbye		; if at top left get out
  1398  e50e 203fe2             eloup2: jsr get1ch		; get char from screen
  1399  e511 c920               	cmp #$20
  1400  e513 d009               	bne endbye		; yes, space
  1401  e515 c4de               	cpy sclf		; are we at the left margin?
  1402  e517 d0f0               	bne eloup1		; branch if not
  1403  e519 20a6e4             	jsr getbit		; if we're on a wraped line
  1404  e51c b0eb               	bcs eloup1		; always scan the above line
  1405                          
  1406  e51e 84d5               endbye: sty indx		; remember this
  1407  e520 60                 	rts
  1408                          ; -------------------------------------------------------------------------------------------------
  1409                          ; E521 ****** Move to next char
  1410                          ; scroll if enabled
  1411                          ; wrap to top if disabled
  1412  e521 48                 nxtchr:	pha
  1413  e522 a4cb               	ldy pntr
  1414  e524 c4df               	cpy scrt		; are we at the right margin?
  1415  e526 9007               	bcc bumpnt		; branch if not
  1416                          
  1417  e528 208be3             	jsr nxln		; point to nextline
  1418  e52b a4de               	ldy sclf		; point to first char of 1st line
  1419  e52d 88                 	dey
  1420  e52e 38                 	sec			; set to show moved to new line
  1421  e52f c8                 bumpnt:	iny			; increment char index
  1422  e530 84cb               	sty pntr
  1423  e532 68                 	pla
  1424  e533 60                 	rts
  1425                          ; -------------------------------------------------------------------------------------------------
  1426                          ; E534 Backup one char - Move one char left
  1427                          ; wrap up and stop a top left
  1428  e534 a4cb               bakchr:	ldy pntr
  1429  e536 88                 	dey
  1430  e537 3004               	bmi bakot1
  1431  e539 c4de               	cpy sclf		; are we at the left margin
  1432  e53b b00f               	bcs bakout		; no - past it
  1433  e53d a4dc               bakot1:	ldy sctop
  1434  e53f c4ca               	cpy tblx		; are we at top line last character?
  1435  e541 b00e               	bcs bakot2		; leave with carry set
  1436  e543 c6ca               	dec tblx		; else backup a line
  1437  e545 48                 	pha
  1438  e546 20dfe0             	jsr stupt		; set line base adr
  1439  e549 68                 	pla
  1440  e54a a4df               	ldy scrt		; move cursor to right side
  1441  e54c 84cb               bakout: sty pntr
  1442  e54e c4df               	cpy scrt		; set z-flag if moved to new line
  1443  e550 18                 	clc			; always clear
  1444  e551 60                 bakot2: rts
  1445                          ; -------------------------------------------------------------------------------------------------
  1446                          ; E552 savpos - Save row & column position
  1447  e552 a4cb               savpos: ldy pntr
  1448  e554 84d9               	sty sedt1
  1449  e556 a6ca               	ldx tblx
  1450  e558 86da               	stx sedt2
  1451  e55a 60                 	rts
  1452                          ; -------------------------------------------------------------------------------------------------
  1453                          ; E55B Delete or insert a character
  1454  e55b b034               delins: bcs insert		; C=1 is insert
  1455                          ; delete a character
  1456  e55d 204ae3             deleet: jsr cleft		; move back 1 position
  1457  e560 2052e5             	jsr savpos		; save column & row positions
  1458  e563 b00f               	bcs delout		; abort if at top left corner
  1459                          
  1460  e565 c4df               deloop: cpy scrt		; at right margin?
  1461  e567 9016               	bcc delop1		; no - skip ahaed
  1462  e569 a6ca               	ldx tblx
  1463  e56b e8                 	inx
  1464  e56c 20a8e4             	jsr getbt1		; is next line a wrapped line?
  1465  e56f b00e               	bcs delop1		; yes - continue with delete
  1466  e571 2007e2             	jsr doblnk		; no - blank last character
  1467                          
  1468  e574 a5d9               delout: lda sedt1		; restore column and row positions
  1469  e576 85cb               	sta pntr
  1470  e578 a5da               	lda sedt2
  1471  e57a 85ca               	sta tblx
  1472  e57c 4cdfe0             	jmp stupt		; restore pnt and exit
  1473                          ; E57F
  1474  e57f 2021e5             delop1: jsr nxtchr
  1475  e582 203fe2             	jsr get1ch		; get next character
  1476  e585 2034e5             	jsr bakchr
  1477  e588 200de2             	jsr dsptco		; move it back 1 position
  1478  e58b 2021e5             	jsr nxtchr		; move up 1 position
  1479  e58e 4c65e5             	jmp deloop		; loop until at end of line
  1480                          ; E591 Insert a character 
  1481  e591 2052e5             insert: jsr savpos		; save column & row positions
  1482  e594 20f7e4             	jsr fndend		; move to last char on the line
  1483  e597 e4da               	cpx sedt2		; last row equal to starting row?
  1484  e599 d002               	bne ins10		; no - skip ahead
  1485  e59b c4d9               	cpy sedt1		; is last position before starting position?
  1486  e59d 9021               ins10:	bcc ins50		; yes - no need to move anything
  1487  e59f 20dbe5             	jsr movchr		; move to next char position
  1488  e5a2 b022               	bcs insout		; abort if scroll needed but disabled
  1489                          
  1490  e5a4 2034e5             ins30:	jsr bakchr
  1491  e5a7 203fe2             	jsr get1ch		; move char forward 1 position
  1492  e5aa 2021e5             	jsr nxtchr
  1493  e5ad 200de2             	jsr dsptco
  1494  e5b0 2034e5             	jsr bakchr
  1495  e5b3 a6ca               	ldx tblx
  1496  e5b5 e4da               	cpx sedt2		; at original position
  1497  e5b7 d0eb               	bne ins30
  1498  e5b9 c4d9               	cpy sedt1
  1499  e5bb d0e7               	bne ins30		; no - loop till we are
  1500                          
  1501  e5bd 2007e2             	jsr doblnk		; insert a blank
  1502  e5c0 e6d3               ins50:	inc insrt		; inc insert count
  1503  e5c2 d002               	bne insout		; only allow up to 255
  1504  e5c4 c6d3               	dec insrt
  1505  e5c6 4c74e5             insout:	jmp delout		; restore original position
  1506                          ; -------------------------------------------------------------------------------------------------
  1507                          ; E5C9 Stop/run
  1508  e5c9 900f               stprun: bcc runrts		; exit if a stop code
  1509  e5cb 78                 	sei			; disable interrupts
  1510  e5cc a209               	ldx #9
  1511  e5ce 86d1               	stx ndx			; set keyboard queue size
  1512  e5d0 bd30ec             runlop:	lda runtb-1,x
  1513  e5d3 9daa03             	sta keyd-1,x		; load run character sequence into kybd queue
  1514  e5d6 ca                 	dex
  1515  e5d7 d0f7               	bne runlop
  1516                          
  1517  e5d9 58                 	cli			; enable interrupts
  1518  e5da 60                 runrts: rts
  1519                          ; -------------------------------------------------------------------------------------------------
  1520                          ; E5DB movchr  -  Move to next char position
  1521                          ; insert blank line if at end of line
  1522                          ;   y = column position
  1523                          ;   on exit - carry set = abort - scroll disabled
  1524  e5db c4df               movchr: cpy scrt
  1525  e5dd 900b               	bcc movc10		; easy if not at end of line
  1526  e5df a6ca               	ldx tblx
  1527  e5e1 e4dd               	cpx scbot
  1528  e5e3 9005               	bcc movc10		; skip if not last line of screen
  1529  e5e5 2c8703             	bit scrdis
  1530  e5e8 3017               	bmi movc30		; abort if scrolling disabled
  1531                          
  1532  e5ea 20dfe0             movc10:	jsr stupt		; set pnt address
  1533  e5ed 2021e5             	jsr nxtchr		; move to next char position
  1534  e5f0 900f               	bcc movc30		; done if not move to new line
  1535  e5f2 20a6e4             	jsr getbit		; check if on a continued line
  1536  e5f5 b009               	bcs movc20		; skip ahead if not
  1537                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1538  e5f7 2023ed             	jsr patch1		; patch in a check for single line screen
  1539  e5fa 38                 	sec			; prep for abort...
  1540                          } else{
  1541                          	sec			; prep for abort...
  1542                          	bit scrdis
  1543                          }
  1544  e5fb 7004               	bvs movc30
  1545  e5fd 20dfe3             	jsr scrdwn		; else insert a blank line
  1546                          
  1547  e600 18                 movc20:	clc			; for clean exit
  1548  e601 60                 movc30: rts
  1549                          ; -------------------------------------------------------------------------------------------------
  1550                          ; E602 Change color
  1551  e602 a010               chkcol:	ldy #16			; there's 16 colors
  1552  e604 88                 chk1a:	dey
  1553  e605 3008               	bmi chk1b
  1554  e607 d912ed             	cmp coltab,y
  1555  e60a d0f8               	bne chk1a
  1556  e60c 84ec               	sty color		; change the color
  1557  e60e 60                 	rts
  1558                          
  1559  e60f 4c22e3             chk1b:	jmp cuser
  1560                          ; -------------------------------------------------------------------------------------------------
  1561                          ; E612 Write a byte to the VIC chip
  1562                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1563                          wrtvic: sta saver		; remember value
  1564                          wrtvrpt:lda saver
  1565                          	sta vic,y		; store value to VIC register
  1566                          	eor vic,y		; check stored value
  1567                          	beq wrtvok		; jump to end if success
  1568                          	cpy #$20
  1569                          	bcs wrtvg20		; jump if reg >= $20
  1570                          	cpy #$11
  1571                          	bcc wrtvrpt		; write again if register < $10 is different
  1572                          	and wrtvtbl - $11,y	; clear unused bits with register mask table 
  1573                          	bne wrtvrpt		; write register again if different
  1574                          wrtvg20:and #$0F		; clear upper nibble because only bit#0-3 used
  1575                          	bne wrtvrpt		; write register again if different
  1576                          wrtvok: lda saver
  1577                          	rts
  1578                          wrtvtbl:!byte $7F,$00,$00,$00,$FF,$3F,$FF,$FE
  1579                          	!byte $00,$0F,$FF,$FF,$FF,$FF,$FF
  1580                          } else{				; ********** Fast video PATCH **********
  1581  e612 9900d8             wrtvic: sta vic,y
  1582  e615 60                 	rts
  1583                          }
  1584                          *= $E641
  1585                          ; -------------------------------------------------------------------------------------------------
  1586                          ; E641 Write char A to screen at current line, column Y
  1587                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1588                          wrvram:	sta saver		; remember value
  1589                          wrtrrpt:lda saver
  1590                          	sta (pnt),y		; store to screen RAM
  1591                          	lda (pnt),y		; load from screen
  1592                          	eor saver		; check if same
  1593                          	bne wrtrrpt		; repeat store if not equal
  1594                          
  1595                          	lda saver
  1596                          	rts
  1597                          } else{                         ; ********** Fast video PATCH **********
  1598  e641 91c8               wrvram:	sta (pnt),y		; store byte to screen line pointer + coulmn X
  1599  e643 60                 	rts
  1600                          }
  1601                          *= $E650
  1602                          ; -------------------------------------------------------------------------------------------------
  1603                          ; E650 Write color to color RAM at current line, column Y
  1604                          !ifdef STANDARD_VIDEO{          ; ********** Standard video **********
  1605                          wrcram:	sta saver		; remember value
  1606                          	lda i6509
  1607                          	pha			; remember indirect bank
  1608                          	lda #irom
  1609                          	sta i6509		; switch to system bank
  1610                          wrtcrpt:lda saver
  1611                          	sta (user),y		; store to color RAM
  1612                          	eor (user),y		; check if same
  1613                          	and #$0F		; load and isolate low nibble
  1614                          	bne wrtcrpt		; repeat if not equal
  1615                          
  1616                          	pla
  1617                          	sta i6509		; restore ibank
  1618                          	lda saver
  1619                          	rts
  1620                          } else{
  1621                          !ifdef BANK15_VIDEO{            ; ********** Video bank15 PATCH **********
  1622  e650 91e8               wrcram:	sta (user),y		; store to color RAM
  1623  e652 60                 	rts
  1624                          	} else{                 ; ********** Fast video PATCH **********
  1625                          wrcram:	sta saver		; remember value
  1626                          	lda i6509
  1627                          	pha			; remember indirect bank
  1628                          	lda #irom
  1629                          	sta i6509		; switch to system bank
  1630                          	lda saver
  1631                          	sta (user),y		; store to color RAM
  1632                          	pla
  1633                          	sta i6509		; restore ibank
  1634                          	lda saver
  1635                          	rts
  1636                          }
  1637                          }
  1638                          *= $E669
  1639                          ; -------------------------------------------------------------------------------------------------
  1640                          ; E669 Vector unused
  1641  e669 6cbb03             junkwn1:jmp (iunkwn1)		; vector -> nofunc (rts)
  1642                          ; -------------------------------------------------------------------------------------------------
  1643                          ; E66C Vector unused
  1644  e66c 6cbd03             junkwn2:jmp (iunkwn2)		; vector -> nofunc (rts)
  1645                          ; -------------------------------------------------------------------------------------------------
  1646                          ; E66F Jump vector: Write char to screen
  1647  e66f 6cb703             jwrvrm:	jmp (iwrtvrm)		; -> $03B7 -> $E641
  1648                          ; -------------------------------------------------------------------------------------------------
  1649                          ; E672 Jump vector: Write color to color RAM
  1650  e672 6cb903             jwrcrm:	jmp (iwrtcrm)		; -> $03B9 -> $E650
  1651                          ; -------------------------------------------------------------------------------------------------
  1652                          ; E675 Ring the bell, if enabled
  1653  e675 ad8b03             bell:   lda bellmd
  1654  e678 d028               	bne bellgo
  1655  e67a a90f               	lda #$0F
  1656  e67c 8d18da             	sta sid+volume		; turn up volume
  1657  e67f a900               	lda #$00
  1658  e681 8d05da             	sta sid+osc1+atkdcy	; attack=0, decay=0
  1659  e684 a9f8               	lda #$F8
  1660  e686 8d06da             	sta sid+osc1+susrel	; sustain=15, release=8
  1661  e689 a940               	lda #$40
  1662  e68b 8d01da             	sta sid+osc1+freqhi	; voice 1 freq.
  1663  e68e a980               	lda #$80
  1664  e690 8d0fda             	sta sid+osc3+freqhi	; voice 3 freq.
  1665  e693 a215               	ldx #$15
  1666  e695 8e04da             	stx sid+osc1+oscctl	; voice 1 gate on, triangle, ring mod. 
  1667  e698 a000               	ldy #$00
  1668  e69a c8                 bell10:	iny
  1669  e69b ea                 	nop			; wait to reach sustain level
  1670  e69c d0fc               	bne bell10
  1671                          
  1672  e69e ca                 	dex
  1673  e69f 8e04da             	stx sid+osc1+oscctl	; gate off
  1674  e6a2 60                 bellgo: rts
  1675                          ; -------------------------------------------------------------------------------------------------
  1676                          ; E6A3 ce - Clear entry
  1677                          ;   always deletes last character entered
  1678                          ;   will delete all <#>s. (0 1 2 3 4 5 6 7 8 9 .)
  1679                          ;   will delete if (<#>e<+/->)
  1680                          ;   cursor must be next posistion beyond entry being deleted.
  1681  e6a3 a5cb               ce:	lda pntr		; get index on line
  1682  e6a5 48                 	pha			; save for final delete if necessary
  1683  e6a6 a4cb               cet0:	ldy pntr
  1684  e6a8 88                 	dey
  1685  e6a9 2041e2             	jsr getych		; get previous character
  1686  e6ac c92b               	cmp #'+'		; (+)
  1687  e6ae f004               	beq cet1
  1688  e6b0 c92d               	cmp #'-'		; (-)
  1689  e6b2 d008               	bne cet2
  1690                          
  1691  e6b4 88                 cet1:	dey			; try for an <#>e
  1692  e6b5 2041e2             	jsr getych
  1693  e6b8 c905               	cmp #5			; (e)
  1694  e6ba d01a               	bne cet4		; exit if not...it can only be an <#>e
  1695                          
  1696  e6bc c905               cet2:	cmp #5			; (e)
  1697  e6be d004               	bne cet3
  1698  e6c0 88                 	dey
  1699  e6c1 2041e2             	jsr getych
  1700                          
  1701  e6c4 c92e               cet3:	cmp #'.'		; try for a <#>
  1702  e6c6 900e               	bcc cet4		; (.)
  1703  e6c8 c92f               	cmp #'0'-1
  1704  e6ca f00a               	beq cet4
  1705  e6cc c93a               	cmp #'9'+1		; (0-9)
  1706  e6ce b006               	bcs cet4
  1707                          
  1708  e6d0 205de5             	jsr deleet
  1709  e6d3 4ca6e6             	jmp cet0
  1710                          
  1711  e6d6 68                 cet4:	pla			; check if any deletes occured
  1712  e6d7 c5cb               	cmp pntr
  1713  e6d9 d0c7               	bne bellgo		; yes...exit
  1714  e6db 4c5de5             	jmp deleet		; else... go delete a character
  1715                          ; -------------------------------------------------------------------------------------------------
  1716                          ; E6DE Escape sequence vector
  1717  e6de 6c2003             sequen:	jmp (escvec)		; escape indirect
  1718                          ; -------------------------------------------------------------------------------------------------
  1719                          ;******************************
  1720                          ; E6E1 Insert line (esc-i)
  1721                          ;*****************************
  1722  e6e1 20dfe3             iline:	jsr scrdwn		; insert a blank line
  1723  e6e4 20d9e0             	jsr stu10		; move to start of line
  1724  e6e7 e8                 	inx
  1725  e6e8 20a8e4             	jsr getbt1
  1726  e6eb 08                 	php
  1727  e6ec 20b2e4             	jsr putbit		; set continuation same as in previous line
  1728  e6ef 28                 	plp
  1729  e6f0 b003               	bcs linrts		; skip if was wrapped
  1730  e6f2 38                 	sec
  1731  e6f3 66cf               	ror lsxp  		; set flag - new line
  1732                          
  1733  e6f5 60                 linrts: rts
  1734                          ; -------------------------------------------------------------------------------------------------
  1735                          ;**************************
  1736                          ; Delete line (esc-d)
  1737                          ;**************************
  1738                          ; E6F8 Insert or delete a line
  1739  e6f6 b0e9               	bcs iline		; insert if C=1
  1740                          
  1741  e6f8 20e9e4             dline:	jsr fistrt		; find start of line
  1742  e6fb a5dc               	lda sctop		; save current of window
  1743  e6fd 48                 	pha
  1744  e6fe a5ca               	lda tblx		; make 1st display line top of window
  1745  e700 85dc               	sta sctop
  1746  e702 ad8a03             	lda logscr		; make sure logical scrl is off
  1747  e705 48                 	pha
  1748  e706 a980               	lda #$80
  1749  e708 8d8a03             	sta logscr
  1750  e70b 201ae4             	jsr scru15		; scroll the top line away
  1751  e70e 68                 	pla
  1752  e70f 8d8a03             	sta logscr
  1753  e712 a5dc               	lda sctop		; make old 1st line of this 1 current
  1754  e714 85ca               	sta tblx
  1755  e716 68                 	pla
  1756  e717 85dc               	sta sctop
  1757  e719 38                 	sec
  1758  e71a 66cf               	ror lsxp		; set flag - new line
  1759  e71c 4cd9e0             	jmp stu10		; make this line the current one
  1760                          ; -------------------------------------------------------------------------------------------------
  1761                          ;******************************
  1762                          ; E71F Erase to end of line (esc-q)
  1763                          ;******************************
  1764  e71f 18                 etoeol: clc
  1765  e720 24                 	!byte $24               ; skip next instruction
  1766                          ;******************************
  1767                          ; E721 Erase to start of line (esc-p)
  1768                          ;******************************
  1769  e721 38                 etosol: sec
  1770  e722 2052e5             	jsr savpos
  1771  e725 b012               	bcs etstol
  1772                          ; Erase to end of line
  1773  e727 2029e2             etol:	jsr clrprt		; blank rest of line
  1774  e72a e6ca               	inc tblx		; move to next line
  1775  e72c 20dfe0             	jsr stupt
  1776  e72f a4de               	ldy sclf
  1777  e731 20a6e4             	jsr getbit		; check if next is wrapped line
  1778  e734 b0f1               	bcs etol		; yes - blank next line
  1779                          
  1780  e736 4c74e5             etout:	jmp delout		; exit and restore original position
  1781                          ; Erase to start of line
  1782  e739 2007e2             etstol:	jsr doblnk		; do a blank
  1783  e73c c4de               	cpy sclf		; done a line ?
  1784  e73e d005               	bne ets100		; no
  1785  e740 20a6e4             	jsr getbit		; at top of line
  1786  e743 90f1               	bcc etout		; yes - exit
  1787  e745 2034e5             ets100:	jsr bakchr		; back up
  1788  e748 90ef               	bcc etstol		; always
  1789                          ; -------------------------------------------------------------------------------------------------
  1790                          ;*****************************
  1791                          ; E74A Scroll up (esc-v)
  1792                          ;*****************************
  1793  e74a 18                 esuup:	clc
  1794  e74b 24                 	!byte $24               ; skips next instruction
  1795                          ;*****************************
  1796                          ; E74C Scroll down (esc-w)
  1797                          ;*****************************
  1798  e74c 38                 esddn:	sec
  1799                          ; E74D Scroll screen depending on carry
  1800  e74d 2052e5             suup:	jsr savpos
  1801  e750 b00b               	bcs sddn		; scroll down if C=1
  1802                          ; Scroll up
  1803  e752 8a                 	txa
  1804  e753 48                 	pha
  1805  e754 2008e4             	jsr scrup
  1806  e757 68                 	pla
  1807  e758 85da               	sta sedt2
  1808  e75a 4c36e7             	jmp etout		; always
  1809                          ; Scroll down
  1810  e75d 20a6e4             sddn:   jsr getbit
  1811  e760 b003               	bcs sddn2
  1812  e762 38                 	sec
  1813  e763 66cf               	ror lsxp		; set flag - left line
  1814  e765 a5dc               sddn2:  lda sctop
  1815  e767 85ca               	sta tblx		; scroll from screen top
  1816  e769 20dfe3             	jsr scrdwn
  1817  e76c 20b6e4             	jsr clrbit		; make first line non-continued
  1818  e76f 4c36e7             	jmp etout		; always
  1819                          ; -------------------------------------------------------------------------------------------------
  1820                          ;**************************************
  1821                          ; Turn off all modes
  1822                          ;   expected to return zero
  1823                          ;**************************************
  1824                          ; E772 Reset modes: insert, reverse, quote
  1825  e772 a900               toqm:	lda #0
  1826  e774 85d3               	sta insrt
  1827  e776 8d8303             	sta rvs
  1828  e779 85d2               	sta qtsw
  1829                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1830  e77b 8d18da             	sta sid+volume		; turn off sid
  1831                          } else{
  1832                          	sta unknwn
  1833                          }
  1834  e77e 60                 	rts
  1835                          *= $E77F
  1836                          ; -------------------------------------------------------------------------------------------------
  1837                          ; E77F Enable scrolling (esc-l)
  1838  e77f 18                 scrsw0:	clc
  1839  e780 9001               	bcc scrsw
  1840                          ; E782 Disable scrolling (esc-m)
  1841  e782 38                 scrsw1:	sec
  1842                          ; Scrolling enable/disable
  1843                          ;           carry set = disable
  1844  e783 a900               scrsw:	lda #0
  1845  e785 6a                 	ror
  1846  e786 8d8703             	sta scrdis		; store flag: $00 = enable, $80 = disable
  1847  e789 60                 	rts
  1848                          ; -------------------------------------------------------------------------------------------------
  1849                          ; E78A Insert mode off
  1850  e78a 18                 insoff:	clc
  1851  e78b 9001               	bcc inssw
  1852                          ; E78D Insert mode on
  1853  e78d 38                 inson:	sec
  1854                          ; Auto insert on/off
  1855                          ;           carry set = on
  1856  e78e a900               inssw:	lda #0
  1857  e790 6a                 	ror
  1858  e791 8d8603             	sta insflg		; store flag: $00 = off, $80 = on
  1859  e794 60                 	rts
  1860                          ; -------------------------------------------------------------------------------------------------
  1861                          ; E795 Enable/Disable logical scroll
  1862  e795 18                 logoff:	clc			; disable logical scroll (single line scroll)
  1863  e796 9001               	bcc logsw
  1864                          
  1865  e798 38                 logon:	sec			; enable logical scroll (scroll a set of lines)
  1866                          ; Logical scroll enable/disable
  1867                          ;   carry set = enable
  1868  e799 a900               logsw:	lda #0
  1869  e79b 6a                 	ror
  1870  e79c 8d8a03             	sta logscr		; store flag: $00 = disable, $80 = enable
  1871  e79f 60                 	rts
  1872                          ; -------------------------------------------------------------------------------------------------
  1873                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1874                          ; E7A0 This function is not used - removed in patch 3
  1875  e7a0 60                 unused:	rts			; something related to $03BF
  1876                          				;   code removed to free space for new f-key functions below
  1877                          ; -------------------------------------------------------------------------------------------------
  1878                          ; ********** Patched new f-key functions with sei/cli and chr$(141) for shift-return **********
  1879  e7a1 78                 keyfun: sei			; prevent fight over variables with keyscan...
  1880  e7a2 88                 	dey
  1881  e7a3 3003               	bmi listky		; do list if no parameters given
  1882  e7a5 4c64e8             	jmp addkey		; - else go add a new key definition
  1883                          ; list key defintions
  1884  e7a8 a000               listky:	ldy #0			; initialize key counter
  1885                          
  1886  e7aa c8                 listlp:	iny
  1887  e7ab 84d9               	sty sedt1
  1888  e7ad 88                 	dey			; minus 1 for indexing
  1889  e7ae b98d03             	lda keysiz,y		; get key length
  1890  e7b1 f06b               	beq nodefn		; no listing if no defintion
  1891  e7b3 8d8903             	sta keyidx		; save key length
  1892  e7b6 2015ea             	jsr findky		; get buffer start addr for function key
  1893  e7b9 85c2               	sta keypnt
  1894  e7bb 86c3               	stx keypnt+1		; save 2 byte address in temp loc
  1895                          ; print 'key ' preamble
  1896  e7bd a203               	ldx #3
  1897  e7bf bd4ce8             preamb:	lda keword,x
  1898  e7c2 20d2ff             	jsr bsout
  1899  e7c5 ca                 	dex
  1900  e7c6 10f7               	bpl preamb
  1901                          ; convert to 1 or 2 digit ascii
  1902  e7c8 a22f               	ldx #$2F
  1903  e7ca a5d9               	lda sedt1		; get key number
  1904  e7cc 38                 	sec
  1905  e7cd e8                 ky2asc:	inx			; .x=$30, if two digits it will inc to $31
  1906  e7ce e90a               	sbc #10
  1907  e7d0 b0fb               	bcs ky2asc		; repeat if >9
  1908  e7d2 693a               	adc #$3A		; add 10 & make ascii
  1909  e7d4 e030               	cpx #$30
  1910  e7d6 f006               	beq nosec		; skip 2nd digit print
  1911  e7d8 48                 	pha			; save first digit-10
  1912  e7d9 8a                 	txa
  1913  e7da 20d2ff             	jsr bsout		; print second digit
  1914  e7dd 68                 	pla			; restore first digit-10
  1915                          ; print key string
  1916  e7de 20d2ff             nosec:	jsr bsout		; print first digit
  1917  e7e1 a000               	ldy #0			; init string position counter
  1918  e7e3 a92c               	lda #','		; for comma print
  1919  e7e5 20d2ff             lstk20:	jsr bsout		; print char - comma or plus-sign
  1920  e7e8 a207               	ldx #7			; for chr$ printing - no plus-sign or quote to preceed
  1921  e7ea 2067e2             txtprt:	jsr pagkey		; make sure function key ram page (indirect segment)
  1922  e7ed b1c2               	lda (keypnt),y		; get byte
  1923  e7ef 207ce2             	jsr pagres		; restore ram page (indirect segment)
  1924  e7f2 c90d               	cmp #13
  1925  e7f4 f031               	beq lstkcr		; print chr$(13) for return
  1926  e7f6 c98d               	cmp #141
  1927  e7f8 f030               	beq lstksc		; print chr$(141) for shift-return
  1928  e7fa c922               	cmp #34
  1929  e7fc f02f               	beq lstkqt		; print chr$(34) for quote
  1930  e7fe e009               	cpx #9			; was a normal char printed last time
  1931  e800 f007               	beq lstk10		; yes - skip ahead
  1932  e802 48                 	pha			; save char
  1933  e803 a922               	lda #$22
  1934  e805 20d2ff             	jsr bsout		; print a quote
  1935  e808 68                 	pla			; restore the char
  1936                          
  1937  e809 20d2ff             lstk10:	jsr bsout		; print the char
  1938  e80c a209               	ldx #9			; for chr$ - print quote and plus next time
  1939  e80e c8                 	iny
  1940  e80f cc8903             	cpy keyidx
  1941  e812 d0d6               	bne txtprt		; loop to end of string
  1942                          
  1943  e814 a922               	lda #$22
  1944  e816 20d2ff             	jsr bsout		; print ending quote
  1945                          
  1946  e819 a90d               lstk30:	lda #$0D
  1947  e81b 20d2ff             	jsr bsout		; do a return
  1948                          
  1949  e81e a4d9               nodefn:	ldy sedt1		; get key number
  1950  e820 c014               	cpy #pgmkys
  1951  e822 d086               	bne listlp		; loop til all keys checked
  1952                          
  1953  e824 58                 	cli			; all done...clear the keyscan holdoff
  1954  e825 18                 	clc			; okay return always
  1955  e826 60                 	rts
  1956                          
  1957  e827 a20a               lstkcr:	ldx #qtword-cdword-1	; index for return
  1958  e829 2c                 	!byte $2c		; skip 2
  1959  e82a a213               lstksc:	ldx #addkey-cdword-1	; index for shifted-return
  1960  e82c 2c                 	!byte $2c		; skip 2
  1961  e82d a20e               lstkqt:	ldx #scword-cdword-1	; index for quote
  1962                          
  1963  e82f 8a                 lstk:	txa			; save value index....
  1964  e830 48                 	pha			; save .x
  1965  e831 a206               	ldx #crword-cdword-1	; print chr$(
  1966  e833 bd50e8             lstklp:	lda cdword,x		; print loop
  1967  e836 f00a               	beq lstk40		; zero is end...
  1968  e838 20d2ff             	jsr bsout
  1969  e83b ca                 	dex
  1970  e83c 10f5               	bpl lstklp
  1971                          
  1972  e83e 68                 	pla			; move number and repeat
  1973  e83f aa                 	tax
  1974  e840 d0f1               	bne lstklp		; loop again for 'xxx)' ending part
  1975                          
  1976  e842 c8                 lstk40:	iny
  1977  e843 cc8903             	cpy keyidx
  1978  e846 f0d1               	beq lstk30		; exit if all string printed
  1979  e848 a92b               	lda #'+'		; set to print plus sign
  1980  e84a d099               	bne lstk20		; return to routine
  1981                          
  1982  e84c 2059454b           keword:	!pet " yek"
  1983  e850 28245248432b22     cdword:	!pet "($rhc+",$22
  1984  e857 00293331           crword:	!pet 0,")31"
  1985  e85b 00293433           qtword:	!pet 0,")43"
  1986  e85f 0029313431         scword:	!pet 0,")141"
  1987                          
  1988                          ; insert a new key defintion
  1989  e864 48                 addkey:	pha			; save zero page address of params
  1990  e865 aa                 	tax
  1991  e866 84d9               	sty sedt1		; save key number in temp loc
  1992  e868 b500               	lda $0,x		; get new string length
  1993  e86a 38                 	sec
  1994  e86b f98d03             	sbc keysiz,y		; subtract old length
  1995  e86e 85da               	sta sedt2		; save difference in temp location
  1996  e870 6e8803             	ror fktmp		; save the carry
  1997  e873 c8                 	iny
  1998  e874 2015ea             	jsr findky		; find start addr of next function key
  1999  e877 85c4               	sta sedsal
  2000  e879 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  2001  e87b a014               	ldy #pgmkys
  2002  e87d 2015ea             	jsr findky		; find end of last function key
  2003  e880 85c6               	sta sedeal
  2004  e882 86c7               	stx sedeal+1		; save next free byte addr in temp loc
  2005  e884 ac8803             	ldy fktmp		; check if new string is longer or shorter
  2006  e887 1013               	bpl keysho		; skip ahead if shorter
  2007  e889 18                 	clc
  2008  e88a ed8003             	sbc pkyend		; subtract last available adress
  2009  e88d a8                 	tay
  2010  e88e 8a                 	txa
  2011  e88f ed8103             	sbc pkyend+1
  2012  e892 aa                 	tax
  2013  e893 98                 	tya
  2014  e894 18                 	clc
  2015  e895 65da               	adc sedt2		; add difference
  2016  e897 8a                 	txa
  2017  e898 6900               	adc #0
  2018  e89a b06c               	bcs kyxit		; exit if no room, skip if memory not full
  2019                          
  2020                          ; expand or contract key area to make room for new key definition.
  2021  e89c 2067e2             keysho:	jsr pagkey		; set up function key ram page (indirect segment)
  2022  e89f a5c6               kymove:	lda sedeal
  2023  e8a1 18                 	clc			; check if entire area expanded or contracted
  2024  e8a2 e5c4               	sbc sedsal
  2025  e8a4 a5c7               	lda sedeal+1
  2026  e8a6 e5c5               	sbc sedsal+1
  2027  e8a8 902a               	bcc keyins		; go insert new key defintion if yes
  2028  e8aa a000               	ldy #0
  2029  e8ac ad8803             	lda fktmp		; check if expand or contract
  2030  e8af 1011               	bpl kshort		; skip if needs to be contracted
  2031                          
  2032  e8b1 a5c6               	lda sedeal
  2033  e8b3 d002               	bne newky4		; dec 1 from source addr
  2034  e8b5 c6c7               	dec sedeal+1		; sub 1 for borrow
  2035  e8b7 c6c6               newky4:	dec sedeal
  2036  e8b9 b1c6               	lda (sedeal),y		; move 1 byte up to expand
  2037  e8bb a4da               	ldy sedt2		; get offset = difference
  2038  e8bd 91c6               	sta (sedeal),y		; move byte up
  2039  e8bf 4c9fe8             	jmp kymove		; loop until all bytes moved
  2040                          
  2041  e8c2 b1c4               kshort:	lda (sedsal),y		; get source byte
  2042  e8c4 a4da               	ldy sedt2		; get offset = difference
  2043  e8c6 c6c5               	dec sedsal+1		; sub 1 to move down
  2044  e8c8 91c4               	sta (sedsal),y		; move the byte down
  2045  e8ca e6c5               	inc sedsal+1
  2046  e8cc e6c4               	inc sedsal		; move source up 1 byte
  2047  e8ce d0cf               	bne kymove
  2048  e8d0 e6c5               	inc sedsal+1		; add 1 for carry
  2049  e8d2 d0cb               	bne kymove		; always
  2050                          ; insert the new string defintion
  2051  e8d4 a4d9               keyins:	ldy sedt1		; get the key index
  2052  e8d6 2015ea             	jsr findky		; find buffer start address for this key
  2053  e8d9 85c4               	sta sedsal
  2054  e8db 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  2055  e8dd a4d9               	ldy sedt1
  2056  e8df 68                 	pla
  2057  e8e0 48                 	pha
  2058  e8e1 aa                 	tax			; get zero page addr of params
  2059  e8e2 b500               	lda $0,x
  2060  e8e4 998d03             	sta keysiz,y		; save key length
  2061  e8e7 a8                 	tay
  2062  e8e8 f01a               	beq kyinok		; equal to zero no keys...exit
  2063  e8ea b501               	lda $1,x		; get & save low byte of string address
  2064  e8ec 85c6               	sta sedeal
  2065  e8ee b502               	lda $2,x		; get & save high byte of string address
  2066  e8f0 85c7               	sta sedeal+1
  2067                          
  2068  e8f2 88                 kyinlp:	dey
  2069  e8f3 b503               	lda $3,x		; get string ram page
  2070  e8f5 8501               	sta i6509
  2071  e8f7 b1c6               	lda (sedeal),y		; get byte
  2072  e8f9 207ce2             	jsr pagres		; restore ram page (indirect segment)
  2073  e8fc 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
  2074  e8ff 91c4               	sta (sedsal),y		; store into buffer
  2075  e901 98                 	tya			; .y flags...end?
  2076  e902 d0ee               	bne kyinlp		; no... loop
  2077                          
  2078  e904 207ce2             kyinok:	jsr pagres		; restore ram page (indirect segment)
  2079  e907 18                 	clc			; for good exit carry clear
  2080  e908 68                 kyxit:	pla			; pop zero page address for params
  2081  e909 58                 	cli			; all done...release keyscan
  2082  e90a 60                 	rts			; c-set is memory full error
  2083                          } else{			; ********* OLD version without chr$(141) and sei/cli
  2084                          ; -------------------------------------------------------------------------------------------------
  2085                          ; E7A0 Not used - removed in patch 3
  2086                          unused:	lda unknwn		; ($03BF)
  2087                          	eor #$C0
  2088                          	sta unknwn
  2089                          	rts
  2090                          ; -------------------------------------------------------------------------------------------------
  2091                          ;******************************************
  2092                          ; E7A9 Programmable key functions
  2093                          ;******************************************
  2094                          keyfun:	dey
  2095                          	bmi listky		; do list if no parameters given
  2096                          	jmp addkey		; - else go add a new key definition
  2097                          ; List function keys
  2098                          listky:	ldy #0			; initialize key counter
  2099                          
  2100                          listlp: iny
  2101                          	sty sedt1
  2102                          	dey			; minus 1 for indexing
  2103                          	lda keysiz,y		; get key length
  2104                          	beq nodefn		; no listing if no defintion
  2105                          	sta keyidx		; save key length
  2106                          	jsr findky		; get buffer start addr for function key
  2107                          	sta keypnt
  2108                          	stx keypnt+1		; save 2 byte address in temp loc
  2109                          	ldx #3
  2110                          ; print 'key ' preamble
  2111                          preamb: lda keword,x
  2112                          	jsr jbsout
  2113                          	dex
  2114                          	bpl preamb
  2115                          ; convert to 1 or 2 digit ascii
  2116                          	ldx #$2F
  2117                          	lda sedt1		; get key number
  2118                          	sec
  2119                          ky2asc: inx			; .x=$30, if two digits it will inc to $31
  2120                          	sbc #10
  2121                          	bcs ky2asc		; repeat if >9
  2122                          	adc #$3A		; add 10 & make ascii
  2123                          	cpx #'0'
  2124                          	beq nosec		; skip 2nd digit print
  2125                          	pha			; save first digit-10
  2126                          	txa
  2127                          	jsr jbsout		; print second digit '1'
  2128                          	pla			; restore first digit-10
  2129                          
  2130                          nosec:  jsr jbsout		; print first digit
  2131                          	ldy #0			; init string position counter
  2132                          	lda #','		; for comma print
  2133                          	ldx #6
  2134                          txtprt:	cpx #8
  2135                          	beq lstk00		; skip if normal char last time
  2136                          	jsr jbsout		; print char - comma or plus-sign
  2137                          lstk00:	php
  2138                          	jsr pagkey		; set up function key ram page (indirect segment)
  2139                          	lda (keypnt),y		; get byte
  2140                          	jsr pagres		; restore ram page (indirect segment)
  2141                          	plp
  2142                          	cmp #$0D
  2143                          	beq lstkcr		; print chr$(13) for return
  2144                          	cmp #$8D
  2145                          	beq lstkcr		; print chr$(13) for shift-return
  2146                          	cmp #$22
  2147                          	beq lstkqt		; print chr$(34) for quote
  2148                          	cpx #8			; was a normal char printed last time
  2149                          	beq lstk10		; yes - skip ahead
  2150                          	pha			; save char
  2151                          	lda #$22
  2152                          	jsr jbsout		; print a quote
  2153                          	pla
  2154                          	ldx #8			; skip next print at loop start
  2155                          lstk10: jsr jbsout		; print char
  2156                          	lda #'+'
  2157                          	iny
  2158                          	cpy keyidx
  2159                          	bne txtprt		; loop to end of string
  2160                          
  2161                          	cpx #6
  2162                          	beq lstk30
  2163                          	lda #$22
  2164                          	jsr jbsout		; print ending quote
  2165                          
  2166                          lstk30: lda #$0D
  2167                          	jsr jbsout		; do a return
  2168                          
  2169                          nodefn: ldy sedt1		; get key number
  2170                          	cpy #pgmkys
  2171                          	beq listx		; exit if finished list
  2172                          	jmp listlp		; print next key definition
  2173                          
  2174                          listx:	clc
  2175                          	rts
  2176                          ; E83C
  2177                          lstkcr:	clc
  2178                          lstklp:	lda crword,x		; load chr$(13 string
  2179                          lstkqt:	bcc lstk40
  2180                          	lda qtword,x		; load chr$(34 string
  2181                          lstk40:	php			; preserce carry flag for string selection
  2182                          	jsr jbsout
  2183                          	plp
  2184                          	dex
  2185                          	bpl lstklp		; next char
  2186                          
  2187                          	lda #')' 
  2188                          	ldx #6			; mark to print ')' at loop start
  2189                          	bne lstk10
  2190                          ; Jump vector: bsout via indirect vector
  2191                          jbsout:	jmp (ibsout)
  2192                          ; -------------------------------------------------------------------------------------------------
  2193                          ; E856 
  2194                          keword: !pet " yek"		; 'key '
  2195                          crword: !pet "31($rhc+", $22	; "+chr$(13
  2196                          qtword: !pet "43($rhc+", $22	; "+chr$(34
  2197                          ; -------------------------------------------------------------------------------------------------
  2198                          ; E86C Insert a new key defintion
  2199                          addkey: pha			; save zero page address of params
  2200                          	tax
  2201                          	sty sedt1		; save key number in temp loc
  2202                          	lda $00,x		; get new string length
  2203                          	sec
  2204                          	sbc keysiz,y		; subtract old length
  2205                          	sta sedt2		; save difference in temp location
  2206                          	iny
  2207                          	jsr findky		; find start addr of next function key
  2208                          	sta sedsal
  2209                          	stx sedsal+1		; save 2 byte address in temp loc
  2210                          	ldy #pgmkys
  2211                          	jsr findky		; find end of last function key
  2212                          	sta sedeal
  2213                          	stx sedeal+1		; save next free byte addr in temp loc
  2214                          	ldy sedt2		; load difference
  2215                          	bmi keysho		; skip ahead if old key shorter
  2216                          	clc
  2217                          	sbc pkyend		; subtract last available adress
  2218                          	tay
  2219                          	txa
  2220                          	sbc pkyend+1
  2221                          	tax
  2222                          	tya
  2223                          	clc
  2224                          	adc sedt2		; add difference
  2225                          	txa
  2226                          	adc #0			; add carry
  2227                          	bcc keysho		; make room for definition
  2228                          	pla
  2229                          	rts			; exit if no room
  2230                          ; E8A2 expand or contract key area to make room for new key definition.
  2231                          keysho: jsr pagkey		; set up function key ram page (indirect segment)
  2232                          kymove: lda sedeal
  2233                          	clc 			; check if entire area expanded or contracted
  2234                          	sbc sedsal
  2235                          	lda sedeal+1
  2236                          	sbc sedsal+1
  2237                          	bcc keyins		; go insert new key defintion if yes
  2238                          	ldy #0
  2239                          	lda sedt2		; check if expand or contract
  2240                          	bmi kshort		; skip if needs to be contracted
  2241                          
  2242                          	lda sedeal
  2243                          	bne newky4		; dec 1 from source addr
  2244                          	dec sedeal+1		; sub 1 for borrow
  2245                          newky4: dec sedeal
  2246                          	lda (sedeal),y		; move 1 byte up to expand
  2247                          	ldy sedt2		; get offset = difference
  2248                          	sta (sedeal),y		; move byte up
  2249                          	bpl kymove		; loop until all bytes moved
  2250                          
  2251                          kshort:	lda (sedsal),y		; get source byte
  2252                          	ldy sedt2		; get offset = difference
  2253                          	dec sedsal+1		; sub 1 to move down
  2254                          	sta (sedsal),y		; move the byte down
  2255                          	inc sedsal+1
  2256                          	inc sedsal		; move source up 1 byte
  2257                          	bne kymove
  2258                          	inc sedsal+1		; add 1 for carry
  2259                          	bne kymove		; always
  2260                          ;  insert the new string defintion
  2261                          keyins: ldy sedt1		; get the key index
  2262                          	jsr findky		; find buffer start address for this key
  2263                          	sta sedsal
  2264                          	stx sedsal+1		; save 2 byte address in temp loc
  2265                          	ldy sedt1
  2266                          	pla
  2267                          	tax			; get zero page addr of params
  2268                          	lda $00,x
  2269                          	sta keysiz,y		; save key length
  2270                          	tay
  2271                          	lda $01,x		; get & save low byte of string address
  2272                          	sta sedeal
  2273                          	lda $02,x		; get & save high byte of string address
  2274                          	sta sedeal+1
  2275                          
  2276                          kyinlp: dey 
  2277                          	bmi kyinok
  2278                          	lda $03,x		; get string ram bank
  2279                          	sta i6509
  2280                          	lda (sedeal),y		; get byte
  2281                          	jsr pagres		; restore ram page (indirect segment)
  2282                          	jsr pagkey		; set up function key ram page (indirect segment)
  2283                          	sta (sedsal),y		; store into buffer
  2284                          	jmp kyinlp		; next 
  2285                          
  2286                          kyinok: jsr pagres    		; restore indirect bank
  2287                          	clc 			; for good exit carry clear
  2288                          	rts
  2289                          }
  2290                          *= $E90C
  2291                          ; -------------------------------------------------------------------------------------------------
  2292                          ;*******************************
  2293                          ; E90C Keyboard scanner
  2294                          ;*******************************
  2295                          ; Cursor blink routine
  2296  e90c 206ce6             scnkey: jsr junkwn2		; vector -> nofunc (rts)
  2297  e90f a5e6               	lda blnon
  2298  e911 d020               	bne key			; skip if blinking cursor is off (run mode)
  2299                          
  2300                          !ifdef SOLID_CURSOR{		; ********** Solid cursor patch ***********
  2301                          	lda blnsw
  2302                          	bne key			; skip if cursor already visible
  2303                          	
  2304                          	inc blnsw		; set visibility switch
  2305                          	jsr get1ch		; get char and color under cursor
  2306                          	ldx gdcol
  2307                          	sta config		; remember char under cursor
  2308                          	ldx tcolor
  2309                          	stx gdcol		; remember char color
  2310                          	ldx color		; load actual color
  2311                          scnk10:	eor #$80		; inverse char
  2312                          	jsr dspp		; print (reversed) char
  2313                          	jmp key
  2314                          } else{				; ********** Blinking standard cursor **********
  2315  e913 c6e7               	dec blncnt
  2316  e915 d01c               	bne key			; skip if blink counter not zero
  2317  e917 a914               	lda #20
  2318  e919 85e7               	sta blncnt		; reset blink counter
  2319  e91b 203fe2             	jsr get1ch		; get char and color under cursor
  2320  e91e a6ed               	ldx gdcol
  2321  e920 46eb               	lsr blnsw		; reset blink switch
  2322  e922 b00a               	bcs scnk10		; if cursor is off -> reverse char
  2323  e924 e6eb               	inc blnsw		; set blink switch
  2324  e926 85d4               	sta config		; remember char under cursor
  2325  e928 a6ea               	ldx tcolor
  2326  e92a 86ed               	stx gdcol		; remember char color
  2327  e92c a6ec               	ldx color		; load actual color
  2328  e92e 4980               scnk10:	eor #$80		; inverse char
  2329  e930 2013e2             	jsr dspp		; print (reversed) char
  2330                          }
  2331                          *= $E933
  2332                          ; E933 Keyboard scanner
  2333  e933 a0ff               key:    ldy #$FF		; say no keys pressed (real-time keyscan)
  2334  e935 84e0               	sty modkey
  2335  e937 84e1               	sty norkey
  2336  e939 c8                 	iny			; init base kybd index = 0
  2337  e93a 8c01df             	sty tpi2+pb		; allow all output lines
  2338  e93d 8c00df             	sty tpi2+pa
  2339  e940 20eae9             	jsr getkey		; get keybd input
  2340  e943 293f               	and #$3F		; check if any inputs
  2341  e945 493f               	eor #$3F
  2342  e947 f076               	beq nulxit		; exit if none
  2343  e949 a9ff               	lda #$FF
  2344  e94b 8d00df             	sta tpi2+pa		; allow only output line 0
  2345  e94e 0a                 	asl
  2346  e94f 8d01df             	sta tpi2+pb
  2347  e952 20eae9             	jsr getkey		; get input from line 0
  2348  e955 48                 	pha			; save shift & control bits
  2349  e956 85e0               	sta modkey		; shift keys are down
  2350  e958 0930               	ora #$30		; mask them by setting bits
  2351  e95a d003               	bne line01
  2352                          
  2353  e95c 20eae9             linelp: jsr getkey		; get line inputs
  2354  e95f a205               line01: ldx #5			; loop for 6 input lines
  2355  e961 4a                 kyloop: lsr			; check line
  2356  e962 9010               	bcc havkey		; skip ahead if have input
  2357  e964 c8                 	iny			; inc keyd code count
  2358  e965 ca                 	dex
  2359  e966 10f9               	bpl kyloop
  2360                          
  2361  e968 38                 	sec
  2362  e969 2e01df             	rol tpi2+pb		; rotate to activate next
  2363  e96c 2e00df             	rol tpi2+pa		; - output line
  2364  e96f b0eb               	bcs linelp		; loop until all lines done
  2365                          
  2366  e971 68                 	pla			; clear shift/control byte
  2367  e972 904b               	bcc nulxit		; exit if no key
  2368                          ; get pet-ascii using keyboard index and shift and control inputs
  2369  e974 beb1ea             havkey: ldx normtb,y
  2370  e977 84e1               	sty norkey		; have a normal keypress
  2371  e979 68                 	pla			; get shift/control byte
  2372  e97a 0a                 	asl
  2373  e97b 0a                 	asl			; move bits left
  2374  e97c 0a                 	asl
  2375  e97d 900e               	bcc doctl		; skip ahead if control depressed
  2376  e97f 300f               	bmi havasc		; skip ahead if not shifted - have ascii
  2377  e981 be11eb             	ldx shfttb,y		; assume shited textual
  2378  e984 a5cc               	lda grmode		; test text or graphic mode
  2379  e986 d008               	bne havasc		; have key if text mode
  2380  e988 be71eb             	ldx shftgr,y		; get shifted graphic
  2381  e98b d003               	bne havasc		; go process ascii key
  2382                          
  2383  e98d bed1eb             doctl:	ldx ctltbl,y		; get pet-ascii char for this key
  2384                          ; y-reg has keyboard index value
  2385                          ; x-reg has pet-ascii value
  2386  e990 e0ff               havasc: cpx #$FF
  2387  e992 f02d               	beq keyxit		; exit if null pet-ascii
  2388  e994 8a                 	txa
  2389  e995 c9e0               	cmp #$E0		; check if function key
  2390  e997 9009               	bcc notfun		; skip - not a function key
  2391  e999 98                 	tya
  2392  e99a 48                 	pha
  2393  e99b 20f3e9             	jsr funjmp		; do function key indirect
  2394  e99e 68                 	pla
  2395  e99f a8                 	tay
  2396  e9a0 b01f               	bcs keyxit		; done if carry flag set
  2397                          ; E9A2 Not a function key
  2398  e9a2 8a                 notfun: txa			; get pet-ascii code
  2399  e9a3 c4cd               	cpy lstx		; check if same key as last
  2400                          ; Time through
  2401  e9a5 f027               	beq dorpt		; skip ahead if so
  2402                          ; A new key input - check queue availability
  2403  e9a7 a213               	ldx #19
  2404  e9a9 86d8               	stx delay		; reset initial delay count
  2405  e9ab a6d1               	ldx ndx			; get key-in queue size
  2406  e9ad e009               	cpx #keymax		; check if queue full
  2407  e9af f00e               	beq nulxit		; exit if yes
  2408  e9b1 c059               	cpy #dblzer		; check if keypad - 00
  2409  e9b3 d029               	bne savkey		; go save key-in if not
  2410  e9b5 e008               	cpx #keymax-1		; check if room for two
  2411  e9b7 f006               	beq nulxit		; exit if not
  2412  e9b9 9dab03             	sta keyd,x		; save first zero
  2413  e9bc e8                 	inx			; update queue size
  2414  e9bd d01f               	bne savkey		; always
  2415                          
  2416  e9bf a0ff               nulxit: ldy #$FF
  2417  e9c1 84cd               keyxit: sty lstx		; save last key number
  2418  e9c3 a27f               keyxt2: ldx #$7F
  2419  e9c5 8e00df             	stx tpi2+pa		; reset output lines to allow
  2420  e9c8 a2ff               	ldx #$FF		; - stop key input
  2421  e9ca 8e01df             	stx tpi2+pb
  2422  e9cd 60                 	rts
  2423                          
  2424                          ; E9CE Check repeat delays
  2425  e9ce c6d8               dorpt:  dec delay		; dec initial delay count
  2426  e9d0 10f1               	bpl keyxt2		; exit if was not zero - still on 1st delay
  2427  e9d2 e6d8               	inc delay		; - else reset count to zero
  2428                          
  2429                          ; Check if secondary count down to zero
  2430  e9d4 c6d7               	dec rptcnt		; dec repeat btwn keys
  2431  e9d6 10eb               	bpl keyxt2		; exit if was not zero - still on delay
  2432  e9d8 e6d7               	inc rptcnt		; reset back to zero
  2433                          
  2434                          ; Time to repeat - check if key queue empty
  2435  e9da a6d1               	ldx ndx			; get kybd queue size
  2436  e9dc d0e5               	bne keyxt2		; exit if kybd queue not empty
  2437                          
  2438                          ; E9DE Save pet-ascii into key buffer
  2439  e9de 9dab03             savkey: sta keyd,x		; store pet-ascii in kybd buffer
  2440  e9e1 e8                 	inx
  2441  e9e2 86d1               	stx ndx
  2442  e9e4 a203               	ldx #3
  2443  e9e6 86d7               	stx rptcnt		; reset delay btwn keys
  2444  e9e8 d0d7               	bne keyxit
  2445                          ; E9EA Read keyboard matrix and debounce
  2446  e9ea ad02df             getkey: lda tpi2+pc		; debounce keyboard input
  2447  e9ed cd02df             	cmp tpi2+pc
  2448  e9f0 d0f8               	bne getkey
  2449  e9f2 60                 	rts
  2450                          ; -------------------------------------------------------------------------------------------------
  2451                          ; E9F3 Jump vector: Function key indirect
  2452  e9f3 6cb503             funjmp: jmp (funvec)
  2453                          ; -------------------------------------------------------------------------------------------------
  2454                          ; E9F6 Default function key handler
  2455  e9f6 c4cd               dokeyf: cpy lstx
  2456  e9f8 f019               	beq funrts		; exit not allowed to repeat
  2457  e9fa a5d1               	lda ndx
  2458  e9fc 05d6               	ora kyndx
  2459  e9fe d013               	bne funrts		; exit - function queue not empty
  2460  ea00 8d8903             	sta keyidx		; init pointer index into function area
  2461  ea03 8a                 	txa
  2462  ea04 291f               	and #$1F		; mask out to get function key number
  2463  ea06 a8                 	tay
  2464  ea07 b98d03             	lda keysiz,y		; get function key size
  2465  ea0a 85d6               	sta kyndx		; - and store it for key scan
  2466  ea0c 2015ea             	jsr findky
  2467  ea0f 85c2               	sta keypnt		; get function start addr
  2468  ea11 86c3               	stx keypnt+1		; - and save in keypnt
  2469                          
  2470  ea13 38                 funrts: sec
  2471  ea14 60                 	rts
  2472                          ; -------------------------------------------------------------------------------------------------
  2473                          ; EA15 Find address of function key given in y-reg
  2474  ea15 a5c0               findky: lda pkybuf
  2475  ea17 a6c1               	ldx pkybuf+1
  2476                          
  2477  ea19 18                 findlp: clc
  2478  ea1a 88                 	dey			; found key yet?
  2479  ea1b 3008               	bmi fndout		; yes - done
  2480  ea1d 798d03             	adc keysiz,y		; add function key size
  2481  ea20 90f7               	bcc findlp		; loop if no high byte carry-over
  2482  ea22 e8                 	inx
  2483  ea23 d0f4               	bne findlp		; loop - always
  2484                          
  2485  ea25 60                 fndout: rts
  2486                          ; -------------------------------------------------------------------------------------------------
  2487                          ; EA26 Tab set-up (tab positioner)
  2488                          ;   y=column in question
  2489  ea26 98                 gettab: tya			; get bit in question
  2490  ea27 2907               	and #$07
  2491  ea29 aa                 	tax
  2492  ea2a bdefec             	lda bits,x
  2493  ea2d 8d8803             	sta bitmsk
  2494  ea30 98                 	tya			; get 8 bit block
  2495  ea31 4a                 	lsr
  2496  ea32 4a                 	lsr
  2497  ea33 4a                 	lsr
  2498  ea34 aa                 	tax
  2499  ea35 bda103             	lda tab,x
  2500  ea38 2c8803             	bit bitmsk		; set equal flag
  2501  ea3b 60                 	rts
  2502                          ; -------------------------------------------------------------------------------------------------
  2503                          ;************************************************************
  2504                          ;*  routines involved in executing escape functions
  2505                          ;************************************************************
  2506                          ; EA3C Main escape sequence handler
  2507                          ;   entry: character following escape character in acc.
  2508  ea3c 297f               escape: and #$7F
  2509  ea3e 38                 	sec
  2510  ea3f e941               	sbc #'a'		; table begins at ascii a
  2511  ea41 c91a               	cmp #$1A		; 'z'-'a'+1
  2512  ea43 9001               	bcc escgo		; valid char, go get address
  2513  ea45 60                 escrts:	rts			; failed to find entry...ignore it!
  2514                          ; -------------------------------------------------------------------------------------------------
  2515                          ; EA46 Get address of escape routine, and go to it.
  2516  ea46 0a                 escgo:  asl			; multiply index by 2
  2517  ea47 aa                 	tax
  2518  ea48 bd52ea             	lda escvct+1,x		; get high byte
  2519  ea4b 48                 	pha
  2520  ea4c bd51ea             	lda escvct,x		; and low
  2521  ea4f 48                 	pha
  2522  ea50 60                 	rts			; and go to that address
  2523                          ; -------------------------------------------------------------------------------------------------
  2524                          ; EA51 Escape sequence table
  2525  ea51 aaea               escvct:	!word auton-1		; a Auto insert
  2526  ea53 86ea               	!word sethtb-1		; b set bottom
  2527  ea55 a7ea               	!word autoff-1		; c cancel auto insert
  2528  ea57 f7e6               	!word dline-1		; d Delete line
  2529  ea59 a6ea               	!word notimp-1		; e
  2530  ea5b a6ea               	!word notimp-1		; f
  2531  ea5d a1ea               	!word bellon-1		; g enable bell
  2532  ea5f a3ea               	!word bellof-1		; h disable bell
  2533  ea61 e0e6               	!word iline-1		; i Insert line
  2534  ea63 e4e4               	!word fndfst-1		; j Move to start of line
  2535  ea65 f6e4               	!word fndend-1		; k Move to end of line
  2536  ea67 7ee7               	!word scrsw0-1		; l enable scrolling
  2537  ea69 81e7               	!word scrsw1-1		; m disable scrolling
  2538  ea6b a6ea               	!word notimp-1		; n
  2539  ea6d 71e7               	!word toqm-1		; o cancel insert, quote and reverse
  2540  ea6f 20e7               	!word etosol-1		; p Erase to start of line
  2541  ea71 1ee7               	!word etoeol-1		; q Erase to end of line
  2542  ea73 a6ea               	!word notimp-1		; r
  2543  ea75 a6ea               	!word notimp-1		; s
  2544  ea77 84ea               	!word sethtt-1		; t Set top left of page
  2545  ea79 a6ea               	!word notimp-1		; u
  2546  ea7b 49e7               	!word esuup-1		; v Scroll up
  2547  ea7d 4be7               	!word esddn-1		; w Scroll down
  2548  ea7f 44ea               	!word escrts-1		; x cancel esacpe sequence
  2549  ea81 a6ea               	!word notimp-1		; y
  2550  ea83 a6ea               	!word notimp-1		; z
  2551                          ; -------------------------------------------------------------------------------------------------
  2552                          ; EA85 Set top left window corner (esc-t)
  2553  ea85 18                 sethtt: clc			; set upper left corner with C=0
  2554  ea86 24                 	!byte $24		; skip next instruction with bit $xx
  2555                          ; EA87 Set bottom right window corner (esc-b)
  2556  ea87 38                 sethtb: sec			; set lower right corner with C=1
  2557  ea88 a6cb               window: ldx pntr		; load cursor column
  2558  ea8a a5ca               	lda tblx		; load cursour row
  2559  ea8c 900f               	bcc settps		; set upper left corner if C=0
  2560  ea8e 85dd               setbts: sta scbot		; store last row
  2561  ea90 86df               	stx scrt		; store last column
  2562  ea92 60                 	rts
  2563                          ; -------------------------------------------------------------------------------------------------
  2564                          ; EA93 Set full screen window
  2565  ea93 a918               sreset: lda #scymax		; load last row, column of screen
  2566  ea95 a227               	ldx #scxmax
  2567  ea97 208eea             	jsr setbts		; set lower right corner
  2568  ea9a a900               	lda #0			; clear A, X to first row, column
  2569  ea9c aa                 	tax
  2570  ea9d 85dc               settps: sta sctop		; set first row
  2571  ea9f 86de               	stx sclf		; set first column
  2572  eaa1 60                 	rts
  2573                          ; -------------------------------------------------------------------------------------------------
  2574                          ; EAA2 Bell on (esc-g)
  2575  eaa2 a900               bellon: lda #0			; $00 = bell on
  2576                          ; EAA4 Bell off (esc-h)
  2577  eaa4 8d8b03             bellof:sta bellmd		; store bell flag - any value = bell off
  2578                          ; EAA7 Not implemented escape sequences jump here
  2579  eaa7 60                 notimp: rts
  2580                          ; -------------------------------------------------------------------------------------------------
  2581                          ; EAA8 Auto insert mode off (esc-c)
  2582  eaa8 a900               autoff: lda #$00
  2583  eaaa 2c                 	!byte $2C		; skips next instruction
  2584                          ; EAAB Auto insert mode on (esc-a)
  2585  eaab a9ff               auton:  lda #$FF
  2586  eaad 8d8603             	sta insflg
  2587  eab0 60                 	rts
  2588                          ; -------------------------------------------------------------------------------------------------
  2589                          ; EAB1 Keyboard tables
  2590                          normtb:					; keyboard table - no control/no shift
  2591                          	;line 0: f1, escape, tab, null, shift, control
  2592  eab1 e01b09ff0001       	 !byte $e0,$1b,$09,$ff,$00,$01
  2593                          	;line 1: f2, 1, q, a, z, null
  2594  eab7 e13151415aff       	 !byte $e1,$31,$51,$41,$5a,$ff
  2595                          	;line 2: f3, 2, w, s, x, c
  2596  eabd e23257535843       	 !byte $e2,$32,$57,$53,$58,$43
  2597                          	;line 3: f4, 3, e, d, f, v
  2598  eac3 e33345444656       	 !byte $e3,$33,$45,$44,$46,$56
  2599                          	;line 4: f5, 4, r, t, g, b
  2600  eac9 e43452544742       	 !byte $e4,$34,$52,$54,$47,$42
  2601                          	;line 5: f6, 5, 6, y, h, n
  2602  eacf e5353659484e       	 !byte $e5,$35,$36,$59,$48,$4e
  2603                          	;line 6: f7, 7, u, j, m, space
  2604  ead5 e637554a4d20       	 !byte $e6,$37,$55,$4a,$4d,$20
  2605                          	;line 7: f8, 8, i, k, "," , .
  2606  eadb e738494b2c2e       	 !byte $e7,$38,$49,$4b,$2c,$2e
  2607                          	;line 8: f9, 9, o, l, ;, /
  2608  eae1 e8394f4c3b2f       	 !byte $e8,$39,$4f,$4c,$3b,$2f
  2609                          	;line 9: f10, 0, -, p, [, '
  2610  eae7 e9302d505b27       	 !byte $e9,$30,$2d,$50,$5b,$27
  2611                          	;line 10: down cursor, =, _, ], return, pi
  2612  eaed 113d5f5d0dde       	 !byte $11,$3d,$5f,$5d,$0d,$de
  2613                          	;line 11: up cur, lt cur, rt cur, del, cmdr, null
  2614  eaf3 919d1d1402ff       	 !byte $91,$9d,$1d,$14,$02,$ff
  2615                          	;line 12: home, ?, 7, 4, 1, 0
  2616  eaf9 133f37343130       	 !byte $13,$3f,$37,$34,$31,$30
  2617                          	;line 13: rvs on, cancel, 8, 5, 2, decimal point
  2618  eaff 12043835322e       	 !byte $12,$04,$38,$35,$32,$2e
  2619                          	;line 14: graphic, mult, 9, 6, 3, 00
  2620  eb05 8e2a39363330       	 !byte $8e,$2a,$39,$36,$33,$30
  2621                          	;line 15: stop, div, subtr, add, enter, null
  2622  eb0b 032f2d2b0dff       	 !byte $03,$2f,$2d,$2b,$0d,$ff
  2623                          
  2624                          shfttb:					; keyboard table - shift only & text mode
  2625                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2626  eb11 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2627                          	;line 1: f12, !, q, a, z, null
  2628  eb17 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2629                          	;line 2: f13, @, w, s, x, c
  2630  eb1d ec40d7d3d8c3       	 !byte $ec,$40,$d7,$d3,$d8,$c3
  2631                          	;line 3: f14, #, e, d, f, v
  2632  eb23 ed23c5c4c6d6       	 !byte $ed,$23,$c5,$c4,$c6,$d6
  2633                          	;line 4: f15, $, r, t, g, b
  2634  eb29 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2635                          	;line 5: f16, %, ^, y, h, n
  2636  eb2f ef255ed9c8ce       	 !byte $ef,$25,$5e,$d9,$c8,$ce
  2637                          	;line 6: f17, &, u, j, m, shifted space
  2638  eb35 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2639                          	;line 7: f18, *, i, k, <, >
  2640  eb3b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2641                          	;line 8: f19, (, o, l, :, ?
  2642  eb41 f228cfcc3a3f       	 !byte $f2,$28,$cf,$cc,$3a,$3f
  2643                          	;line 9: f20, ), -, p, [, "
  2644  eb47 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2645                          	;line 10: down cursor, +, pound sign, ], sht return, pi
  2646  eb4d 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2647                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2648  eb53 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2649                          	;line 12: clear/home, ?, 7, 4, 1, 0
  2650  eb59 933f37343130       	 !byte $93,$3f,$37,$34,$31,$30
  2651                          	;line 13: rvs off, shft cancel, 8, 5, 2, decimal point
  2652  eb5f 92843835322e       	 !byte $92,$84,$38,$35,$32,$2e
  2653                          	;line 14: text, mult, 9, 6, 3, 00
  2654  eb65 0e2a39363330       	 !byte $0e,$2a,$39,$36,$33,$30
  2655                          	;line 15: run, div, subtr, add, enter, null
  2656  eb6b 832f2d2b8dff       	 !byte $83,$2f,$2d,$2b,$8d,$ff
  2657                          
  2658                          shftgr:					; keyboard table - shift only & graphic mode
  2659                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2660  eb71 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2661                          	;line 1: f12, !, gr, gr, gr, null
  2662  eb77 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2663                          	;line 2: f13, @, gr, gr, gr, gr
  2664  eb7d ec40d7d3d8c0       	 !byte $ec,$40,$d7,$d3,$d8,$c0
  2665                          	;line 3: f14, #, gr, gr, gr, gr
  2666  eb83 ed23c5c4c6c3       	 !byte $ed,$23,$c5,$c4,$c6,$c3
  2667                          	;line 4: f15, $, gr, gr, gr, gr
  2668  eb89 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2669                          	;line 5: f16, %, ^, gr, gr, gr
  2670  eb8f ef255ed9c8dd       	 !byte $ef,$25,$5e,$d9,$c8,$dd
  2671                          	;line 6: f17, &, gr, gr, gr, shifted space
  2672  eb95 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2673                          	;line 7: f18, *, gr, gr, <, >
  2674  eb9b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2675                          	;line 8: f19, (, gr, gr, :, ?
  2676  eba1 f228cfd63a3f       	 !byte $f2,$28,$cf,$d6,$3a,$3f
  2677                          	;line 9: f20, ), -, gr, [, "
  2678  eba7 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2679                          	;line 10: down cursor, +, pound, ], shifted return, pi
  2680  ebad 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2681                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2682  ebb3 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2683                          	;line 12: clear/home,gr,gr,gr,gr,gr
  2684  ebb9 93b7b4b1b0ad       	 !byte $93,$b7,$b4,$b1,$b0,$ad
  2685                          	;line 13: rvs off,gr,gr,gr,gr,gr
  2686  ebbf 92b8b5b2aebd       	 !byte $92,$b8,$b5,$b2,$ae,$bd
  2687                          	;line 14: text,gr,gr,gr,gr,00
  2688  ebc5 0eb9b6b3db30       	 !byte $0e,$b9,$b6,$b3,$db,$30
  2689                          	;line 15: run,gr,gr,gr,gr,null
  2690  ebcb 83afaaab8dff       	 !byte $83,$af,$aa,$ab,$8d,$ff
  2691                          
  2692                          ctltbl:					; keyboard table... control characters, any mode
  2693                          	;line 0: null,null,null,null,null
  2694  ebd1 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2695                          	;line 1: null,gr,q,a,z,null
  2696  ebd7 ffa111011aff       	 !byte $ff,$a1,$11,$01,$1a,$ff
  2697                          	;line 2: null,gr,w,s,x,c
  2698  ebdd ffa217131803       	 !byte $ff,$a2,$17,$13,$18,$03
  2699                          	;line 3: null,gr,e,d,f,v
  2700  ebe3 ffa305040616       	 !byte $ff,$a3,$05,$04,$06,$16
  2701                          	;line 4: null,gr,r,t,g,b
  2702  ebe9 ffa412140702       	 !byte $ff,$a4,$12,$14,$07,$02
  2703                          	;line 5: null,gr,gr,y,h,n
  2704  ebef ffa5a719080e       	 !byte $ff,$a5,$a7,$19,$08,$0e
  2705                          	;line 6: null,gr,u,j,m,null
  2706  ebf5 ffbe150a0dff       	 !byte $ff,$be,$15,$0a,$0d,$ff
  2707                          	;line 7: null,gr,i,k,gr,null
  2708  ebfb ffbb090bceff       	 !byte $ff,$bb,$09,$0b,$ce,$ff
  2709                          	;line 8: null,gr,o,l,gr,null
  2710  ec01 ffbf0f0cdcff       	 !byte $ff,$bf,$0f,$0c,$dc,$ff
  2711                          	;line 9: null,gr,gr,p,gr,gr
  2712  ec07 ffacbc10cca8       	 !byte $ff,$ac,$bc,$10,$cc,$a8
  2713                          	;line 10: null,gr,gr,gr,null,gr
  2714  ec0d ffa9dfbaffa6       	 !byte $ff,$a9,$df,$ba,$ff,$a6
  2715                          	;line 11: null,null,null,null,null,null
  2716  ec13 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2717                          	;line 12: null,lred,yell,mag,wht,blk
  2718  ec19 ff969e9c0590       	 !byte $ff,$96,$9e,$9c,$05,$90
  2719                          	;line 13: null,lblue,org,grn,red,null
  2720  ec1f ff99811e1cff       	 !byte $ff,$99,$81,$1e,$1c,$ff
  2721                          	;line 14: null,gray3,brown,blue,cyan,null
  2722  ec25 ff9a951f9fff       	 !byte $ff,$9a,$95,$1f,$9f,$ff
  2723                          	;line 15: null,gray1,gray2,purple,null,null
  2724  ec2b ff97989bffff       	 !byte $ff,$97,$98,$9b,$ff,$ff
  2725                          ; -------------------------------------------------------------------------------------------------
  2726                          ; EC31 <SHIFT> <RUN/STOP> String: DLOAD "*" + RUN
  2727  ec31 44cc222a0d         runtb:  !pet "d",$CC,$22,"*",$0D	; dL"* <RETURN>
  2728  ec36 52554e0d           	!pet "run",$0D          	; run <RETURN>
  2729                          ; -------------------------------------------------------------------------------------------------
  2730                          ;****** address of screen lines ******
  2731                          linz0	= scnram
  2732                          linz1	= linz0+llen
  2733                          linz2	= linz1+llen
  2734                          linz3	= linz2+llen
  2735                          linz4	= linz3+llen
  2736                          linz5	= linz4+llen
  2737                          linz6	= linz5+llen
  2738                          linz7	= linz6+llen
  2739                          linz8	= linz7+llen
  2740                          linz9	= linz8+llen
  2741                          linz10	= linz9+llen
  2742                          linz11	= linz10+llen
  2743                          linz12	= linz11+llen
  2744                          linz13	= linz12+llen
  2745                          linz14	= linz13+llen
  2746                          linz15	= linz14+llen
  2747                          linz16	= linz15+llen
  2748                          linz17	= linz16+llen
  2749                          linz18	= linz17+llen
  2750                          linz19	= linz18+llen
  2751                          linz20	= linz19+llen
  2752                          linz21	= linz20+llen
  2753                          linz22	= linz21+llen
  2754                          linz23	= linz22+llen
  2755                          linz24	= linz23+llen
  2756                          
  2757                          ;****** screen lines lo byte table ******
  2758  ec3a 00                 ldtb2:	!byte <linz0
  2759  ec3b 28                 	!byte <linz1
  2760  ec3c 50                 	!byte <linz2
  2761  ec3d 78                 	!byte <linz3
  2762  ec3e a0                 	!byte <linz4
  2763  ec3f c8                 	!byte <linz5
  2764  ec40 f0                 	!byte <linz6
  2765  ec41 18                 	!byte <linz7
  2766  ec42 40                 	!byte <linz8
  2767  ec43 68                 	!byte <linz9
  2768  ec44 90                 	!byte <linz10
  2769  ec45 b8                 	!byte <linz11
  2770  ec46 e0                 	!byte <linz12
  2771  ec47 08                 	!byte <linz13
  2772  ec48 30                 	!byte <linz14
  2773  ec49 58                 	!byte <linz15
  2774  ec4a 80                 	!byte <linz16
  2775  ec4b a8                 	!byte <linz17
  2776  ec4c d0                 	!byte <linz18
  2777  ec4d f8                 	!byte <linz19
  2778  ec4e 20                 	!byte <linz20
  2779  ec4f 48                 	!byte <linz21
  2780  ec50 70                 	!byte <linz22
  2781  ec51 98                 	!byte <linz23
  2782  ec52 c0                 	!byte <linz24
  2783                          
  2784                          ;****** screen lines hi byte table ******
  2785  ec53 d0                 ldtb1:	!byte >linz0
  2786  ec54 d0                 	!byte >linz1
  2787  ec55 d0                 	!byte >linz2
  2788  ec56 d0                 	!byte >linz3
  2789  ec57 d0                 	!byte >linz4
  2790  ec58 d0                 	!byte >linz5
  2791  ec59 d0                 	!byte >linz6
  2792  ec5a d1                 	!byte >linz7
  2793  ec5b d1                 	!byte >linz8
  2794  ec5c d1                 	!byte >linz9
  2795  ec5d d1                 	!byte >linz10
  2796  ec5e d1                 	!byte >linz11
  2797  ec5f d1                 	!byte >linz12
  2798  ec60 d2                 	!byte >linz13
  2799  ec61 d2                 	!byte >linz14
  2800  ec62 d2                 	!byte >linz15
  2801  ec63 d2                 	!byte >linz16
  2802  ec64 d2                 	!byte >linz17
  2803  ec65 d2                 	!byte >linz18
  2804  ec66 d2                 	!byte >linz19
  2805  ec67 d3                 	!byte >linz20
  2806  ec68 d3                 	!byte >linz21
  2807  ec69 d3                 	!byte >linz22
  2808  ec6a d3                 	!byte >linz23
  2809  ec6b d3                 	!byte >linz24
  2810                          ; -------------------------------------------------------------------------------------------------
  2811                          ; EC6C Dispatch table (control codes $00-$1F, $80-$9F)
  2812  ec6c 21e3               ctable:	!word cuser-1
  2813  ec6e 01e6               	!word chkcol-1		; -/orange
  2814  ec70 21e3               	!word cuser-1
  2815  ec72 c8e5               	!word stprun-1		; stop/run
  2816  ec74 a2e6               	!word ce-1		; cancel
  2817  ec76 01e6               	!word chkcol-1		; white/-
  2818  ec78 9fe7               	!word unused-1		; unused - from rev.01/02 editor (uses $03BF)
  2819  ec7a 74e6               	!word bell-1		; bell/-
  2820  ec7c 21e3               	!word cuser-1
  2821  ec7e 6ae3               	!word tabit-1		; tab/tab toggle
  2822  ec80 21e3               	!word cuser-1
  2823  ec82 21e3               	!word cuser-1
  2824  ec84 21e3               	!word cuser-1
  2825  ec86 a4e3               	!word nxt1-1		; return or shifted return
  2826  ec88 50e2               	!word ctext-1		; text/graphic mode
  2827  ec8a 87ea               	!word window-1		; set top/bottom
  2828  ec8c 01e6               	!word chkcol-1		; -/black
  2829  ec8e 24e3               	!word cdnup-1		; cursor down/up
  2830  ec90 54e3               	!word rvsf-1		; rvs on/off
  2831  ec92 5ae3               	!word homclr-1		; home/clr
  2832  ec94 5ae5               	!word delins-1		; delete/insert character
  2833  ec96 01e6               	!word chkcol-1		; -/brown
  2834  ec98 01e6               	!word chkcol-1		; -/lightred
  2835  ec9a 01e6               	!word chkcol-1		; -/gray1
  2836  ec9c 01e6               	!word chkcol-1		; -/gray2
  2837  ec9e 01e6               	!word chkcol-1		; -/lightgreen
  2838  eca0 01e6               	!word chkcol-1		; -/lightblue
  2839  eca2 01e6               	!word chkcol-1		; -/gray3
  2840  eca4 01e6               	!word chkcol-1		; red/purple
  2841  eca6 41e3               	!word crtlf-1		; cursor right/left
  2842  eca8 01e6               	!word chkcol-1		; green/yellow
  2843  ecaa 01e6               	!word chkcol-1		; blue/cyan
  2844                          ; -------------------------------------------------------------------------------------------------
  2845                          ; ECAC Length of function key texts
  2846  ecac 03                 keylen: !byte key2-key1
  2847  ecad 03                 	!byte key3-key2
  2848  ecae 03                 	!byte key4-key3
  2849  ecaf 03                 	!byte key5-key4
  2850  ecb0 0d                 	!byte key6-key5
  2851  ecb1 0d                 	!byte key7-key6
  2852  ecb2 04                 	!byte key8-key7
  2853  ecb3 09                 	!byte key9-key8
  2854  ecb4 03                 	!byte key10-key9
  2855  ecb5 03                 	!byte keyend-key10                   ; 57 bytes keydef-text
  2856                          
  2857                          !ifdef STANDARD_FKEYS{          ; ********** Standard F-keys **********
  2858                          ; ECB6 Function key definitions
  2859                          keydef:
  2860                          key1:	!pet "print"                    ; F1
  2861                          key2:	!pet "list"                     ; F2
  2862                          key3:	!pet "dload",$22                ; F3
  2863                          key4:	!pet "dsave",$22                ; F4
  2864                          key5:	!pet "dopen"                    ; F5
  2865                          key6:	!pet "dclose"                   ; F6
  2866                          key7:	!pet "copy"                     ; F7
  2867                          key8:	!pet "directory"                ; F8
  2868                          key9:	!pet "scratch"                  ; F9
  2869                          key10:	!pet "chr$("                    ; F10
  2870                          ; -------------------------------------------------------------------------------------------------
  2871                          } else{                         ; ********** F-keys PATCH **********
  2872                          ; ECB6 Function key definitions
  2873                          keydef:
  2874  ecb6 52d50d             key1:	!pet "rU",$0d                   ; F1
  2875  ecb9 4cc90d             key2:	!pet "lI",$0d                   ; F2
  2876  ecbc 44cc22             key3:	!pet "dL",$22                   ; F3
  2877  ecbf 44d322             key4:	!pet "dS",$22                   ; F4
  2878  ecc2 4fd0382c382c3135...key5:	!pet "oP8,8,15,",$22,"cd:"      ; F5
  2879  eccf 4fd0392c392c3135...key6:	!pet "oP9,9,15,",$22,"cd:"      ; F6
  2880  ecdc 4443cc0d           key7:	!pet "dcL",$0d                  ; F7
  2881  ece0 4449d244304f4e55...key8:	!pet "diRd0onu8"                ; F8
  2882  ece9 53c322             key9:	!pet "sC",$22                   ; F9
  2883  ecec 48c522             key10:	!pet "hE",$22                   ; F10
  2884                          }
  2885                          ; Function key definitions
  2886                          ;keydef:
  2887                          ;key1:	!pet "run"                      ; F1
  2888                          ;key2:	!pet "list"                     ; F2
  2889                          ;key3:	!pet "dload",$22                ; F3
  2890                          ;key4:	!pet "dsave",$22                ; F4
  2891                          ;key5:	!pet "print"                    ; F5
  2892                          ;key6:	!pet "chr$("                    ; F6
  2893                          ;key7:	!pet "bank"                     ; F7
  2894                          ;key8:	!pet "directory"                ; F8
  2895                          ;key9:	!pet "scratch",$22              ; F9
  2896                          ;key10:	!pet "header",$22               ; F10
  2897                          ;}
  2898                          keyend:
  2899                          ; -------------------------------------------------------------------------------------------------
  2900                          ; ECEF bits  -  bit position table
  2901  ecef 8040201008040201   bits:	!byte $80,$40,$20,$10,$08,$04,$02,$01
  2902                          ; -------------------------------------------------------------------------------------------------
  2903                          ; ECF7 VIC initialization table regs $11-$21 
  2904  ecf7 1b00000000080040   tvic:	!byte $1B,$00,$00,$00,$00,$08,$00,$40
  2905  ecff 8f00000000000003   	!byte $8F,$00,$00,$00,$00,$00,$00,EXTCOL
  2906  ed07 01                 	!byte BGRCOL
  2907                          ; -------------------------------------------------------------------------------------------------
  2908                          ; ED08 Extended editor vector table (copied to $3B5)
  2909  ed08 f6e9               edvect:	!word dokeyf
  2910  ed0a 41e6               	!word wrvram
  2911  ed0c 50e6               	!word wrcram
  2912  ed0e 36e0               	!word nofunc
  2913  ed10 36e0               	!word nofunc
  2914                          ; -------------------------------------------------------------------------------------------------
  2915                          ; ED12 Color control code table
  2916                          ; blk,wht,red,cyan,magenta,grn,blue,yellow
  2917  ed12 90051c9f9c1e1f9e   coltab:	!byte $90,$05,$1C,$9F,$9C,$1E,$1F,$9E
  2918                          ; org,brown,lred,gray1,gray2,lgreen,lblue,gray3
  2919  ed1a 8195969798999a9b   	!byte $81,$95,$96,$97,$98,$99,$9A,$9B
  2920                          ; rsr modify for vic-40 system			*** Just for fun from rev.1 c64-kernal rev.1 ;) ***
  2921                          ; rsr 12/31/81 add 8 more colors
  2922                          ; -------------------------------------------------------------------------------------------------
  2923                          ; ED22 checksum byte
  2924  ed22 28                 cksume	!byte CHECKSUM		; e-page checksum
  2925                          ; -------------------------------------------------------------------------------------------------
  2926                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  2927                          ;**************************************************
  2928                          ; patch1 - checks for a single line window
  2929                          ;          aborts if so...
  2930                          ;**************************************************
  2931  ed23 a6dd               patch1:	ldx scbot		; check
  2932  ed25 e4dc               	cpx sctop
  2933  ed27 d002               	bne patcha		; no...pass through old code
  2934  ed29 68                 	pla			; abort
  2935  ed2a 68                 	pla
  2936  ed2b 2c8703             patcha:	bit scrdis		; restore patched area (test for scrolling mode)
  2937  ed2e 60                 	rts
  2938                          }
  2939                          ; -------------------------------------------------------------------------------------------------
  2940                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  2941                          ; patch 4a-2 - make space for clear insert flag
  2942                          patch4a2:
  2943  ed2f 20e9e4             	jsr fistrt		; find begining of line
  2944  ed32 a900               	lda #0
  2945  ed34 60                 	rts
  2946                          ; -------------------------------------------------------------------------------------------------
  2947                          ; patch 4a-4 - remember bootom line no
  2948                          patch4a4:
  2949  ed35 05d0               	ora crsw		; NO SENSE - a already 3
  2950  ed37 85d0               	sta crsw		; fake a carriage return
  2951  ed39 a5dd               	lda scbot
  2952  ed3b 8d8403             	sta lintmp		; remember bootom line no
  2953  ed3e a5df               	lda scrt		; moved to patch to make space
  2954  ed40 60                 	rts
  2955                          ; -------------------------------------------------------------------------------------------------
  2956                          ; patch 4a-3 - RS232 output
  2957                          patch4a3:
  2958  ed41 9003               	bcc p4a3		; -> check output ?
  2959  ed43 4c5af9             	jmp errorx		; moved to patch to make space
  2960  ed46 08                 p4a3:	php
  2961  ed47 48                 	pha
  2962  ed48 a5a0               	lda sa
  2963  ed4a 2901               	and #$01
  2964  ed4c f00a               	beq p4a3x		; no output
  2965  ed4e a69e               	ldx la
  2966  ed50 20c9ff             	jsr ckout		; open channel
  2967  ed53 20ccff             	jsr clrch		; close channel
  2968  ed56 a6a6               	ldx ribuf
  2969  ed58 68                 p4a3x:	pla
  2970  ed59 28                 	plp
  2971  ed5a 60                 	rts
  2972                          }
  2973                          ; -------------------------------------------------------------------------------------------------
  2974                          !ifdef SYSPATCH{
  2975                          poker	= $1B
  2976                          dfbank	= $0257
  2977                          getpin	= $B4B9
  2978                          *= $EDDC
  2979  eddc 20b9b4             csys:	jsr getpin      ; get positive integer
  2980  eddf a501               	lda i6509
  2981  ede1 48                 	pha
  2982  ede2 ad5702             	lda dfbank 	; current bank
  2983  ede5 c90f               	cmp #$F
  2984  ede7 f00b               	beq fligm
  2985  ede9 a61b               	ldx poker
  2986  edeb a41c               	ldy poker+1
  2987  eded 206cff             	jsr newsys
  2988                          csysrz	=*-1
  2989  edf0 68                 	pla
  2990  edf1 8501               	sta $1
  2991  edf3 60                 	rts
  2992                          fligm:
  2993  edf4 a9ed               	lda #>csysrz    ;push return address
  2994  edf6 48                 	pha
  2995  edf7 a9ef               	lda #<csysrz
  2996  edf9 48                 	pha
  2997  edfa 6c1b00             	jmp (poker)
  2998  edfd 60                 	rts	
  2999                          }
  3000                          ; ****************************************** KERNAL ***********************************************
  3001                          ; ##### monitor #####
  3002                          !zone kernal
  3003                          ;************************************************
  3004                          ;* kernal monitor                               *
  3005                          ;*                                              *
  3006                          ;* entry via call (jmp) or breakpoint (brk)     *
  3007                          ;* ---functions---                              *
  3008                          ;* <:>      alter memory                        *
  3009                          ;* <;>      alter registers                     *
  3010                          ;* <r>      display registers                   *
  3011                          ;* <m>      display memory                      *
  3012                          ;* <g>      start execution of code             *
  3013                          ;* <l>      load memory                         *
  3014                          ;* <s>      save memory                         *
  3015                          ;* <v>      view segment                        *
  3016                          ;* <@>      disk command                        *
  3017                          ;* <x>      warm start basic                    *
  3018                          ;* <u>      set default disk unit               *
  3019                          ;* <other>  load and execute from disk          *
  3020                          ;*                                              *
  3021                          ;* for syntax & semantics see cbm kernal manual *
  3022                          ;* copyright (c) 1981 by cbm                    *
  3023                          ;************************************************
  3024                          ; EE00 Reset Entry
  3025                          *= kernal+$E00
  3026                          
  3027                          ; ***** Warm start entry *******
  3028  ee00 20fef9             monon:	jsr ioinit		; get i/o
  3029  ee03 20b1fb             	jsr restor		; vectors
  3030  ee06 2004e0             	jsr jcint		; screen editor
  3031                          
  3032                          ; ***** Cold start entry ******
  3033  ee09 20ccff             monoff:	jsr clrch		; clear channels
  3034  ee0c a95a               	lda #winit		; waste two bytes so timc=60950
  3035  ee0e a200               	ldx #<monon		; point reset vectors at monitor on
  3036  ee10 a0ee               	ldy #>monon
  3037  ee12 20d9fb             	jsr vreset
  3038  ee15 58                 	cli			; release irq's
  3039                          
  3040                          ; ***** Call entry *****
  3041  ee16 a9c0               timc:	lda #$40+$80
  3042  ee18 8d6103             	sta msgflg		; error+messages on
  3043  ee1b a940               	lda #ms34-ms1		; call entry
  3044  ee1d 85bd               	sta tmpc
  3045  ee1f d010               	bne b3			; branch always
  3046                          
  3047                          ; ***** Break entry *****
  3048  ee21 20ccff             timb:	jsr clrch		; clr channels
  3049  ee24 a953               	lda #ms36-ms1		; break entry
  3050  ee26 85bd               	sta tmpc
  3051  ee28 d8                 	cld 
  3052                          
  3053                          ; Save .y,.x,.a,flags, and pc
  3054  ee29 a205               	ldx #5
  3055                          ; EE2B Pop registers from stack and save them
  3056  ee2b 68                 b1:	pla
  3057  ee2c 95ae               	sta pch,x
  3058  ee2e ca                 	dex
  3059  ee2f 10fa               	bpl b1
  3060                          
  3061  ee31 a501               b3:	lda i6509		; save indirection segment
  3062  ee33 85b5               	sta xi6509
  3063  ee35 ad0003             	lda cinv
  3064  ee38 85b8               	sta invl		; save irq low
  3065  ee3a ad0103             	lda cinv+1
  3066  ee3d 85b7               	sta invh		; save irq high
  3067                          
  3068  ee3f ba                 	tsx
  3069  ee40 86b4               	stx sp			; save original sp
  3070  ee42 58                 	cli			; clear ints
  3071  ee43 a908               	lda #8			; set disk default to 8
  3072  ee45 85bf               	sta ddisk
  3073                          
  3074  ee47 a4bd               b5:	ldy tmpc		; message code
  3075  ee49 2023f2             	jsr spmsg		; print break/call
  3076                          
  3077  ee4c a952               	lda #'r'		; display regs on entry
  3078  ee4e d023               	bne s0			; branch always
  3079                          ; EE50 ***** Error entry *****
  3080                          
  3081  ee50 201eef             erropr:	jsr outqst
  3082  ee53 68                 	pla
  3083  ee54 68                 	pla
  3084                          
  3085                          ; ***** Command interpreter entry *****
  3086                          strtm1=*-1
  3087  ee55 a9c0               	lda #$40+$80
  3088  ee57 8d6103             	sta msgflg		; i/o messages to screen
  3089  ee5a a900               	lda #<buf		; put filename at bottom of basic buffer
  3090  ee5c 8590               	sta fnadr
  3091  ee5e a902               	lda #>buf
  3092  ee60 8591               	sta fnadr+1
  3093  ee62 a90f               	lda #irom
  3094  ee64 8592               	sta fnadr+2
  3095  ee66 2021ef             	jsr crlf
  3096                          
  3097  ee69 20cfff             st1:	jsr basin		; read command
  3098                          
  3099  ee6c c920               	cmp #' '
  3100  ee6e f0f9               	beq st1			; span blanks
  3101  ee70 6c1e03             	jmp (usrcmd)		; user indirect for monitor
  3102                          ; -------------------------------------------------------------------------------------------------
  3103                          ; EE73 Command interpreter
  3104  ee73 a200               s0:	ldx #0
  3105  ee75 869d               	stx fnlen
  3106  ee77 a8                 	tay			; save current command
  3107                          
  3108                          ; Put return address for commands on stack
  3109  ee78 a9ee               	lda #>strtm1
  3110  ee7a 48                 	pha
  3111  ee7b a954               	lda #<strtm1
  3112  ee7d 48                 	pha
  3113                          
  3114  ee7e 98                 	tya			; current command in .a
  3115                          
  3116  ee7f ddd1ee             s1:	cmp cmds,x		; is it this one?
  3117  ee82 d010               	bne s2			; notit
  3118                          
  3119  ee84 8d6603             	sta savx		; save current command
  3120                          
  3121                          ; Indirect jmp from table
  3122  ee87 bdd2ee             	lda cmds+1,x
  3123  ee8a 85b9               	sta tmp0
  3124  ee8c bdd3ee             	lda cmds+2,x
  3125  ee8f 85ba               	sta tmp0+1
  3126  ee91 6cb900             	jmp (tmp0)
  3127                          ; -------------------------------------------------------------------------------------------------
  3128                          ; EE94 Each table entry is 3 long---skip to next
  3129  ee94 e8                 s2:	inx
  3130  ee95 e8                 	inx
  3131  ee96 e8                 	inx
  3132  ee97 e024               	cpx #cmdend-cmds
  3133  ee99 90e4               	bcc s1			; loop for all commands
  3134                          
  3135                          ; Command not in table...look on disk.
  3136                          ; Command name can be any length and have parameters.
  3137  ee9b a200               	ldx #0			; length to zero
  3138  ee9d c90d               s3:	cmp #$D			; end of name?
  3139  ee9f f00d               	beq s4			; yes...
  3140  eea1 c920               	cmp #' '		; blank?
  3141  eea3 f009               	beq s4			; yes
  3142  eea5 9d0002             	sta buf,x
  3143  eea8 20cfff             	jsr basin		; get next
  3144  eeab e8                 	inx			; count char
  3145  eeac d0ef               	bne s3			; and continue
  3146                          
  3147  eeae 85bd               s4:	sta tmpc
  3148  eeb0 8a                 	txa			; count
  3149  eeb1 f01d               	beq s6			; is zero
  3150                          
  3151  eeb3 859d               	sta fnlen
  3152  eeb5 a940               	lda #$40
  3153  eeb7 8d6103             	sta msgflg		; messages off
  3154  eeba a5bf               	lda ddisk
  3155  eebc 859f               	sta fa			; will use default disk
  3156  eebe a90f               	lda #irom		; commands only load to rom segment !!!***
  3157  eec0 8501               	sta i6509		; turn indirect to rom segment
  3158  eec2 a2ff               	ldx #$FF
  3159  eec4 a0ff               	ldy #$FF
  3160  eec6 20d5ff             	jsr load		; try to load command
  3161  eec9 b005               	bcs s6			; bad load...
  3162                          
  3163  eecb a5bd               	lda tmpc		; pass last character
  3164  eecd 6c9900             	jmp (stal)		; go do it
  3165                          
  3166  eed0 60                 s6:	rts
  3167                          ; -------------------------------------------------------------------------------------------------
  3168                          ; EED1 Command table
  3169  eed1 3a                 cmds:	!pet ':'		; alter memory
  3170  eed2 f7ef               	!word altm
  3171  eed4 3b                 	!pet ';'		; alter registers
  3172  eed5 c5ef               	!word altr
  3173  eed7 52                 	!pet 'r'		; display registers
  3174  eed8 41ef               	!word dsplyr
  3175  eeda 4d                 	!pet 'm'		; display memory
  3176  eedb 84ef               	!word dsplym
  3177  eedd 47                 	!pet 'g'		; start execution
  3178  eede 14f0               	!word go
  3179  eee0 4c                 	!pet 'l'		; load memory
  3180  eee1 43f0               	!word ld
  3181  eee3 53                 	!pet 's'		; save memory
  3182  eee4 43f0               	!word ld
  3183  eee6 56                 	!pet 'v'		; view segment
  3184  eee7 dfef               	!word view
  3185  eee9 40                 	!pet '@'		; disk command (alternate)
  3186  eeea 68f1               	!word disk
  3187  eeec 5a                 	!pet 'z'		; transfer to 2nd microprocessor
  3188  eeed 72ff               	!word ipcgov		; ipcgo vector
  3189  eeef 58                 	!pet 'x'		; warm start basic
  3190  eef0 f5ee               	!word xeit
  3191  eef2 55                 	!pet 'u'		; default disk unit set
  3192  eef3 ebef               	!word unitd
  3193                          cmdend:
  3194                          ; -------------------------------------------------------------------------------------------------
  3195                          ; EEF5 Exit 'x'
  3196  eef5 68                 xeit:	pla			; remove command return from stack
  3197  eef6 68                 	pla
  3198  eef7 78                 	sei			; disable interrupts...all warm start code expects
  3199  eef8 6cf803             	jmp (evect)		; go warmstart language
  3200                          ; -------------------------------------------------------------------------------------------------
  3201                          ; EEFB Move tmp0/tmp0+1 to PC memory location
  3202  eefb a5b9               putp:	lda tmp0		; move tmp0 to pch,pcl
  3203  eefd 85af               	sta pcl
  3204  eeff a5ba               	lda tmp0+1
  3205  ef01 85ae               	sta pch
  3206  ef03 60                 	rts
  3207                          ; -------------------------------------------------------------------------------------------------
  3208                          ; EF04 Set tmp0 to point to the saved regs in zero page
  3209  ef04 a9b0               setr:	lda #<flgs		; set to access regs
  3210  ef06 85b9               	sta tmp0
  3211  ef08 a900               	lda #>flgs
  3212  ef0a 85ba               	sta tmp0+1
  3213  ef0c a90f               	lda #irom		; point indirect at roms
  3214  ef0e 8501               	sta i6509
  3215  ef10 a905               	lda #5
  3216  ef12 60                 	rts
  3217                          ; -------------------------------------------------------------------------------------------------
  3218                          ; EF13 Prints '.:' or '.;' before data to permit alter after 'm' or 'r' command
  3219                          
  3220  ef13 48                 altrit: pha			; preserve alter character
  3221  ef14 2021ef             	jsr crlf
  3222  ef17 68                 	pla
  3223  ef18 20d2ff             	jsr bsout
  3224                          
  3225  ef1b a920               space:  lda #' '		; output a space
  3226  ef1d 2c                 	!byte $2C		; skip two bytes
  3227                          
  3228  ef1e a93f               outqst: lda #'?'		; output question
  3229  ef20 2c                 	!byte $2C		; skip two bytes
  3230                          
  3231  ef21 a90d               crlf:   lda #$D		; do carriage return
  3232  ef23 4cd2ff             	jmp bsout
  3233                          ; -------------------------------------------------------------------------------------------------
  3234                          ; EF26 Data for register display heading
  3235  ef26 0d2020             regk:	!pet cr,"  "		; 3 spaces
  3236  ef29 2050432020495251...	!pet " pc "," irq "," sr ac xr yr sp"
  3237                          ; -------------------------------------------------------------------------------------------------
  3238                          ; EF41 Display register function 'r'
  3239  ef41 a200               dsplyr:	ldx #0
  3240  ef43 bd26ef             d2:	lda regk,x
  3241  ef46 20d2ff             	jsr bsout		; print heading
  3242  ef49 e8                 	inx
  3243  ef4a e01b               	cpx #dsplyr-regk	; max length
  3244  ef4c d0f5               	bne d2
  3245  ef4e a93b               	lda #';'
  3246  ef50 2013ef             	jsr altrit		; allow alter after display
  3247  ef53 a6ae               	ldx pch
  3248  ef55 a4af               	ldy pcl
  3249  ef57 20f9f0             	jsr wroa		; print program counter
  3250  ef5a 201bef             	jsr space
  3251  ef5d a6b7               	ldx invh
  3252  ef5f a4b8               	ldy invl
  3253  ef61 20f9f0             	jsr wroa		; print irq vector
  3254  ef64 2004ef             	jsr setr		; set to print .p,.a,.x,.y,.s
  3255                          
  3256                          ; display memory subroutine
  3257  ef67 85bd               dm:	sta tmpc		; byte count
  3258  ef69 a000               	ldy #0			; indirect index
  3259  ef6b 849d               	sty fnlen		; fnlen is zero-page crossing flag...
  3260  ef6d 201bef             dm1:	jsr space		; space tween bytes
  3261  ef70 b1b9               	lda (tmp0),y
  3262  ef72 20fef0             	jsr wrob		; write byte of memory
  3263                          
  3264                          ; increment indirect
  3265  ef75 e6b9               	inc tmp0
  3266  ef77 d006               	bne dm2
  3267  ef79 e6ba               	inc tmp0+1
  3268  ef7b d002               	bne dm2			; no zero page crossing
  3269  ef7d c69d               	dec fnlen		; fnlen<>0 is flag
  3270                          
  3271  ef7f c6bd               dm2:	dec tmpc		; count bytes
  3272  ef81 d0ea               	bne dm1			; until zero
  3273  ef83 60                 	rts
  3274                          ; -------------------------------------------------------------------------------------------------
  3275                          ; EF84 Display memory function 'm'
  3276  ef84 2026f1             dsplym:	jsr rdoa		; read start adr
  3277  ef87 b039               	bcs arrn		; ...err if no sa
  3278  ef89 2016f1             	jsr t2t2		; sa to tmp2
  3279                          
  3280                          ; allow user to type just one address
  3281  ef8c 2026f1             	jsr rdoa		; read end adr
  3282  ef8f 9008               	bcc dsp123		; good...no default
  3283                          
  3284  ef91 a5bb               	lda tmp2
  3285  ef93 85b9               	sta tmp0		; default low byte
  3286  ef95 a5bc               	lda tmp2+1
  3287  ef97 85ba               	sta tmp0+1		; default hi byte
  3288                          
  3289  ef99 2016f1             dsp123:	jsr t2t2		; sa to tmp0, ea to tmp2
  3290  ef9c 20e1ff             dsp1:	jsr stop		; stop key?
  3291  ef9f f020               	beq beqs1		; yes...break list
  3292                          
  3293  efa1 a93a               	lda #':'
  3294  efa3 2013ef             	jsr altrit		; allow alter
  3295  efa6 a6ba               	ldx tmp0+1
  3296  efa8 a4b9               	ldy tmp0
  3297  efaa 20f9f0             	jsr wroa		; write start address
  3298                          
  3299  efad a908               	lda #8			; count of bytes
  3300  efaf 2067ef             	jsr dm			; display bytes
  3301                          
  3302  efb2 a59d               	lda fnlen		; check for zero-crossing
  3303  efb4 d00b               	bne beqs1		; yup....
  3304  efb6 38                 	sec
  3305  efb7 a5bb               	lda tmp2
  3306  efb9 e5b9               	sbc tmp0
  3307  efbb a5bc               	lda tmp2+1
  3308  efbd e5ba               	sbc tmp0+1
  3309  efbf b0db               	bcs dsp1		; end >= start
  3310                          
  3311  efc1 60                 beqs1:	rts			; a.o.k. exit
  3312                          
  3313  efc2 4c50ee             arrn:	jmp erropr		; syntax error jump
  3314                          ; -------------------------------------------------------------------------------------------------
  3315                          ; EFC5 Alter register function ';'
  3316  efc5 2026f1             altr:	jsr rdoa		; read new pc
  3317  efc8 b0f8               	bcs arrn		; ...no address=error
  3318                          
  3319  efca 20fbee             	jsr putp		; alter pc
  3320                          
  3321  efcd 2026f1             	jsr rdoa		; read new irq
  3322  efd0 b0f0               	bcs arrn		; ...no address=error
  3323                          
  3324  efd2 a5b9               	lda tmp0
  3325  efd4 85b8               	sta invl		; alter irq vector
  3326  efd6 a5ba               	lda tmp0+1
  3327  efd8 85b7               	sta invh
  3328                          
  3329  efda 2004ef             	jsr setr		; set to alter r's
  3330  efdd d01f               	bne a4			; branch always
  3331                          ; -------------------------------------------------------------------------------------------------
  3332                          ; EFDF View a segment (point indirect) 'v'
  3333  efdf 2033f1             view:	jsr rdob		; get a byte
  3334  efe2 b0de               	bcs arrn		; ...if none...error
  3335  efe4 c910               	cmp #16			; range 0-15
  3336  efe6 b0da               	bcs arrn		; to large no modulo
  3337  efe8 8501               	sta i6509
  3338  efea 60                 	rts
  3339                          ; -------------------------------------------------------------------------------------------------
  3340                          ; EFEB Unit default for disk 'u'
  3341  efeb 2033f1             unitd:	jsr rdob		; get a byte
  3342  efee b0d2               	bcs arrn		; ...if none...error
  3343  eff0 c920               	cmp #32			; range 0-31
  3344  eff2 b0ce               	bcs arrn		; to large no modulo
  3345  eff4 85bf               	sta ddisk
  3346  eff6 60                 	rts
  3347                          ; -------------------------------------------------------------------------------------------------
  3348                          ; EFF7 Alter memory - read adr and data ':'
  3349  eff7 2026f1             altm:	jsr rdoa		; read alter adr
  3350  effa b0c6               	bcs arrn		; ...if none...error
  3351                          
  3352  effc a908               	lda #8			; allow 8 bytes change
  3353                          
  3354                          ; common code for ':' and ';'
  3355  effe 85bd               a4:	sta tmpc		; number of bytes to change
  3356                          
  3357  f000 2033f1             a5:	jsr rdob		; read byte
  3358  f003 b00e               	bcs a9
  3359                          
  3360  f005 a000               	ldy #0
  3361  f007 91b9               	sta (tmp0),y		; store it away
  3362                          
  3363                          ; increment store address
  3364  f009 e6b9               	inc tmp0
  3365  f00b d002               	bne a6
  3366  f00d e6ba               	inc tmp0+1
  3367                          
  3368  f00f c6bd               a6:	dec tmpc		; count byte
  3369  f011 d0ed               	bne a5			; until zero
  3370  f013 60                 a9:	rts
  3371                          ; -------------------------------------------------------------------------------------------------
  3372                          ; F014 Start execution function 'g'
  3373  f014 2062f1             go:	jsr rdoc		; see if default
  3374  f017 f008               	beq g1			; yes...pc is address
  3375  f019 2026f1             	jsr rdoa		; no...get new addr
  3376  f01c b022               	bcs errl		; ...none=error
  3377  f01e 20fbee             	jsr putp		; move addr to p.c.
  3378                          
  3379  f021 a6b4               g1:	ldx sp
  3380  f023 9a                 	txs			; orig or new sp value to sp
  3381                          
  3382  f024 78                 	sei			; prevent disaster
  3383                          
  3384  f025 a5b7               	lda invh
  3385  f027 8d0103             	sta cinv+1		; set up irq vector
  3386  f02a a5b8               	lda invl
  3387  f02c 8d0003             	sta cinv
  3388  f02f a5b5               	lda xi6509		; and indirection register
  3389  f031 8501               	sta i6509
  3390                          
  3391                          ; get flags,pch,pcl,.a,.x,.y
  3392  f033 a200               	ldx #0
  3393  f035 b5ae               g2:	lda pch,x
  3394  f037 48                 	pha			; everybody on stack
  3395  f038 e8                 	inx
  3396  f039 e006               	cpx #6
  3397  f03b d0f8               	bne g2
  3398                          
  3399                          ; interrupt return sets everybody up from data on stack
  3400  f03d 4cb3fc             	jmp prend
  3401                          
  3402  f040 4c50ee             errl:	jmp erropr
  3403                          ; -------------------------------------------------------------------------------------------------
  3404                          ; F043 Load ram function 'l' and 's'
  3405                          ;  *note - load/save reset indirect to rom
  3406  f043 a001               ld:	ldy #1
  3407  f045 849f               	sty fa			; default device #1
  3408  f047 88                 	dey			; .y=0 to count name length
  3409  f048 a9ff               	lda #$FF		; default no move load
  3410  f04a 85b9               	sta tmp0
  3411  f04c 85ba               	sta tmp0+1
  3412  f04e a501               	lda i6509		; save indirect for seg address
  3413  f050 85be               	sta t6509
  3414  f052 a90f               	lda #irom		; indirect to rom for filename
  3415  f054 8501               	sta i6509
  3416                          
  3417  f056 2062f1             l1:	jsr rdoc		; default?
  3418  f059 f01c               	beq l5			; yes...try load
  3419                          
  3420  f05b c920               	cmp #' '
  3421  f05d f0f7               	beq l1			; span blanks
  3422                          
  3423  f05f c922               	cmp #$22		; string next?
  3424  f061 d0dd               l2:	bne errl		; no file name...
  3425                          
  3426  f063 2062f1             l3:	jsr rdoc		; get character of name
  3427  f066 f00f               	beq l5			; end...asssume load
  3428                          
  3429  f068 c922               	cmp #$22		; end of string?
  3430  f06a f01d               	beq l8			; yes...could still be 'l' or 's'
  3431                          
  3432  f06c 9190               	sta (fnadr),y		; store name
  3433  f06e e69d               	inc fnlen
  3434  f070 c8                 	iny
  3435  f071 c010               	cpy #16			; max file name length
  3436                          
  3437  f073 f0cb               l4:	beq errl		; file name too long
  3438  f075 d0ec               	bne l3			; branch always
  3439                          ; see if we got a load
  3440  f077 ad6603             l5:	lda savx		; get last command
  3441  f07a c94c               	cmp #'l'
  3442  f07c d0e3               	bne l2			; no..not a load..error
  3443                          
  3444  f07e a5be               	lda t6509		; get segment to load to
  3445  f080 290f               	and #irom		; mask off verify bit
  3446  f082 a6b9               	ldx tmp0
  3447  f084 a4ba               	ldy tmp0+1
  3448  f086 4cd5ff             	jmp load		; yes...do load
  3449                          
  3450  f089 2062f1             l8:	jsr rdoc		; more stuff?
  3451  f08c f0e9               	beq l5			; no...defualt load
  3452                          
  3453  f08e c92c               	cmp #','		; delimeter?
  3454  f090 d0cf               l9:	bne l2			; no...bad syntax
  3455                          
  3456  f092 2033f1             	jsr rdob		; yes...get next parm
  3457  f095 b05f               	bcs l15			; ...error if none
  3458                          
  3459  f097 859f               	sta fa
  3460                          
  3461  f099 2062f1             	jsr rdoc		; more parms?
  3462  f09c f0d9               	beq l5			; no...default load
  3463                          
  3464  f09e c92c               	cmp #','		; delimeter?
  3465  f0a0 d0ee               l12:	bne l9			; no...bad syntax
  3466                          
  3467  f0a2 2033f1             	jsr rdob		; segment byte ?
  3468  f0a5 b04f               	bcs l15			; ...must have
  3469  f0a7 c910               	cmp #16			; 00-0f allowed
  3470  f0a9 b04b               	bcs l15			; too big...
  3471  f0ab 85be               	sta t6509
  3472  f0ad 859b               	sta stas		; prep segment
  3473  f0af 2026f1             	jsr rdoa
  3474  f0b2 b042               	bcs l15
  3475                          ; set up start save address
  3476  f0b4 a5b9               	lda tmp0
  3477  f0b6 8599               	sta stal
  3478  f0b8 a5ba               	lda tmp0+1
  3479  f0ba 859a               	sta stah
  3480                          
  3481  f0bc 2062f1             	jsr rdoc		; delimeter?
  3482  f0bf f0b6               	beq l5			; cr, do load
  3483  f0c1 c92c               	cmp #','
  3484  f0c3 d031               	bne l15			; no delim
  3485                          
  3486  f0c5 2033f1             	jsr rdob		; get segment byte
  3487  f0c8 b02c               	bcs l15			; ...must have
  3488  f0ca c910               	cmp #16			; allow only 00-0f
  3489  f0cc b028               	bcs l15			; too big...
  3490  f0ce 8598               	sta eas			; prep segment
  3491  f0d0 2026f1             	jsr rdoa		; try to read end address
  3492  f0d3 b021               	bcs l15			; ...must have
  3493                          
  3494                          ; set up end save address
  3495  f0d5 a5b9               	lda tmp0
  3496  f0d7 8596               	sta eal
  3497  f0d9 a5ba               	lda tmp0+1
  3498  f0db 8597               	sta eah
  3499                          
  3500  f0dd 20cfff             l20:	jsr basin
  3501  f0e0 c920               	cmp #' '
  3502  f0e2 f0f9               	beq l20			; span blanks
  3503                          
  3504  f0e4 c90d               	cmp #cr
  3505  f0e6 d0b8               l14:	bne l12			; missing cr at end
  3506  f0e8 ad6603             	lda savx 		; was command save?
  3507  f0eb c953               	cmp #'s'
  3508  f0ed d0f7               	bne l14			; no...load can't have parms
  3509                          
  3510  f0ef a299               	ldx #<stal		; get addresses of params for save
  3511  f0f1 a096               	ldy #<eal
  3512  f0f3 4cd8ff             	jmp save
  3513                          
  3514  f0f6 4c50ee             l15:	jmp erropr
  3515                          ; -------------------------------------------------------------------------------------------------
  3516                          ; F0F9 Write adr from tmp0 stores
  3517  f0f9 8a                 wroa:   txa			; hi-byte
  3518  f0fa 20fef0             	jsr wrob
  3519  f0fd 98                 	tya			; low-byte
  3520                          ; F0FE Write byte --- a = byte
  3521                          ; unpack byte data into two ascii characters. a=byte; x,a=chars
  3522  f0fe 48                 wrob:   pha
  3523  f0ff 4a                 	lsr
  3524  f100 4a                 	lsr
  3525  f101 4a                 	lsr
  3526  f102 4a                 	lsr
  3527  f103 200af1             	jsr ascii		; convert to ascii
  3528  f106 aa                 	tax
  3529  f107 68                 	pla
  3530  f108 290f               	and #$0F
  3531                          ; F10A Convert nybble in a to ascii and print it
  3532  f10a 18                 ascii:	clc
  3533  f10b 69f6               	adc #$F6
  3534  f10d 9002               	bcc asc1
  3535  f10f 6906               	adc #$06
  3536  f111 693a               asc1:	adc #$3A
  3537  f113 4cd2ff             	jmp bsout
  3538                          ; -------------------------------------------------------------------------------------------------
  3539                          ; F116 Exchange temporaries
  3540  f116 a202               t2t2:	ldx #2
  3541  f118 b5b8               t2t21:	lda tmp0-1,x
  3542  f11a 48                 	pha
  3543  f11b b5ba               	lda tmp2-1,x
  3544  f11d 95b8               	sta tmp0-1,x 
  3545  f11f 68                 	pla
  3546  f120 95ba               	sta tmp2-1,x
  3547  f122 ca                 	dex
  3548  f123 d0f3               	bne t2t21
  3549  f125 60                 	rts
  3550                          ; -------------------------------------------------------------------------------------------------
  3551                          ; F126 Read hex adr,return hi in tmp0, lo in tmp0+1,and cy=1, if sp cy=0
  3552  f126 2033f1             rdoa:	jsr rdob		; read 2-char byte
  3553  f129 b007               	bcs rdoa2		; space
  3554  f12b 85ba               	sta tmp0+1
  3555  f12d 2033f1             	jsr rdob
  3556  f130 85b9               	sta tmp0
  3557  f132 60                 rdoa2:	rts
  3558                          ; -------------------------------------------------------------------------------------------------
  3559                          ; F133 Read hex byte and return in a and cy=0 if sp cy=1
  3560  f133 a900               rdob:	lda #0			; space
  3561  f135 8d0001             	sta bad			; read next char
  3562  f138 2062f1             	jsr rdoc
  3563  f13b f019               	beq rdob4		; fail on cr
  3564  f13d c920               	cmp #' '		; blank?
  3565  f13f f0f2               	beq rdob		; span blanks...
  3566                          
  3567  f141 2057f1             	jsr hexit		; convert to hex nybble
  3568  f144 0a                 	asl
  3569  f145 0a                 	asl
  3570  f146 0a                 	asl
  3571  f147 0a                 	asl
  3572  f148 8d0001             	sta bad
  3573  f14b 2062f1             	jsr rdoc		; 2nd char assumed hex
  3574  f14e f006               	beq rdob4		; fail on cr
  3575  f150 2057f1             	jsr hexit
  3576  f153 0d0001             	ora bad
  3577                          
  3578  f156 60                 rdob4:	rts
  3579                          ; -------------------------------------------------------------------------------------------------
  3580                          ; F157 Convert char in A into hex value
  3581  f157 c93a               hexit:  cmp #$3A
  3582  f159 08                 	php			; save flags
  3583  f15a 290f               	and #$0F
  3584  f15c 28                 	plp
  3585  f15d 9002               	bcc hex09		; 0-9
  3586  f15f 6908               	adc #8			; alpha add 8+cy=9
  3587  f161 60                 hex09:	rts
  3588                          ; -------------------------------------------------------------------------------------------------
  3589                          ; F162 Get character and test for cr
  3590  f162 20cfff             rdoc:	jsr basin
  3591  f165 c90d               	cmp #$D			; is it a cr
  3592  f167 60                 	rts			; return with flags
  3593                          ; -------------------------------------------------------------------------------------------------
  3594                          ; F168 Send disk command or read status '@'
  3595  f168 a900               disk:	lda #0			; clear status @ i/o begin
  3596  f16a 859c               	sta status
  3597  f16c 859d               	sta fnlen		; filename length of zero...
  3598                          
  3599  f16e a6bf               	ldx ddisk		; get default disk
  3600  f170 a00f               	ldy #$0F		; open command channel
  3601  f172 204ffb             	jsr setlfs		; .a-0 temporary channel #
  3602  f175 18                 	clc
  3603  f176 20c0ff             	jsr open		; open a real channel
  3604  f179 b044               	bcs disk30		; exit if bad return
  3605                          
  3606  f17b 2062f1             	jsr rdoc		; see if status check
  3607  f17e f01d               	beq disk20		; yes
  3608                          
  3609  f180 48                 	pha
  3610  f181 a200               	ldx #0
  3611  f183 20c9ff             	jsr ckout		; set up as output
  3612  f186 68                 	pla
  3613  f187 b036               	bcs disk30		; bad status return
  3614  f189 9003               	bcc disk15		; no...ok
  3615                          
  3616  f18b 20cfff             disk10:	jsr basin		; get a character
  3617  f18e c90d               disk15:	cmp #$D			; see if end
  3618  f190 08                 	php			; save for later
  3619  f191 20d2ff             	jsr bsout		; out to floppy
  3620  f194 a59c               	lda status
  3621  f196 d023               	bne disk28		; bad status returned
  3622  f198 28                 	plp			; end?
  3623  f199 d0f0               	bne disk10		; no...continue
  3624  f19b f022               	beq disk30		; yes...floppy done
  3625                          
  3626  f19d 2021ef             disk20:	jsr crlf
  3627  f1a0 a200               	ldx #0
  3628  f1a2 20c6ff             	jsr chkin		; tell floppy to speak
  3629  f1a5 b018               	bcs disk30		; bad device
  3630                          
  3631  f1a7 20cfff             disk25:  jsr basin		; get a character
  3632  f1aa c90d               	cmp #$0D
  3633  f1ac 08                 	php			; save test for later
  3634  f1ad 20d2ff             	jsr bsout		; out to screen
  3635  f1b0 a59c               	lda status		; check for bad basin
  3636  f1b2 29bf               	and #$FF-$40		; remove eoi bit
  3637  f1b4 d005               	bne disk28		; report bad status
  3638  f1b6 28                 	plp			; end?
  3639  f1b7 d0ee               	bne disk25		; no...
  3640  f1b9 f004               	beq disk30		; yes...floppy done
  3641                          
  3642  f1bb 68                 disk28:	pla			; clean up...
  3643  f1bc 204cf9             disk29:	jsr error5		; report error #5 for bad device
  3644  f1bf 20ccff             disk30:	jsr clrch		; clean up
  3645  f1c2 a900               	lda #0
  3646  f1c4 18                 	clc			; just remove from table
  3647  f1c5 4cc3ff             	jmp close
  3648                          ; -------------------------------------------------------------------------------------------------
  3649                          ; F1C8 Unused
  3650  f1c8 ea                 	nop
  3651  f1c9 ea                 	nop
  3652                          ; -------------------------------------------------------------------------------------------------
  3653                          ; F1CA ##### messages #####
  3654  f1ca 0d492f4f20455252...ms1:	!pet $0D,"i/o error ",$A3
  3655  f1d6 0d53454152434849...ms5:	!pet $0D,"searching",$A0
  3656  f1e1 464f52a0           ms6:	!pet "for",$A0
  3657                          ;ms7:	!pet $0D,"press play on tap",$C5
  3658                          ;ms8:	!pet "press record & play on tap",$C5
  3659  f1e5 0d4c4f4144494ec7   ms10:	!pet $0D,"loadin",$C7
  3660  f1ed 0d534156494e47a0   ms11:	!pet $0D,"saving",$A0
  3661  f1f5 0d56455249465949...ms21:	!pet $0D,"verifyin",$C7
  3662  f1ff 0d464f554e44a0     ms17:	!pet $0D,"found",$A0
  3663  f206 0d4f4b8d           ms18:	!pet $0D,"ok",$8D
  3664  f20a 0d2a2a204d4f4e49...ms34:	!pet $0D,"** monitor 1.0 **",$8D
  3665  f21d 0d42524541cb       ms36:	!pet $0D,"brea",$CB
  3666                          ; -------------------------------------------------------------------------------------------------
  3667                          ; F223 Print message to screen only if output enabled
  3668  f223 2c6103             spmsg:	bit msgflg		; printing messages?
  3669  f226 100d               	bpl msg10		; no...
  3670  f228 b9caf1             msg:	lda ms1,y
  3671  f22b 08                 	php
  3672  f22c 297f               	and #$7F
  3673  f22e 20d2ff             	jsr bsout
  3674  f231 c8                 	iny
  3675  f232 28                 	plp
  3676  f233 10f3               	bpl msg
  3677  f235 18                 msg10:	clc
  3678  f236 60                 	rts
  3679                          ; -------------------------------------------------------------------------------------------------
  3680                          ; ##### ieee #####
  3681                          ; F237 Command ieee-488 device to talk
  3682  f237 0940               ntalk:	ora #tlkr		; make a talk adr
  3683  f239 d002               	bne list1		; always go to list1
  3684                          ; command ieee-488 device to listen
  3685  f23b 0920               nlistn:	ora #lstnr		; make a listen adr
  3686                          
  3687  f23d 48                 list1:	pha			; save device and talk/listen
  3688                          
  3689  f23e a93f               	lda #tddb		; set control for atn/data out
  3690  f240 8d03de             	sta tpi1+ddpa
  3691                          
  3692  f243 a9ff               	lda #$FF		; set direction for transmitt *
  3693  f245 8d00dc             	sta cia+pra		; set data   *
  3694  f248 8d02dc             	sta cia+ddra		; set data direction out   *
  3695  f24b a9fa               	lda #$FF-dc-ren		; enable transmitt
  3696  f24d 8d00de             	sta tpi1+pa
  3697  f250 a5aa               	lda c3po		; get ieee flags
  3698  f252 101b               	bpl list2		; if data in buffer
  3699                          
  3700  f254 ad00de             	lda tpi1+pa		; send eoi
  3701  f257 29df               	and #$FF-eoi
  3702  f259 8d00de             	sta tpi1+pa
  3703                          
  3704  f25c a5ab               	lda bsour		; get byte to send
  3705  f25e 20c0f2             	jsr tbyte		; send last character
  3706                          
  3707  f261 a5aa               	lda c3po		; clear byte in buffer flag
  3708  f263 297f               	and #$FF-dibf
  3709  f265 85aa               	sta c3po
  3710                          
  3711  f267 ad00de             	lda tpi1+pa		; clear eoi
  3712  f26a 0920               	ora #eoi
  3713  f26c 8d00de             	sta tpi1+pa
  3714                          
  3715  f26f ad00de             list2:	lda tpi1+pa		; assert atn
  3716  f272 29f7               	and #$FF-atn
  3717  f274 8d00de             	sta tpi1+pa
  3718                          
  3719  f277 68                 	pla			; get talk/listen address
  3720  f278 4cc0f2             	jmp tbyte
  3721                          ; -------------------------------------------------------------------------------------------------
  3722                          ; F27B Send secondary address after listen
  3723  f27b 20c0f2             nsecnd:	jsr tbyte		; send it      
  3724                          ; release attention after listen       
  3725                          scat1:
  3726  f27e ad00de             scatn:	lda tpi1+pa		; de-assert atn
  3727  f281 0908               	ora #atn
  3728  f283 8d00de             	sta tpi1+pa
  3729  f286 60                 	rts
  3730                          ; -------------------------------------------------------------------------------------------------
  3731                          ; F287 Talk second address
  3732  f287 20c0f2             ntksa:	jsr tbyte		; send secondary address
  3733                          
  3734  f28a a939               tkatn:	lda #$FF-nrfd-ndac-te-ren ; pull nrfd and ndac low
  3735  f28c 2d00de             	and tpi1+pa
  3736                          ; exit entry for untalk/unlisten
  3737  f28f 8d00de             setlns:	sta tpi1+pa
  3738  f292 a9c7               	lda #rddb		; set control lines for input
  3739  f294 8d03de             	sta tpi1+ddpa
  3740  f297 a900               	lda #$00		; set data lines for recieve
  3741  f299 8d02dc             	sta cia+ddra
  3742  f29c f0e0               	beq scatn
  3743                          ; -------------------------------------------------------------------------------------------------
  3744                          ; F29E Buffered output to ieee-488
  3745  f29e 48                 nciout:	pha			; save data
  3746  f29f a5aa               	lda c3po		; get ieee flags
  3747  f2a1 1007               	bpl ci1			; if no data in buffer
  3748  f2a3 a5ab               	lda bsour		; get data in buffer
  3749  f2a5 20c0f2             	jsr tbyte		; transmit byte
  3750  f2a8 a5aa               	lda c3po		; get ieee flags
  3751                          
  3752  f2aa 0980               ci1:	ora #dibf		; set data in buffer flag
  3753  f2ac 85aa               	sta c3po
  3754                          
  3755  f2ae 68                 	pla			; get new data
  3756  f2af 85ab               	sta bsour
  3757  f2b1 60                 	rts
  3758                          ; -------------------------------------------------------------------------------------------------
  3759                          ; F2B2 Send untalk command on ie
  3760  f2b2 a95f               nuntlk:	lda #utlkr		; untalk command
  3761  f2b4 d002               	bne unls1		; always
  3762                          
  3763                          ; send unlisten command on ieee-488
  3764  f2b6 a93f               nunlsn:	lda #ulstn		; unlisten command
  3765  f2b8 203df2             unls1:	jsr list1		; send it
  3766  f2bb a9f9               	lda #$FF-te-ren		; set for recieve all lines high
  3767  f2bd 4c8ff2             	jmp setlns		; go setup proper exit state
  3768                          ; -------------------------------------------------------------------------------------------------
  3769                          ; tbyte -- output byte onto ieee bus.
  3770                          ;   entry a = data byte to be output.
  3771                          ;   uses a register. 1 byte of stack space.
  3772                          ; F2C0
  3773  f2c0 49ff               tbyte:	eor #$FF	; compliment data
  3774  f2c2 8d00dc             	sta cia+pra
  3775                          
  3776  f2c5 ad00de             	lda tpi1+pa
  3777  f2c8 0912               	ora #dav+te		; say data not valid, te=data out
  3778  f2ca 8d00de             	sta tpi1+pa
  3779                          
  3780  f2cd 2c00de             	bit tpi1+pa		; test nrfd & ndac in high state
  3781  f2d0 5009               	bvc tby2		; either nrfd or ndac low => ok
  3782  f2d2 1007               	bpl tby2
  3783                          
  3784  f2d4 a980               tby1:	lda #nodev		; set no-device bit in status
  3785  f2d6 206efb             	jsr udst
  3786  f2d9 d030               	bne tby7		; always exit
  3787                          
  3788  f2db ad00de             tby2:	lda tpi1+pa
  3789  f2de 10fb               	bpl tby2		; if nrfd is high
  3790                          
  3791  f2e0 29ef               	and #$FF-dav
  3792  f2e2 8d00de             	sta tpi1+pa
  3793                          
  3794  f2e5 2076f3             tby3:	jsr timero		; set timeout
  3795  f2e8 9001               	bcc tby4		; c-clear means first time through
  3796  f2ea 38                 tby3t:	sec			; c-set is second time
  3797                          
  3798  f2eb 2c00de             tby4:	bit tpi1+pa
  3799  f2ee 7013               	bvs tby6		; if ndac hi
  3800  f2f0 ad0ddc             	lda cia+icr
  3801  f2f3 2902               	and #$02		; timer b posistion (cia)
  3802  f2f5 f0f4               	beq tby4		; if no timeout
  3803  f2f7 ad5e03             	lda timout		; timeout selection flag
  3804  f2fa 30e9               	bmi tby3		; no - loop
  3805  f2fc 90ec               	bcc tby3t		; wait full 64us
  3806                          
  3807  f2fe a901               tby5:	lda #toout		; set timeout on output in status
  3808  f300 206efb             	jsr udst		; update status
  3809                          
  3810  f303 ad00de             tby6:	lda tpi1+pa		; release dav
  3811  f306 0910               	ora #dav
  3812  f308 8d00de             	sta tpi1+pa
  3813                          
  3814  f30b a9ff               tby7:	lda #$FF		; release data bus
  3815  f30d 8d00dc             	sta cia+pra		; bus failure exit
  3816  f310 60                 	rts
  3817                          ; -------------------------------------------------------------------------------------------------
  3818                          ; rbyte -- input byte from ieee bus.
  3819                          ;   uses a register. 1 byte of stack space.
  3820                          ;   exit a = input data byte.
  3821                          ; F311
  3822                          nacptr:	; ********************************
  3823                          nrbyte:
  3824  f311 ad00de             	lda tpi1+pa		; set control lines
  3825  f314 29b9               	and #$FF-te-ndac-ren	; pull ndac low, te=data in
  3826  f316 0981               	ora #nrfd+dc		; say read for data
  3827  f318 8d00de             	sta tpi1+pa
  3828                          
  3829  f31b 2076f3             rby1:	jsr timero		; return c-clear for cbmii
  3830  f31e 9001               	bcc rby2		; c-clear is first time through
  3831  f320 38                 rby1t:	sec			; c-set is second time through
  3832                          
  3833  f321 ad00de             rby2:	lda tpi1+pa		; get ieee control lines
  3834  f324 2910               	and #dav
  3835  f326 f01e               	beq rby4		; if data available
  3836  f328 ad0ddc             	lda cia+icr
  3837  f32b 2902               	and #$02		; timer b (cia)
  3838  f32d f0f2               	beq rby2		; if not timed out
  3839  f32f ad5e03             	lda timout		; get timeout flag
  3840  f332 30e7               	bmi rby1		; loop
  3841  f334 90ea               	bcc rby1t		; go through twice
  3842                          
  3843  f336 a902               rby3:	lda #toin		; set timeout on input in status
  3844  f338 206efb             	jsr udst
  3845  f33b ad00de             	lda tpi1+pa
  3846  f33e 293d               	and #$FF-nrfd-ndac-te	; nrfd & ndac lo on error
  3847  f340 8d00de             	sta tpi1+pa
  3848  f343 a90d               	lda #cr			; return null input
  3849  f345 60                 	rts
  3850                          ; F346
  3851  f346 ad00de             rby4:	lda tpi1+pa		; say not read for data
  3852  f349 297f               	and #$FF-nrfd
  3853  f34b 8d00de             	sta tpi1+pa
  3854  f34e 2920               	and #eoi
  3855  f350 d005               	bne rby5		; if not eoi
  3856  f352 a940               	lda #eoist		; set eoi in status
  3857  f354 206efb             	jsr udst
  3858                          
  3859  f357 ad00dc             rby5:	lda cia+pra		; get data
  3860  f35a 49ff               	eor #$FF
  3861                          
  3862  f35c 48                 rby6:	pha			; save data
  3863  f35d ad00de             	lda tpi1+pa		; say data accepted
  3864  f360 0940               	ora #ndac
  3865  f362 8d00de             	sta tpi1+pa
  3866                          
  3867  f365 ad00de             rby7:	lda tpi1+pa		; get ieee control lines
  3868  f368 2910               	and #dav
  3869  f36a f0f9               	beq rby7		; if dav high
  3870                          
  3871  f36c ad00de             	lda tpi1+pa		; say dat not accpted
  3872  f36f 29bf               	and #$FF-ndac
  3873  f371 8d00de             	sta tpi1+pa
  3874  f374 68                 	pla			; return data in a
  3875  f375 60                 	rts
  3876                          ; -------------------------------------------------------------------------------------------------
  3877                          ; F376 Set up for timeout (6526)
  3878  f376 a980               timero:	lda #$80		; set time for at least 32us (cbmii $FF)
  3879                          
  3880  f378 8d07dc             	sta cia+tbhi
  3881  f37b a911               	lda #$11		; turn on timer continous in case of other irq's
  3882  f37d 8d0fdc             	sta cia+crb
  3883  f380 ad0ddc             	lda cia+icr		; clear interrupt
  3884  f383 18                 	clc
  3885  f384 60                 	rts
  3886                          ; -------------------------------------------------------------------------------------------------
  3887                          ; F385 ##### rs232 #####
  3888  f385 4c58f9             rs232:	jmp error9		; bad device number
  3889                          ; -------------------------------------------------------------------------------------------------
  3890                          ; opn232 - open an rs-232 channel
  3891                          ;   if sa=1 then output channel
  3892                          ;   if sa=2 then input  channel
  3893                          ;   if sa=3 then bidirectional channel
  3894                          ;   if sa>128 then ascii conversion enabled
  3895                          ;
  3896                          ;   filename consists of 0-4 bytes
  3897                          ;  byte #1- control register 6551
  3898                          ;  byte #2- command register 6551
  3899                          ;  byte #3- c/r lf delay...60ths of sec   (unimplemented)
  3900                          ;  byte #4- auto c/r insert afer xx chars (unimplemented)
  3901                          ;
  3902                          ;    actions:
  3903                          ;  1. clear  rs232 status:  rsstat
  3904                          ;  2. set 6551 contrl (ctr) register
  3905                          ;  3. set 6551 command (cdr) register
  3906                          ;       cdr bits (7-4) = filename byte 2 bits (7-4)
  3907                          ;                (3-2) = 00  (xmitter off)
  3908                          ;                (1)   = 1   (receiver off)
  3909                          ;                (0)   = 0   (dtr off)
  3910                          ;  4. do buffer alocatation, if needed
  3911                          ;---------------------------------------------
  3912                          ; F388
  3913  f388 2035f4             opn232:	jsr rst232		; reset rs232 status
  3914  f38b a000               	ldy #0
  3915                          
  3916  f38d c49d               opn020:	cpy fnlen		; filename all out ?
  3917  f38f f00b               	beq opn030		; yes...
  3918                          
  3919  f391 208dfe             	jsr fnadry
  3920  f394 997603             	sta m51ctr,y
  3921  f397 c8                 	iny
  3922  f398 c004               	cpy #4			; only four bytes in all
  3923  f39a d0f1               	bne opn020
  3924                          
  3925  f39c ad7603             opn030:	lda m51ctr		; set the register
  3926  f39f 8d03dd             	sta acia+ctr
  3927  f3a2 ad7703             	lda m51cdr		; clear up conflicts
  3928  f3a5 29f2               	and #$F2
  3929  f3a7 0902               	ora #$02
  3930  f3a9 8d02dd             	sta acia+cdr		; everything off
  3931  f3ac 18                 	clc
  3932  f3ad a5a0               	lda sa			; check for buffers needed
  3933  f3af 2902               	and #$02
  3934  f3b1 f015               	beq opn045		; no input
  3935                          
  3936  f3b3 ad7d03             	lda ridbe		; set up pointers
  3937  f3b6 8d7c03             	sta ridbs
  3938  f3b9 a5a8               	lda ribuf+2		; check for allocation
  3939  f3bb 29f0               	and #$F0		; $ff not allocated flag (see alloc error codes, too)
  3940  f3bd f009               	beq opn045		; already allocated
  3941  f3bf 2003f4             	jsr req256		; request 256 bytes for storage
  3942  f3c2 85a8               	sta ribuf+2		; save starting
  3943  f3c4 86a6               	stx ribuf
  3944  f3c6 84a7               	sty ribuf+1
  3945                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  3946  f3c8 4c41ed             opn045:	jmp patch4a3		; ***** patch 4a-3 - RS232 output *****
  3947  f3cb ea                 	nop
  3948  f3cc ea                 	nop
  3949                          } else{
  3950                          opn045:	bcc opn050
  3951                          	jmp errorx
  3952                          }
  3953                          
  3954  f3cd 60                 opn050:	rts			; c-clr already allocated
  3955                          ; -------------------------------------------------------------------------------------------------
  3956                          ; toasci - convert cbm text code to
  3957                          ;  ascii for valid ascii ranges.
  3958                          ; entry: .a - cbm text code
  3959                          ; exit : .a - ascii code
  3960                          ;----------------------------------------
  3961                          ; F3CE
  3962  f3ce c941               toasci:	cmp #'a'		; convert $41 to $5a
  3963  f3d0 9010               	bcc toa020
  3964  f3d2 c95b               	cmp #$5B
  3965  f3d4 b002               	bcs toa010
  3966  f3d6 0920               	ora #$20		; to lower case ascii
  3967  f3d8 c9c1               toa010:	cmp #$C1		; convert $c1 to $da
  3968  f3da 9006               	bcc toa020
  3969  f3dc c9db               	cmp #$DB
  3970  f3de b002               	bcs toa020
  3971  f3e0 297f               	and #$7F		; to upper case ascii
  3972  f3e2 60                 toa020:	rts
  3973                          ; -------------------------------------------------------------------------------------------------
  3974                          ; tocbm - convert ascii code to cbm
  3975                          ;  text code for valid ascii ranges.
  3976                          ; entry: .a - ascii code
  3977                          ; exit : .a - cbm text code
  3978                          ;----------------------------------------
  3979                          ; F3E3
  3980  f3e3 c941               tocbm:	cmp #'a'		; convert upper case ascii
  3981  f3e5 9010               	bcc toc020
  3982  f3e7 c95b               	cmp #$5B
  3983  f3e9 b002               	bcs toc010
  3984  f3eb 0980               	ora #$80		; to $c1 to $da
  3985  f3ed c961               toc010:	cmp #$61		; convert lower case ascii
  3986  f3ef 9006               	bcc toc020
  3987  f3f1 c97b               	cmp #$7B
  3988  f3f3 b002               	bcs toc020
  3989  f3f5 29df               	and #$FF-$20		; to $41 - $5a
  3990  f3f7 60                 toc020:	rts
  3991                          ; -------------------------------------------------------------------------------------------------
  3992                          ; xon232 - turn 6551 transmitter on, no transmit interrupts
  3993                          ;        cdr bits(3-2) = 10
  3994                          ;            bit(1)    = 1
  3995                          ;---------------------------------------------------------------
  3996                          ; F3F8
  3997  f3f8 ad02dd             xon232:	lda acia+cdr
  3998  f3fb 0909               	ora #$09
  3999  f3fd 29fb               	and #$FB
  4000  f3ff 8d02dd             	sta acia+cdr
  4001  f402 60                 	rts
  4002                          ; -------------------------------------------------------------------------------------------------
  4003                          ; F403 req256 - request 256 bytes of space
  4004                          ;  (don't care where we get it...)
  4005  f403 a200               req256:	ldx #00
  4006  f405 a001               	ldy #01		; one page = 256 bytes
  4007                          ; -------------------------------------------------------------------------------------------------
  4008                          ; alocat - alocatate space
  4009                          ;  entry:
  4010                          ; *  .a- if .a=$ff then don't care what segment
  4011                          ; *  .a- if .a=$80 then we want bottom of memory
  4012                          ; *  .a- if .a=$40 then we want top of memory
  4013                          ; *  .a- if .a=$0x then we need segment x
  4014                          ;    .x- low # of bytes needed
  4015                          ;    .y- high # of bytes needed
  4016                          ;
  4017                          ;  exit :
  4018                          ;    c-clr  no problem alocatating space
  4019                          ;     .a,.x,.y is start address of alocatated space
  4020                          ;    c-set  problem with alocatation
  4021                          ;     if .a =$ff then alocatation refused (cannot cross segment boundrys)
  4022                          ; *   if .a =$8x then bottom of memory needs to be changed
  4023                          ;     if .a =$4x then top of memory needs to be changed
  4024                          ; *   if .a =$c0 then bottom>top  !! fatal error !!
  4025                          ;     return to language
  4026                          ;
  4027                          ; *=> not implemented yet  10/30/81 rsr (only top alocatation)
  4028                          ;-----------------------------------------------------------------------
  4029                          ; F407
  4030                          alocat:
  4031  f407 8a                 tttop:	txa			; calc new hiadr
  4032  f408 38                 	sec
  4033  f409 49ff               	eor #$FF
  4034  f40b 6d5503             	adc hiadr		; sub low from end of system RAM
  4035  f40e aa                 	tax
  4036  f40f 98                 	tya
  4037  f410 49ff               	eor #$FF
  4038  f412 6d5603             	adc hiadr+1		; sub high
  4039  f415 a8                 	tay
  4040  f416 ad5703             	lda hiadr+2		; load highest system RAM bank
  4041  f419 b006               	bcs top010
  4042  f41b a9ff               refuse:	lda #$FF		; allocation refused...crossed boundry
  4043  f41d 0940               topbad:	ora #$40		; want top of memory changed
  4044  f41f 38                 	sec			; C=1 Not enough memory available 
  4045  f420 60                 	rts			; return unsuccessful
  4046                          
  4047  f421 cc5c03             top010:	cpy memsiz+1		; compare new high address with user memory high
  4048  f424 90f7               	bcc topbad		; branch if new high lower = not enough memory alocatatable
  4049  f426 d005               	bne topxit		; branch to memoryok if new high > 
  4050  f428 ec5b03             	cpx memsiz		; if higbyte equal compare low
  4051  f42b 90f0               	bcc topbad		; branch if lower = not enough memory alocatatable
  4052  f42d 8e5503             topxit:	stx hiadr		; store new end of system memory ($)
  4053  f430 8c5603             	sty hiadr+1
  4054  f433 18                 	clc
  4055  f434 60                 	rts
  4056                          ; -------------------------------------------------------------------------------------------------
  4057                          ; rst232 - reset rs232 and dcd/dsr status
  4058                          ;          note, the dcd and dsr bits of rsstat reflect whether a
  4059                          ;          dsr or dcd error occured since the last time the user
  4060                          ;          examined rsstat.
  4061                          ;          dcdsr has the dcd/dsr states prior to their last state
  4062                          ;          changes.
  4063                          ;-----------------------------------------------------------------
  4064                          ; F435
  4065  f435 08                 rst232:	php
  4066  f436 78                 	sei			; disable ints
  4067  f437 ad01dd             	lda acia+srsn
  4068  f43a 2960               	and #$60
  4069  f43c 8d7a03             	sta rsstat
  4070  f43f 8d7b03             	sta dcdsr
  4071  f442 28                 	plp
  4072  f443 60                 	rts
  4073                          ; -------------------------------------------------------------------------------------------------
  4074                          ; ##### channelio #####
  4075                          ;*****************************************
  4076                          ;* getin -- get character from channel   *
  4077                          ;*      channel is determined by dfltn.  *
  4078                          ;* if device is 0, keyboard queue is     *
  4079                          ;* examined and a character removed if   *
  4080                          ;* available.  devices 1,3-31 advance to *
  4081                          ;* basin.                                *
  4082                          ;*                                       *
  4083                          ;* exit:  .a = character                 *
  4084                          ;*        cy = 1, stop key error for cas-*
  4085                          ;*                cassetes and rs232     *
  4086                          ;*           = 0, otherwise.             *
  4087                          ;*        z  = 1, if kbd and queue empty.*
  4088                          ;*****************************************
  4089                          ; F444
  4090  f444 a5a1               ngetin:	lda dfltn		; check device
  4091  f446 d00c               	bne gn10		; not keyboard
  4092                          
  4093  f448 a5d1               	lda ndx			; queue index
  4094  f44a 05d6               	ora kyndx		; check function key que
  4095  f44c f053               	beq gn20		; nobody there...exit
  4096                          
  4097  f44e 78                 	sei
  4098  f44f 2007e0             	jsr jlp2		; go remove a character
  4099  f452 18                 	clc
  4100  f453 60                 	rts
  4101                          
  4102                          ; Check for input from device 2 = RS232
  4103  f454 c902               gn10:	cmp #2			; is it rs-232
  4104  f456 f003               	beq gn232
  4105  f458 4ccfff             	jmp basin		; no...use basin
  4106                          
  4107                          ; getin RS232
  4108  f45b 8c6503             gn232:	sty xsav		; save .y...
  4109  f45e 8e6603             	stx savx		; ..and .x
  4110  f461 ac7c03             	ldy ridbs		; get last byte address
  4111  f464 cc7d03             	cpy ridbe		; see if buffer emptyy
  4112  f467 d016               	bne gn15		; rs232 buffer not empty...
  4113                          
  4114  f469 ad02dd             	lda acia+cdr		; make sure receiver is on
  4115  f46c 29fd               	and #$FD
  4116  f46e 0901               	ora #$01		; bits(10) = 01 now
  4117  f470 8d02dd             	sta acia+cdr
  4118  f473 ad7a03             	lda rsstat		; set empty input buffer condition
  4119  f476 0910               	ora #$10
  4120  f478 8d7a03             	sta rsstat
  4121  f47b a900               	lda #0			; return a null byte
  4122  f47d f01c               	beq gnexit		; always
  4123                          
  4124                          ; Get one byte from RS232 input buffer
  4125  f47f ad7a03             gn15:	lda rsstat		; clear empty buffer status
  4126  f482 29ef               	and #$ef
  4127  f484 8d7a03             	sta rsstat
  4128  f487 a601               	ldx i6509
  4129  f489 a5a8               	lda ribuf+2
  4130  f48b 8501               	sta i6509		; point at buffer
  4131  f48d b1a6               	lda (ribuf),y		; get last char
  4132  f48f 8601               	stx i6509		; restore
  4133  f491 ee7c03             	inc ridbs		; inc to next posistion
  4134  f494 24a0               	bit sa			; check for ascii flag
  4135  f496 1003               	bpl gnexit		; not on...
  4136  f498 20e3f3             	jsr tocbm		; convert to cbm code
  4137  f49b ac6503             gnexit:	ldy xsav		; restore .y
  4138  f49e ae6603             	ldx savx
  4139  f4a1 18                 gn20:	clc			; good return
  4140  f4a2 60                 	rts
  4141                          ; -------------------------------------------------------------------------------------------------
  4142                          ;***************************************
  4143                          ;* basin-- input character from channel*
  4144                          ;*     input differs from get on device*
  4145                          ;* #0 function which is keyboard. the  *
  4146                          ;* screen editor makes ready an entire *
  4147                          ;* line which is passed char by char   *
  4148                          ;* up to the carriage return.  note,   *
  4149                          ;* rs232 uses getin to get each char.  *
  4150                          ;* other devices are:                  *
  4151                          ;*      0 -- keyboard                  *
  4152                          ;*      1 -- cassette #1               *
  4153                          ;*      2 -- rs232                     *
  4154                          ;*      3 -- screen                    *
  4155                          ;*   4-31 -- ieee   bus                *
  4156                          ;*                                     *
  4157                          ;* exit: cy=1, stop key error for cas- *
  4158                          ;*             settes and rs232.       *
  4159                          ;*       cy=0, otherwise.              *
  4160                          ;*                                     *
  4161                          ;*       all other errors must be de-  *
  4162                          ;*       tected by checking status !   *
  4163                          ;***************************************
  4164                          ; F4A3
  4165  f4a3 a5a1               nbasin:	lda dfltn		; check device
  4166  f4a5 d00b               	bne bn10		; is not keyboard...
  4167                          
  4168                          ; input from keyboard
  4169  f4a7 a5cb               	lda pntr		; save current...
  4170  f4a9 85ce               	sta lstp		; ... cursor column
  4171  f4ab a5ca               	lda tblx		; save current...
  4172  f4ad 85cf               	sta lsxp		; ... line number
  4173  f4af 4cbcf4             	jmp bn15		; blink cursor until return
  4174                          
  4175  f4b2 c903               bn10:	cmp #3			; is input from screen?
  4176  f4b4 d00b               	bne bn20		; no...
  4177                          
  4178                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  4179  f4b6 2035ed             	jsr patch4a4		; ***** patch 4a-4 - remember bootom line no *****
  4180  f4b9 ea                 	nop
  4181                          } else{
  4182                          	sta crsw		; fake a carriage return
  4183                          	lda scrt		; say we ended...
  4184                          }
  4185  f4ba 85d5               	sta indx		; ...up on this line
  4186  f4bc 200ae0             bn15:	jsr jloop5		; pick up characters
  4187  f4bf 18                 	clc
  4188  f4c0 60                 	rts
  4189                          
  4190  f4c1 b007               bn20:	bcs bn30		; devices >3
  4191  f4c3 c902               	cmp #2			; rs232?
  4192  f4c5 f010               	beq bn50
  4193                          
  4194  f4c7 2068fe             	jsr xtape		; go to tape indirect
  4195                          
  4196                          ; input from ieee bus
  4197  f4ca a59c               bn30:	lda status		; status from last
  4198  f4cc f004               	beq bn35		; was good
  4199  f4ce a90d               bn31:	lda #$D			; bad...all done
  4200  f4d0 18                 bn32:	clc			; valid data
  4201  f4d1 60                 bn33:	rts
  4202                          
  4203  f4d2 20a5ff             bn35:	jsr acptr		; good...handshake
  4204  f4d5 18                 	clc
  4205  f4d6 60                 	rts
  4206                          
  4207                          ; input from rs232
  4208  f4d7 20e4ff             bn50:	jsr getin		; get data
  4209  f4da b0f5               	bcs bn33		; error return
  4210  f4dc c900               	cmp #00			; non-null means good data always
  4211  f4de d0f0               	bne bn32		; have valid data
  4212  f4e0 ad7a03             	lda rsstat		; check for valid null byte
  4213  f4e3 2910               	and #$10
  4214  f4e5 f0e9               	beq bn32		; ok
  4215  f4e7 ad7a03             	lda rsstat		; buffer empty, check for errors in dsr, dcd
  4216  f4ea 2960               	and #dsrerr+dcderr
  4217  f4ec d0e0               	bne bn31		; have error...send c/r's
  4218  f4ee 20e1ff             	jsr stop		; check for stop key depressed
  4219  f4f1 d0e4               	bne bn50		; no, stay in loop 'til we get something
  4220  f4f3 38                 	sec			; .a=0, stop key error
  4221  f4f4 60                 	rts
  4222                          ; -------------------------------------------------------------------------------------------------
  4223                          ;***************************************
  4224                          ;* bsout -- out character to channel   *
  4225                          ;*     determined by variable dflto:   *
  4226                          ;*     0 -- invalid                    *
  4227                          ;*     1 -- cassette #1                *
  4228                          ;*     2 -- rs232                      *
  4229                          ;*     3 -- screen                     *
  4230                          ;*  4-31 -- ieee   bus                 *
  4231                          ;*                                     *
  4232                          ;* exit:  cy=1, stop key error for cas-*
  4233                          ;*              settes and rs232.      *
  4234                          ;*        cy=0, otherwise.             *
  4235                          ;*                                     *
  4236                          ;*       note, other errors must be de-*
  4237                          ;*       tected by checking status !   *
  4238                          ;***************************************
  4239                          ; F4F5
  4240  f4f5 48                 nbsout:	pha			; preserve .a
  4241  f4f6 a5a2               	lda dflto		; check device
  4242  f4f8 c903               	cmp #3			; is it the screen?
  4243  f4fa d006               	bne bo10		; no...
  4244                          
  4245                          ; print to crt
  4246  f4fc 68                 	pla			; restore data
  4247  f4fd 200de0             	jsr jprt		; print on crt
  4248  f500 18                 	clc
  4249  f501 60                 	rts
  4250                          
  4251  f502 9006               bo10:	bcc bo20		; device 1 or 2
  4252                          
  4253                          ; print to ieee   bus
  4254  f504 68                 	pla
  4255  f505 20a8ff             	jsr ciout
  4256  f508 18                 	clc
  4257  f509 60                 	rts
  4258                          
  4259                          ; print to cassette devices
  4260  f50a c902               bo20:	cmp #2			; rs232?
  4261  f50c f00a               	beq bo50
  4262                          
  4263  f50e 68                 	pla
  4264  f50f 2068fe             	jsr xtape		; go to tape indirect
  4265                          
  4266  f512 68                 rstbo:	pla			; restore .a (error exit for 232)
  4267  f513 9002               	bcc rstor1		; no error
  4268  f515 a900               	lda #00			; stop error if c-set
  4269  f517 60                 rstor1:	rts
  4270                          
  4271                          ; output to rs232
  4272  f518 8e6303             bo50:	stx t1			; put in a temp
  4273  f51b 8c6403             	sty t2
  4274                          
  4275  f51e ad7a03             bo55:	lda rsstat		; check for dsr,dcd errors
  4276  f521 2960               	and #$60
  4277  f523 d022               	bne bo90		; bad....
  4278                          
  4279  f525 68                 bo70:	pla			; restore data
  4280  f526 24a0               	bit sa			; check for cbm to ascii conversion
  4281  f528 1003               	bpl bo80		; none
  4282  f52a 20cef3             	jsr toasci		; convert cbm to ascii
  4283  f52d 8d00dd             bo80:	sta acia+drsn		; sending data
  4284  f530 48                 	pha
  4285                          
  4286  f531 ad7a03             bo60:	lda rsstat
  4287  f534 2960               	and #$60		; dcd,dsr errors?
  4288  f536 d00f               	bne bo90		; yes...
  4289  f538 ad01dd             bo64:	lda acia+srsn
  4290  f53b 2910               	and #$10		; transmit buffer empty?
  4291  f53d d008               	bne bo90		; yes, transmit done!
  4292  f53f 20e1ff             	jsr stop		; check for stop key
  4293  f542 d0ed               	bne bo60		; try again
  4294  f544 38                 bo66:	sec			; stop key/error return
  4295  f545 b0cb               	bcs rstbo		; exit....
  4296                          
  4297  f547 68                 bo90:	pla
  4298  f548 ae6303             	ldx t1          ;go restore
  4299  f54b ac6403             	ldy t2
  4300  f54e 18                 	clc
  4301  f54f 60                 	rts
  4302                          ; -------------------------------------------------------------------------------------------------
  4303                          ; ##### openchannel #####
  4304                          ;***************************************
  4305                          ;* nchkin -- open channel for input    *
  4306                          ;*                                     *
  4307                          ;* the number of the logical file to be*
  4308                          ;* opened for input is passed in .x.   *
  4309                          ;* chkin searches the logical file     *
  4310                          ;* to look up device and command info. *
  4311                          ;* errors are reported if the device   *
  4312                          ;* was not opened for input ,(e.g.     *
  4313                          ;* cassette write file), or the logical*
  4314                          ;* file has no reference in the tables.*
  4315                          ;* device 0, (keyboard), and device 3  *
  4316                          ;* (screen), require no table entries  *
  4317                          ;* and are handled separate.           *
  4318                          ;***************************************
  4319                          ; F550
  4320  f550 2045f6             nchkin:	jsr lookup		; see if file known
  4321  f553 f003               	beq jx310		; yup...
  4322                          
  4323  f555 4c46f9             	jmp error3		; no...file not open
  4324                          
  4325  f558 2057f6             jx310:	jsr jz100		; extract file info
  4326  f55b a59f               	lda fa
  4327  f55d f02e               	beq jx320		; is keyboard...done.
  4328                          
  4329                          ; could be screen, keyboard, or serial
  4330  f55f c903               	cmp #3
  4331  f561 f02a               	beq jx320		; is screen...done.
  4332  f563 b02c               	bcs jx330		; is serial...address it
  4333  f565 c902               	cmp #2			; rs232?
  4334  f567 d01e               	bne jx315		; no...
  4335                          
  4336                          ; rs232 channel
  4337  f569 a5a0               	lda sa
  4338  f56b 2902               	and #02			; check for input
  4339  f56d f01b               	beq jx316		; not input file
  4340  f56f 2d02dd             	and acia+cdr		; check if running
  4341  f572 f00f               	beq jx312		; is...done ?? (rceiver on => yes)
  4342  f574 49ff               	eor #$FF		; flip all bits
  4343  f576 2d02dd             	and acia+cdr		; turn on...
  4344  f579 0901               	ora #$01		; turn on dtr ;bits(10)=01
  4345  f57b 48                 	pha
  4346  f57c 2035f4             	jsr rst232		; reset rs232 status
  4347  f57f 68                 	pla
  4348  f580 8d02dd             	sta acia+cdr		; set command
  4349  f583 a902               jx312:	lda #2			; device
  4350  f585 d006               	bne jx320		; bra...done
  4351                          
  4352                          ; some extra checks for tape
  4353  f587 2068fe             jx315:	jsr xtape		; goto tape indirect
  4354                          
  4355  f58a 4c4ff9             jx316:	jmp error6		; not input file
  4356                          
  4357  f58d 85a1               jx320:	sta dfltn		; all input come from here
  4358                          
  4359  f58f 18                 	clc			; good exit
  4360  f590 60                 	rts
  4361                          
  4362                          ; an serial device has to be a talker
  4363  f591 aa                 jx330:	tax			; device # for dflto
  4364  f592 20b4ff             	jsr talk		; tell him to talk
  4365                          
  4366  f595 a5a0               	lda sa			; a second?
  4367  f597 1006               	bpl jx340		; yes...send it
  4368  f599 208af2             	jsr tkatn		; no...let go
  4369  f59c 4ca2f5             	jmp jx350
  4370                          
  4371  f59f 2096ff             jx340:	jsr tksa		; send second
  4372                          
  4373  f5a2 8a                 jx350:	txa
  4374  f5a3 249c               	bit status		; did he listen?
  4375  f5a5 10e6               	bpl jx320		; yes
  4376                          
  4377  f5a7 4c4cf9             	jmp error5		; device not present
  4378                          ; -------------------------------------------------------------------------------------------------
  4379                          ;***************************************
  4380                          ;* chkout -- open channel for output   *
  4381                          ;*                                     *
  4382                          ;* the number of the logical file to be*
  4383                          ;* opened for output is passed in .x.  *
  4384                          ;* chkout searches the logical file    *
  4385                          ;* to look up device and command info. *
  4386                          ;* errors are reported if the device   *
  4387                          ;* was not opened for input ,(e.g.     *
  4388                          ;* keyboard), or the logical file has  *
  4389                          ;* reference in the tables.            *
  4390                          ;* device 0, (keyboard), and device 3  *
  4391                          ;* (screen), require no table entries  *
  4392                          ;* and are handled separate.           *
  4393                          ;***************************************
  4394                          ; F5AA
  4395  f5aa 2045f6             nckout:	jsr lookup		; is file in table?
  4396  f5ad f003               	beq ck5			; yes...
  4397                          
  4398  f5af 4c46f9             	jmp error3		; no...file not open
  4399                          
  4400  f5b2 2057f6             ck5:	jsr jz100		; extract table info
  4401  f5b5 a59f               	lda fa			; is it keyboard?
  4402  f5b7 d003               	bne ck10		; no...something else.
  4403                          
  4404  f5b9 4c52f9             ck20:	jmp error7		; yes...not output file
  4405                          
  4406                          ;could be screen,serial,or tapes
  4407  f5bc c903               ck10:	cmp #3
  4408  f5be f018               	beq ck30		; is screen...done
  4409  f5c0 b01a               	bcs ck40		; is serial...address it
  4410  f5c2 c902               	cmp #2			; rs232?
  4411  f5c4 d00f               	bne ck15
  4412                          
  4413                          ; rs232 output
  4414  f5c6 a5a0               	lda sa			; check if output file
  4415  f5c8 4a                 	lsr
  4416  f5c9 90ee               	bcc ck20		; not so...
  4417  f5cb 2035f4             	jsr rst232		; reset rs232 status
  4418  f5ce 20f8f3             	jsr xon232		; make sure transmit is on
  4419  f5d1 a902               	lda #2			; device#
  4420  f5d3 d003               	bne ck30		; bra...done
  4421                          
  4422                          ; special tape channel handling
  4423  f5d5 2068fe             ck15:	jsr xtape		; goto system tape indirect
  4424                          
  4425  f5d8 85a2               ck30:	sta dflto		; all output goes here
  4426                          
  4427  f5da 18                 	clc			; good exit
  4428  f5db 60                 	rts
  4429                          
  4430  f5dc aa                 ck40:	tax			; save device for dflto
  4431  f5dd 20b1ff             	jsr listn		; tell him to listen
  4432                          
  4433  f5e0 a5a0               	lda sa			; is there a second?
  4434  f5e2 1005               	bpl ck50		; yes...
  4435                          
  4436  f5e4 207ef2             	jsr scatn		; no...release lines
  4437  f5e7 d003               	bne ck60		; branch always
  4438                          
  4439  f5e9 2093ff             ck50:	jsr secnd		; send second...
  4440                          
  4441  f5ec 8a                 ck60:	txa
  4442  f5ed 249c               	bit status		; did he listen?
  4443  f5ef 10e7               	bpl ck30		; yes...finish up
  4444                          
  4445  f5f1 4c4cf9             	jmp error5		; no...device not present
  4446                          ; -------------------------------------------------------------------------------------------------
  4447                          ; ##### close #####
  4448                          ;*************************************
  4449                          ;* nclose -- close logical file      *
  4450                          ;*                                   *
  4451                          ;* enter:                            *
  4452                          ;*     cy =1 ,transmit close to dev- *
  4453                          ;*            ice.                   *
  4454                          ;*     cy =0 ,only remove from kernal*
  4455                          ;*            tables.                *
  4456                          ;*                                   *
  4457                          ;*     the logical file number of the*
  4458                          ;* file to be closed is passed in .a.*
  4459                          ;* keyboard, screen, and files not   *
  4460                          ;* open pass straight through. tape  *
  4461                          ;* files open for write are closed by*
  4462                          ;* dumping the last buffer and       *
  4463                          ;* conditionally writing an end of   *
  4464                          ;* tape block.serial files are closed*
  4465                          ;* by sending a close file command if*
  4466                          ;* a secondary address was specified *
  4467                          ;* in its open command.              *
  4468                          ;*************************************
  4469                          ; F5F4
  4470  f5f4 08                 nclose:	php			; save cy flag
  4471  f5f5 204af6             	jsr jltlk		; look file up
  4472  f5f8 f003               	beq jx110		; was open...continue
  4473  f5fa 28                 	plp
  4474  f5fb 18                 	clc			; was never open...no error
  4475  f5fc 60                 	rts
  4476                          
  4477  f5fd 2057f6             jx110:	jsr jz100		; extract table data
  4478  f600 28                 	plp			; retrieve cy flag
  4479  f601 8a                 	txa			; save table index
  4480  f602 48                 	pha
  4481  f603 901f               	bcc jx150		; close out table entries only
  4482                          
  4483  f605 a59f               	lda fa			; check device number
  4484  f607 f01b               	beq jx150		; is keyboard...done
  4485  f609 c903               	cmp #3
  4486  f60b f017               	beq jx150		; is screen...done
  4487  f60d b012               	bcs jx120		; is ieee...process
  4488  f60f c902               	cmp #2			; rs232?
  4489  f611 d007               	bne jx115		; no...
  4490                          
  4491                          ; close rs-232 file
  4492  f613 a900               cls232:	lda #0
  4493  f615 8d02dd             	sta acia+cdr		; do a soft reset
  4494  f618 f00a               	beq jx150		; jmp...remove file
  4495                          
  4496                          ; close cassette file
  4497  f61a 68                 jx115:	pla			; cassette now closes the channel...
  4498  f61b 2025f6             	jsr jx151		; before transmitting out the final data
  4499  f61e 2068fe             	jsr xtape		; goto tape indirect
  4500                          
  4501                          ; close an ieee file
  4502  f621 20c6f8             jx120:	jsr clsei
  4503                          
  4504                          ; entry to remove a give logical file from table of logical, primary, and secondary addresses
  4505  f624 68                 jx150:	pla			; get table index off stack
  4506  f625 aa                 jx151:	tax			; entry for cassette special
  4507  f626 ce6003             	dec ldtnd
  4508  f629 ec6003             	cpx ldtnd		; is deleted file at end?
  4509  f62c f015               	beq jx160		; yes...done
  4510                          
  4511                          ; delete entry in middle by moving last entry to that position.
  4512  f62e ac6003             	ldy ldtnd
  4513  f631 b93403             	lda lat,y
  4514  f634 9d3403             	sta lat,x
  4515  f637 b93e03             	lda fat,y
  4516  f63a 9d3e03             	sta fat,x
  4517  f63d b94803             	lda sat,y
  4518  f640 9d4803             	sta sat,x
  4519  f643 18                 jx160:	clc
  4520  f644 60                 jx170:	rts			; close exit
  4521                          
  4522                          ; lookup tablized logical file data
  4523  f645 a900               lookup:	lda #0
  4524  f647 859c               	sta status
  4525  f649 8a                 	txa
  4526  f64a ae6003             jltlk:	ldx ldtnd
  4527  f64d ca                 jx600:	dex
  4528  f64e 302d               	bmi lkups4
  4529  f650 dd3403             	cmp lat,x
  4530  f653 d0f8               	bne jx600
  4531  f655 18                 	clc
  4532  f656 60                 	rts
  4533                          
  4534                          ; routine to fetch table entries
  4535  f657 bd3403             jz100:	lda lat,x
  4536  f65a 859e               	sta la
  4537  f65c bd3e03             	lda fat,x
  4538  f65f 859f               	sta fa
  4539  f661 bd4803             	lda sat,x
  4540  f664 85a0               	sta sa
  4541  f666 60                 jz101:	rts
  4542                          
  4543                          ; sa is passed in .y
  4544                          ; routine looks for match in tables
  4545                          ; carry set if not present
  4546                          ; carry clear:
  4547                          ; .a=la,.x=fa,.y=sa
  4548  f667 98                 lkupsa:	tya
  4549  f668 ae6003             	ldx ldtnd
  4550  f66b ca                 lkups2:	dex
  4551  f66c 300f               	bmi lkups4
  4552  f66e dd4803             	cmp sat,x
  4553  f671 d0f8               	bne lkups2
  4554  f673 18                 	clc
  4555  f674 2057f6             lkups3:	jsr jz100		; get table data
  4556  f677 a8                 	tay
  4557  f678 a59e               	lda la
  4558  f67a a69f               	ldx fa
  4559  f67c 60                 	rts
  4560  f67d 38                 lkups4:	sec
  4561  f67e 60                 	rts			; not found exit
  4562                          
  4563                          ; la is passed in .a
  4564                          ; routine looks for match in tables
  4565                          ; carry set if not found
  4566                          ; carry clear:
  4567                          ; .a=la,.x=fa,.y=sa
  4568  f67f aa                 lkupla:	tax
  4569  f680 2045f6             	jsr lookup
  4570  f683 90ef               	bcc lkups3
  4571  f685 60                 	rts
  4572                          ; -------------------------------------------------------------------------------------------------
  4573                          ; ##### clall #####
  4574                          ;******************************************
  4575                          ;* nclall -- close all logical files      *
  4576                          ;*      deletes all table entries and     *
  4577                          ;* restores default i/o channels          *
  4578                          ;* and clears ieee port devices           *
  4579                          ;******************************************
  4580                          ;------------------------------------------
  4581                          ; new ncall
  4582                          ;  closes all files untill done or an
  4583                          ;  error occurs.
  4584                          ;  entry:
  4585                          ;    c-clr => close all files
  4586                          ;    c-set => .a = fa (device to be closed)
  4587                          ;------------------------------------------
  4588                          ; F686 Close all logical files
  4589  f686 6e6503             nclall:	ror xsav		; save carry
  4590  f689 8d6603             	sta savx		; save .a
  4591  f68c ae6003             ncl010:	ldx ldtnd		; scan index
  4592  f68f ca                 ncl020:	dex
  4593                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  4594  f690 301b               	bmi nclrch		; all done...clear channels (dclose patch 5/31/83)
  4595                          } else{
  4596                          	bmi ncl040		; all done
  4597                          }
  4598  f692 2c6503             	bit xsav		; check for fixed fa
  4599  f695 1008               	bpl ncl030		; none...
  4600  f697 ad6603             	lda savx
  4601  f69a dd3e03             	cmp fat,x
  4602  f69d d0f0               	bne ncl020		; no match...
  4603  f69f bd3403             ncl030:	lda lat,x		; close this la
  4604  f6a2 38                 	sec			; c-set required to close
  4605  f6a3 20c3ff             	jsr close
  4606  f6a6 90e4               	bcc ncl010
  4607                          
  4608  f6a8 a900               ncl040:	lda #0			; original entry for nclall
  4609  f6aa 8d6003             	sta ldtnd		; forget all files
  4610                          ; -------------------------------------------------------------------------------------------------
  4611                          ;********************************************
  4612                          ;* nclrch -- clear channels                 *
  4613                          ;*   unlisten or untalk ieee devices, but   *
  4614                          ;* leave others alone.  default channels    *
  4615                          ;* are restored.                            *
  4616                          ;********************************************
  4617                          ; F6AD
  4618  f6ad a203               nclrch:	ldx #3
  4619  f6af e4a2               	cpx dflto		; is output channel ieee?
  4620  f6b1 b003               	bcs jx750		; no...
  4621                          
  4622  f6b3 20aeff             	jsr unlsn		; yes...unlisten it
  4623                          
  4624  f6b6 e4a1               jx750:	cpx dfltn		; is input channel ieee?
  4625  f6b8 b003               	bcs clall2		; no...
  4626                          
  4627  f6ba 20abff             	jsr untlk		; yes...untalk it
  4628                          
  4629                          ; restore default values
  4630  f6bd a203               clall2:	ldx #3
  4631  f6bf 86a2               	stx dflto		; output chan=3=screen
  4632  f6c1 a900               	lda #0
  4633  f6c3 85a1               	sta dfltn		; input chan=0=keyboard
  4634  f6c5 60                 	rts
  4635                          ; -------------------------------------------------------------------------------------------------
  4636                          ; ##### open #####
  4637                          ;***********************************
  4638                          ;*                                 *
  4639                          ;* open function                   *
  4640                          ;*                                 *
  4641                          ;* enter: cy=1, transmit command to*
  4642                          ;*              device.            *
  4643                          ;*        cy=0, perform open opera-*
  4644                          ;*              tion.              *
  4645                          ;*                                 *
  4646                          ;* la, fa, sa must be set up prior *
  4647                          ;* to the call to this routine, as *
  4648                          ;* well as the file name descript- *
  4649                          ;* tor.                            *
  4650                          ;*                                 *
  4651                          ;***********************************
  4652                          ; F6C6
  4653  f6c6 9003               nopen:	bcc     op000		; do open
  4654  f6c8 4c41f7             	jmp     tranr		; do transmit
  4655                          
  4656                          ;***********************************
  4657                          ;*                                 *
  4658                          ;* create an entry in the logical  *
  4659                          ;* files tables consisting of      *
  4660                          ;* logical file number--la, device *
  4661                          ;* number--fa, and secondary cmd-- *
  4662                          ;* sa.                             *
  4663                          ;*                                 *
  4664                          ;* a file name descriptor, fnadr & *
  4665                          ;* fnlen, is passed to this routine*
  4666                          ;*                                 *
  4667                          ;***********************************
  4668                          ; F6CB
  4669  f6cb a69e               op000:	ldx la			; check file #
  4670                          
  4671                          ; bne op98 ;is not the keyboard
  4672                          ; jmp error6 ;not input file...
  4673                          
  4674  f6cd 2045f6             op98:	jsr lookup		; see if in table
  4675  f6d0 d003               	bne op100		; not found...o.k.
  4676                          
  4677  f6d2 4c43f9             	jmp error2		; file open
  4678                          
  4679  f6d5 ae6003             op100:	ldx ldtnd		; logical device table end
  4680  f6d8 e00a               	cpx #10			; maximum # of open files
  4681  f6da 9003               	bcc op110		; less than 10...o.k.
  4682                          
  4683  f6dc 4c40f9             	jmp error1		; too many files
  4684                          
  4685  f6df ee6003             op110:	inc ldtnd		; new file
  4686  f6e2 a59e               	lda la
  4687  f6e4 9d3403             	sta lat,x		; store logical file #
  4688  f6e7 a5a0               	lda sa
  4689  f6e9 0960               	ora #$60		; make sa an ieee command
  4690  f6eb 85a0               	sta sa
  4691  f6ed 9d4803             	sta sat,x		; store command #
  4692  f6f0 a59f               	lda fa
  4693  f6f2 9d3e03             	sta fat,x		; store device #
  4694                          
  4695                          ; perform device specific open tasks
  4696  f6f5 f015               	beq op175		; is keyboard...done.
  4697  f6f7 c903               	cmp #3
  4698  f6f9 f011               	beq op175		; is screen...done.
  4699  f6fb 9005               	bcc op150		; are cassettes 1 & 2
  4700                          
  4701  f6fd 200ef7             	jsr openi		; is on ieee...open it
  4702  f700 900a               	bcc op175		; branch always...done
  4703                          
  4704                          ; perform tape open stuff
  4705  f702 c902               op150:	cmp #2
  4706  f704 d003               	bne op152
  4707                          
  4708  f706 4c88f3             	jmp opn232
  4709                          
  4710  f709 2068fe             op152:	jsr xtape		; goto tape device indirect
  4711                          
  4712  f70c 18                 op175:	clc			; flag good open
  4713  f70d 60                 op180:	rts			; exit in peace
  4714                          
  4715  f70e a5a0               openi:	lda sa
  4716  f710 302d               	bmi op50		; no sa...done
  4717                          
  4718  f712 a49d               	ldy fnlen
  4719  f714 f029               	beq op50		; no file name...done
  4720                          
  4721  f716 a59f               	lda fa
  4722  f718 20b1ff             	jsr listn		; device la to listen
  4723                          
  4724  f71b a5a0               	lda sa
  4725  f71d 09f0               	ora #$f0
  4726  f71f 2093ff             openib:	jsr secnd
  4727                          
  4728  f722 a59c               	lda status		; anybody home?
  4729  f724 1005               	bpl op35		; yes...continue
  4730                          
  4731                          ; this routine is called by other kernal routines which are called directly by os.
  4732                          ; kill return address to return to os.
  4733  f726 68                 	pla
  4734  f727 68                 	pla
  4735  f728 4c4cf9             	jmp error5		; device not present
  4736                          
  4737  f72b a59d               op35:	lda fnlen
  4738  f72d f00d               	beq op45		; no name...done sequence
  4739                          
  4740                          ; send file name over ieee
  4741  f72f a000               	ldy #0
  4742  f731 208dfe             op40:	jsr fnadry
  4743  f734 20a8ff             	jsr ciout
  4744  f737 c8                 	iny
  4745  f738 c49d               	cpy fnlen
  4746  f73a d0f5               	bne op40
  4747                          
  4748  f73c 20aeff             op45:	jsr unlsn
  4749                          
  4750  f73f 18                 op50:	clc			; no  error
  4751  f740 60                 	rts
  4752                          ; -------------------------------------------------------------------------------------------------
  4753                          ;*****************************************
  4754                          ;*  transmit command to device           *
  4755                          ;*                                       *
  4756                          ;*   fnlen,fnadr must be set up already  *
  4757                          ;*   to contain the command string.      *
  4758                          ;*   fa must be set for the device.      *
  4759                          ;*****************************************
  4760                          ; F741
  4761  f741 a59f               tranr:  lda fa
  4762  f743 20b1ff             	jsr listn
  4763  f746 a96f               	lda #$6F
  4764  f748 85a0               	sta sa
  4765  f74a 4c1ff7             	jmp openib
  4766                          ; -------------------------------------------------------------------------------------------------
  4767                          ; ##### load #####
  4768                          ;**************************************
  4769                          ;* load ram function     10/30/81     *
  4770                          ;*                                    *
  4771                          ;*  loads from cassette 1 or 2, or    *
  4772                          ;*  ieee bus devices >=4 to 31 as     *
  4773                          ;*  determined by contents of         *
  4774                          ;*  variable fa.                      *
  4775                          ;* entry:                             *
  4776                          ;*   .a(bit 7)=0 performs load        *
  4777                          ;*   .a(bit 7)=1 performs verify      *
  4778                          ;*   .a(bits 0123)=start segment      *
  4779                          ;*   .x=start address low             *
  4780                          ;*   .y=start address high            *
  4781                          ;*   if .x=$ff & .y=$ff => fixed load *
  4782                          ;* exit:                              *
  4783                          ;*   .a(bits 0123)=end segment        *
  4784                          ;*   .x=end address low               *
  4785                          ;*   .y=end address high              *
  4786                          ;*                                    *
  4787                          ;**************************************
  4788                          ; F74D
  4789  f74d 8e6f03             nload:	stx relsal		; save alt address
  4790  f750 8c7003             	sty relsah
  4791  f753 8d5f03             	sta verck		; set verify flag (n)
  4792  f756 8d7103             	sta relsas		; save start address
  4793  f759 a900               	lda #0			; clear status
  4794  f75b 859c               	sta status
  4795                          
  4796  f75d a59f               	lda fa			; check device number
  4797  f75f d003               	bne ld20
  4798                          
  4799  f761 4c58f9             ld10:	jmp error9		; bad device #-keyboard
  4800                          
  4801  f764 c903               ld20:	cmp #3
  4802  f766 f0f9               	beq ld10		; disallow screen load
  4803  f768 b003               	bcs *+5
  4804  f76a 4c17f8             	jmp ld100		; handle tapes different
  4805                          
  4806                          ; load from cbm ieee device
  4807  f76d a960               	lda #$60		; special load command
  4808  f76f 85a0               	sta sa
  4809                          
  4810  f771 a49d               	ldy fnlen		; must have file name
  4811  f773 d003               	bne ld25		; yes...ok
  4812                          
  4813  f775 4c55f9             	jmp error8		; missing file name
  4814                          
  4815  f778 2022f8             ld25:	jsr luking		; tell user looking
  4816  f77b 200ef7             	jsr openi		; open the file
  4817                          
  4818  f77e a59f               	lda fa
  4819  f780 20b4ff             	jsr talk		; establish the channel
  4820  f783 a5a0               	lda sa
  4821  f785 2096ff             	jsr tksa		; tell it to load
  4822                          
  4823  f788 20a5ff             	jsr acptr		; get first byte
  4824  f78b 8596               	sta eal
  4825  f78d 8599               	sta stal
  4826                          
  4827  f78f a59c               	lda status		; test status for error
  4828  f791 4a                 	lsr
  4829  f792 4a                 	lsr
  4830  f793 9003               	bcc *+5			; file  found...
  4831                          
  4832  f795 4c49f9             	jmp error4		; file not found error
  4833                          
  4834  f798 20a5ff             	jsr acptr
  4835  f79b 8597               	sta eah
  4836  f79d 859a               	sta stah
  4837                          
  4838  f79f 2047f8             	jsr loding		; tell user loading
  4839                          
  4840                          ; test for fixed or moveable load
  4841  f7a2 ad7103             	lda relsas		; no segment byte in storage ***
  4842  f7a5 8598               	sta eas
  4843  f7a7 859b               	sta stas
  4844  f7a9 ad6f03             	lda relsal
  4845  f7ac 2d7003             	and relsah
  4846  f7af c9ff               	cmp #$FF
  4847  f7b1 f00e               	beq ld40		; fixed load
  4848                          
  4849  f7b3 ad6f03             	lda relsal
  4850  f7b6 8596               	sta eal
  4851  f7b8 8599               	sta stal
  4852  f7ba ad7003             	lda relsah
  4853  f7bd 8597               	sta eah
  4854  f7bf 859a               	sta stah
  4855                          ;
  4856  f7c1 a9fd               ld40:	lda #$FD		; mask off timeout
  4857  f7c3 259c               	and status
  4858  f7c5 859c               	sta status
  4859                          
  4860  f7c7 20e1ff             	jsr stop		; stop key?
  4861  f7ca d003               	bne ld45		; no...
  4862                          
  4863  f7cc 4cbaf8             	jmp break		; stop key pressed
  4864                          
  4865  f7cf 20a5ff             ld45:	jsr acptr		; get byte off ieee
  4866  f7d2 aa                 	tax
  4867  f7d3 a59c               	lda status		; was there a timeout?
  4868  f7d5 4a                 	lsr
  4869  f7d6 4a                 	lsr
  4870  f7d7 b0e8               	bcs ld40		; yes...try again
  4871  f7d9 8a                 	txa
  4872                          ; change indirect pages
  4873  f7da a601               	ldx i6509
  4874  f7dc a498               	ldy eas
  4875  f7de 8401               	sty i6509
  4876  f7e0 a000               	ldy #0
  4877  f7e2 2c5f03             	bit verck		; performing verify?
  4878  f7e5 100e               	bpl ld50		; no...load
  4879  f7e7 8593               	sta sal			; use as a temp
  4880  f7e9 b196               	lda (eal),y
  4881  f7eb c593               	cmp sal
  4882  f7ed f008               	beq ld60		; okay
  4883  f7ef a910               	lda #sperr		; no good...verify error
  4884  f7f1 206efb             	jsr udst		; update status
  4885  f7f4 ad                 	!byte $AD		; skip next store
  4886                          
  4887  f7f5 9196               ld50:	sta (eal),y
  4888  f7f7 8601               ld60:	stx i6509		; restore indirect
  4889  f7f9 e696               	inc eal			; increment store addr
  4890  f7fb d00a               	bne ld64
  4891  f7fd e697               	inc eah
  4892  f7ff d006               	bne ld64
  4893  f801 e698               	inc eas
  4894  f803 a902               	lda #2			; skip $0000 $0001
  4895  f805 8596               	sta eal
  4896  f807 249c               ld64:	bit status		; eoi?
  4897  f809 50b6               	bvc ld40		; no...continue load
  4898                          
  4899  f80b 20abff             	jsr untlk		; close channel
  4900  f80e 20c6f8             	jsr clsei		; close the file
  4901  f811 4c1af8             	jmp ld180		; exit ieee load
  4902                          
  4903  f814 4c49f9             ld90:	jmp error4		; file not found
  4904                          
  4905                          ; load from tape
  4906  f817 2068fe             ld100:	jsr xtape		; goto tape indirect
  4907                          
  4908  f81a 18                 ld180:	clc			; good exit
  4909                          
  4910                          ; set up end load address
  4911  f81b a598               	lda eas
  4912  f81d a696               	ldx eal
  4913  f81f a497               	ldy eah
  4914                          
  4915  f821 60                 ld190:	rts
  4916                          
  4917                          ; subroutine to print to console: searching [for name]
  4918  f822 2c6103             luking:	bit msgflg		; supposed to print?
  4919  f825 101f               	bpl ld115
  4920  f827 a00c               	ldy #ms5-ms1		; "searching"
  4921  f829 2023f2             	jsr spmsg
  4922  f82c a59d               	lda fnlen
  4923  f82e f016               	beq ld115
  4924  f830 a017               	ldy #ms6-ms1		; "for"
  4925  f832 2023f2             	jsr spmsg
  4926                          
  4927                          ; subroutine to output file name
  4928  f835 a49d               outfn:	ldy fnlen		; is there a name?
  4929  f837 f00d               	beq ld115		; no...done
  4930  f839 a000               	ldy #0
  4931  f83b 208dfe             ld110:	jsr fnadry
  4932  f83e 20d2ff             	jsr bsout
  4933  f841 c8                 	iny
  4934  f842 c49d               	cpy fnlen
  4935  f844 d0f5               	bne ld110
  4936                          
  4937  f846 60                 ld115:	rts
  4938                          
  4939                          ; subroutine to print: loading/verifing
  4940  f847 a01b               loding:	ldy #ms10-ms1		; assume 'loading'
  4941  f849 ad5f03             	lda verck		; check flag
  4942  f84c 1002               	bpl ld410		; are doing load
  4943  f84e a02b               	ldy #ms21-ms1		; are 'verifying'
  4944  f850 4c23f2             ld410:	jmp spmsg
  4945                          
  4946                          ; rsr  fix segmentation 10/15/81
  4947                          ; rsr  6509 changes  10/15/81
  4948                          ; -------------------------------------------------------------------------------------------------
  4949                          ; ##### save #####
  4950                          ;***************************************
  4951                          ;* nsave              10/30/81         *
  4952                          ;*                                     *
  4953                          ;* saves to cassette 1 or 2, or        *
  4954                          ;* ieee devices 4>=n>=31 as selected   *
  4955                          ;* by variable fa.                     *
  4956                          ;*                                     *
  4957                          ;* .x => zpage address of start vector *
  4958                          ;* .y => zpage address of end vector   *
  4959                          ;***************************************
  4960                          ; F853
  4961  f853 b500               nsave:	lda 0,x			; get start vector
  4962  f855 8599               	sta stal
  4963  f857 b501               	lda 1,x
  4964  f859 859a               	sta stah
  4965  f85b b502               	lda 2,x
  4966  f85d 859b               	sta stas
  4967  f85f 98                 	tya
  4968  f860 aa                 	tax
  4969  f861 b500               	lda 0,x			; get end vector
  4970  f863 8596               	sta eal
  4971  f865 b501               	lda 1,x
  4972  f867 8597               	sta eah
  4973  f869 b502               	lda 2,x
  4974  f86b 8598               	sta eas
  4975                          
  4976  f86d a59f               	lda fa
  4977  f86f d003               	bne sv20
  4978                          
  4979  f871 4c58f9             sv10:	jmp error9		; bad device #
  4980                          
  4981  f874 c903               sv20:	cmp #3
  4982  f876 f0f9               	beq sv10
  4983  f878 9063               	bcc sv100
  4984  f87a a961               	lda #$61
  4985  f87c 85a0               	sta sa
  4986  f87e a49d               	ldy fnlen
  4987  f880 d003               	bne sv25
  4988                          
  4989  f882 4c55f9             	jmp error8		; missing file name
  4990                          
  4991  f885 200ef7             sv25:	jsr openi
  4992  f888 20e0f8             	jsr saving
  4993  f88b a59f               	lda fa
  4994  f88d 20b1ff             	jsr listn
  4995  f890 a5a0               	lda sa
  4996  f892 2093ff             	jsr secnd
  4997  f895 a601               	ldx i6509		; indirects switched by rd300
  4998  f897 2070fe             	jsr rd300
  4999  f89a a593               	lda sal
  5000  f89c 20a8ff             	jsr ciout
  5001  f89f a594               	lda sah
  5002  f8a1 20a8ff             	jsr ciout
  5003                          
  5004  f8a4 a000               	ldy #0
  5005  f8a6 207ffe             sv30:	jsr cmpste		; compare start to end
  5006  f8a9 b016               	bcs sv50		; have reached end
  5007  f8ab b193               	lda (sal),y
  5008  f8ad 20a8ff             	jsr ciout
  5009  f8b0 203fff             	jsr incsal
  5010  f8b3 20e1ff             	jsr stop
  5011  f8b6 d0ee               	bne sv30
  5012                          
  5013  f8b8 8601               	stx i6509		; restore indirects
  5014  f8ba 20c6f8             break:	jsr clsei
  5015  f8bd a900               	lda #0
  5016  f8bf 38                 	sec
  5017  f8c0 60                 	rts
  5018                          
  5019  f8c1 8601               sv50:	stx i6509		; restore indirects
  5020  f8c3 20aeff             	jsr unlsn
  5021                          
  5022  f8c6 24a0               clsei:	bit sa
  5023  f8c8 3011               	bmi clsei2
  5024  f8ca a59f               	lda fa
  5025  f8cc 20b1ff             	jsr listn
  5026  f8cf a5a0               	lda sa
  5027  f8d1 29ef               	and #$EF
  5028  f8d3 09e0               	ora #$E0
  5029  f8d5 2093ff             	jsr secnd
  5030  f8d8 20aeff             	jsr unlsn
  5031                          
  5032                          clsei2:
  5033  f8db 18                 sv110:	clc
  5034  f8dc 60                 sv115:	rts
  5035                          
  5036  f8dd 2068fe             sv100:	jsr xtape		; goto tape device
  5037                          
  5038                          ; subroutine to output: 'saving <file name>'
  5039  f8e0 ad6103             saving:	lda msgflg
  5040  f8e3 10f7               	bpl sv115		; no print
  5041                          
  5042  f8e5 a023               	ldy #ms11-ms1		; 'saving'
  5043  f8e7 2023f2             	jsr spmsg
  5044  f8ea 4c35f8             	jmp outfn		; <file name>
  5045                          ; -------------------------------------------------------------------------------------------------
  5046                          ; ##### time #####
  5047                          ;----------------------------------------
  5048                          ; time and alarm routines for 6526
  5049                          ;      rsr 11/12/81
  5050                          ;
  5051                          ; rdtim - read the time
  5052                          ;  .y = (bit7=pm,bit6/5=t8/t4,bits4-0 hrs)
  5053                          ;  .x = (bit7=t2,bits6-0 minutes)
  5054                          ;  .a = (bit7=t1,bits6-0 seconds)
  5055                          ;----------------------------------------
  5056                          ; F8ED
  5057  f8ed ad08dc             rdtim:	lda cia+tod10
  5058  f8f0 48                 	pha			; save for later
  5059  f8f1 48                 	pha
  5060  f8f2 0a                 	asl			; shift to add to todhrs
  5061  f8f3 0a                 	asl
  5062  f8f4 0a                 	asl
  5063  f8f5 2960               	and #$60		; bit posistions 5,6
  5064  f8f7 0d0bdc             	ora cia+todhr
  5065  f8fa a8                 	tay			; return in .y
  5066  f8fb 68                 	pla
  5067  f8fc 6a                 	ror			; shift to add to todsec
  5068  f8fd 6a                 	ror
  5069  f8fe 2980               	and #$80
  5070  f900 0d09dc             	ora cia+todsec
  5071  f903 8593               	sta sal			; save for later
  5072  f905 6a                 	ror			; shit to add to todmin
  5073  f906 2980               	and #$80
  5074  f908 0d0adc             	ora cia+todmin
  5075  f90b aa                 	tax			; return in .x
  5076  f90c 68                 	pla
  5077  f90d cd08dc             	cmp cia+tod10		; watch out for rollover
  5078  f910 d0db               	bne rdtim		; ...it changed do again...
  5079  f912 a593               	lda sal
  5080  f914 60                 	rts
  5081                          ; -------------------------------------------------------------------------------------------------
  5082                          ; settim - set tod and alarm
  5083                          ;  c-set => set alarm
  5084                          ;  c-clr => set tod
  5085                          ;  registers same as rdtim
  5086                          ;----------------------------------------
  5087                          ; F915
  5088  f915 48                 settim:	pha			; save for later
  5089  f916 48                 	pha
  5090  f917 6a                 	ror			; set bit 8
  5091  f918 2980               	and #$80
  5092  f91a 0d0fdc             	ora cia+crb
  5093  f91d 8d0fdc             	sta cia+crb
  5094  f920 98                 	tya			; get bits from todhrs
  5095  f921 2a                 	rol
  5096  f922 2a                 	rol
  5097  f923 2693               	rol sal			; bit t8 (don't need to clear sal)
  5098  f925 2a                 	rol
  5099  f926 2693               	rol sal			; bit t4
  5100  f928 8a                 	txa			; get bit from todmin
  5101  f929 2a                 	rol
  5102  f92a 2693               	rol sal			; bit t2
  5103  f92c 68                 	pla			; get bit from todsec
  5104  f92d 2a                 	rol
  5105  f92e 2693               	rol sal			; bit t1
  5106  f930 8c0bdc             	sty cia+todhr
  5107  f933 8e0adc             	stx cia+todmin
  5108  f936 68                 	pla
  5109  f937 8d09dc             	sta cia+todsec
  5110  f93a a593               	lda sal
  5111  f93c 8d08dc             	sta cia+tod10
  5112  f93f 60                 	rts
  5113                          ; -------------------------------------------------------------------------------------------------
  5114                          ; ##### errorhandler #####
  5115                          ;************************************
  5116                          ;* error handler                    *
  5117                          ;*  restores i/o channels to default*
  5118                          ;*  prints kernal error message if  *
  5119                          ;*  bit 6 of msgflg set.  returns   *
  5120                          ;*  with error # in .a and carry.   *
  5121                          ;************************************
  5122                          ; F940 
  5123  f940 a901               error1:	lda #1			; too many files
  5124  f942 2c                 	!byte $2c
  5125  f943 a902               error2:	lda #2			; file open
  5126  f945 2c                 	!byte $2c
  5127  f946 a903               error3:	lda #3			; file not open
  5128  f948 2c                 	!byte $2c
  5129  f949 a904               error4:	lda #4			; file not found
  5130  f94b 2c                 	!byte $2c
  5131  f94c a905               error5:	lda #5			; device not present
  5132  f94e 2c                 	!byte $2c
  5133  f94f a906               error6:	lda #6			; not input file
  5134  f951 2c                 	!byte $2c
  5135  f952 a907               error7:	lda #7			; not output file
  5136  f954 2c                 	!byte $2c
  5137  f955 a908               error8:	lda #8			; missing file name
  5138  f957 2c                 	!byte $2c
  5139  f958 a909               error9:	lda #9			; bad device #
  5140                          
  5141  f95a 48                 errorx:	pha			; error number on stack
  5142  f95b 20ccff             	jsr clrch		; restore i/o channels
  5143                          
  5144  f95e a000               	ldy #ms1-ms1
  5145  f960 2c6103             	bit msgflg		; are we printing error?
  5146  f963 500a               	bvc erexit		; no...
  5147                          
  5148  f965 2028f2             	jsr msg			; print "cbm i/o error #"
  5149  f968 68                 	pla
  5150  f969 48                 	pha
  5151  f96a 0930               	ora #$30		; make error # ascii
  5152  f96c 20d2ff             	jsr bsout		; print it
  5153                          
  5154  f96f 68                 erexit:	pla
  5155  f970 38                 	sec
  5156  f971 60                 	rts
  5157                          ; -------------------------------------------------------------------------------------------------
  5158                          ;***************************************
  5159                          ;* stop -- check stop key flag and     *
  5160                          ;* return z flag set if flag true.     *
  5161                          ;* also closes active channels and     *
  5162                          ;* flushes keyboard queue.             *
  5163                          ;* also returns key downs from last    *
  5164                          ;* keyboard row in .a.                 *
  5165                          ;***************************************
  5166                          ; F972 Check the stop key
  5167  f972 a5a9               nstop:	lda stkey		; value of last row
  5168  f974 2901               	and #$01		; check stop key position
  5169  f976 d007               	bne stop2		; not down
  5170  f978 08                 	php
  5171  f979 20ccff             	jsr clrch		; clear channels
  5172  f97c 85d1               	sta ndx			; flush queue
  5173  f97e 28                 	plp
  5174  f97f 60                 stop2:	rts
  5175                          ; -------------------------------------------------------------------------------------------------
  5176                          ; udtim - update the stop key location
  5177                          ;   expects keyboard outputs set to
  5178                          ;   default value. bit 0 of stkey =0
  5179                          ;   for stop key down.
  5180                          ;---------------------------------------
  5181                          ; F980 
  5182  f980 ad02df             udtim:	lda tpi2+pc		; check keyboard
  5183  f983 4a                 	lsr
  5184  f984 b012               	bcs udexit		; no  stop key
  5185  f986 a9fe               	lda #$FE		; check for shift
  5186  f988 8d01df             	sta tpi2+pb
  5187  f98b a910               	lda #$10
  5188  f98d 2d02df             	and tpi2+pc
  5189  f990 d001               	bne udttt		; no shift key
  5190  f992 38                 	sec			; shift key mark
  5191  f993 a9ff               udttt:	lda #$FF		; clear
  5192  f995 8d01df             	sta tpi2+pb
  5193  f998 2a                 udexit:	rol			; move bit 0 back
  5194  f999 85a9               	sta stkey
  5195  f99b 60                 	rts
  5196                          ; -------------------------------------------------------------------------------------------------
  5197                          ; ##### init #####
  5198                          ;------------------------------------------------
  5199                          ; start - system reset routine
  5200                          ;  kernal checks on 4k boundries from $1000-$8000
  5201                          ;    first occurance has priority.
  5202                          ;    if no occurance then $e000 is used for vector
  5203                          ;    $e000 => monitor start
  5204                          ;  kernal expects:
  5205                          ;    $x000 - jmp init  (cold start)
  5206                          ;    $x003 - jmp winit (warm start)
  5207                          ;    $x006 - 'c'(+$80)=> kernal cold start first
  5208                          ;    $x007 - 'b'+$80
  5209                          ;    $x008 - 'm'+$80
  5210                          ;    $x009 - 'x'  x=4k bank (1-8)
  5211                          ;------------------------------------------------
  5212                          ; F99C Test bytes for ROMs
  5213  f99c c2cd               patall: !byte $C2,$CD		; $x004 rom pattern
  5214                          ; F99E
  5215  f99e a2fe               start:	ldx #$FE		; do all normal junk...
  5216  f9a0 78                 	sei
  5217  f9a1 9a                 	txs
  5218  f9a2 d8                 	cld
  5219                          
  5220                          ; check for warm start
  5221                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  5222  f9a3 a9a5               	lda #warm
  5223  f9a5 cdfa03             	cmp evect+2		; check warm flag ?
  5224  f9a8 d003               	bne scold		; no -> cold start
  5225  f9aa 4c58ff             	jmp chkwarm		; warm start patch
  5226                          } else{
  5227                          	lda #$FF
  5228                          	eor evect+2
  5229                          	eor evect+3		; compare warm start flags $A5, $5A
  5230                          	beq swarm		; if yes...do warm start
  5231                          	}
  5232                          
  5233                          ; F9AD Check for roms
  5234  f9ad a906               scold:	lda #6			; set up indirect to $0006 = position ROM ident bytes
  5235  f9af 8596               	sta eal
  5236  f9b1 a900               	lda #0			; clear upper
  5237  f9b3 8597               	sta eah
  5238  f9b5 8df803             	sta evect		; set low byte of vector warm start to $00
  5239  f9b8 a230               	ldx #$30		; existance flag 4. rom ident byte compare value to '0'
  5240  f9ba a003               sloop0: ldy #3			; set counter to 4th ROM ident byte
  5241  f9bc a597               	lda eah
  5242  f9be 3018               	bmi sloop2		; no roms but this one... -> monitor cold boot
  5243  f9c0 18                 	clc			; calc new test point
  5244  f9c1 6910               	adc #$10                ; 4k steps
  5245  f9c3 8597               	sta eah
  5246  f9c5 e8                 	inx			; next 4. byte compare value $31, $32, $33...
  5247  f9c6 8a                 	txa
  5248  f9c7 d196               	cmp (eal),y		; compare if 4. byte $31 at address $1006+3, $32 at $2006...
  5249  f9c9 d0ef               	bne sloop0		; 4. byte does not mach - > next ROM pos. $2000, $3000...
  5250  f9cb 88                 	dey			; check next byte backwards if 4th byte matches
  5251  f9cc b196               sloop1: lda (eal),y		; load 3., 2., 1. byte
  5252  f9ce 88                 	dey
  5253  f9cf 300a               	bmi sloop3		; all done...correctly - 2.+3. byte matches -> autostart ROM found!
  5254  f9d1 d99cf9             	cmp patall,y		; compare test bytes 'M', 'B'
  5255  f9d4 f0f6               	beq sloop1		; 3. byte OK -> check 2. byte
  5256  f9d6 d0e2               	bne sloop0		; no good... 2. or 3. ident byte does not mach
  5257                          
  5258                          ; monitor (could be test for keydown ***)
  5259  f9d8 a0e0               sloop2: ldy #$E0                ; monitor vector
  5260  f9da 2c                 	!byte $2C		; skip two bytes
  5261  f9db a497               sloop3: ldy eah
  5262  f9dd 8cf903             	sty evect+1             ; set high byte of vector
  5263                          
  5264  f9e0 aa                 	tax                     ; move 1. ident byte to x to set N-flag
  5265  f9e1 1018               	bpl swarm               ; don't use kernal initilization
  5266                          				;   jump to warm start if value is positive ('c'=$43)
  5267                          
  5268                          ; kernal cold start
  5269  f9e3 20fef9             	jsr ioinit              ; initilize i/o -> $F9FE (TPI1, TPI2, CIA, TOD)
  5270  f9e6 a9f0               	lda #$F0		; prevent damage to non-tested buffers
  5271  f9e8 85c1               	sta pkybuf+1            ; start F-keys
  5272  f9ea 2004e0             	jsr jcint               ; cinit call for non-cleared system $E004 -> cint $E044
  5273  f9ed 2094fa             	jsr ramtas              ; ram-test and set -> $FA94
  5274  f9f0 20b1fb             	jsr restor              ; operationg system vectors -> $FBB1 (copies $0300 Vector Table)
  5275  f9f3 2004e0             	jsr jcint               ; screen editor init $E004 -> cint $E044 (editor, F-Keys, VIC)
  5276  f9f6 a9a5               	lda #warm		; Kernal initilize done flag
  5277  f9f8 8dfa03             	sta evect+2             ; save first warm start flag $A5
  5278                          ; F9FB Warm start entry
  5279  f9fb 6cf803             swarm:  jmp (evect)             ; start exit -> basic warm start $BBA0
  5280                          ; -------------------------------------------------------------------------------------------------
  5281                          ; ioinit - initilize i/o system
  5282                          ;   6509/6525/6525/6526
  5283                          ;   must be entered with irq's disabled
  5284                          ;------------------------------------------
  5285                          ; F9FE I/O register init (TPI1, TPI2, CIA, TOD)
  5286                          
  5287                          ; 6525 tpi1 initilization code
  5288  f9fe a9f3               ioinit: lda #%11110011		; cb,ca=hi ie3,4=neg ip=1 mc=1
  5289  fa00 8d06de             	sta tpi1+creg		; interrupt mode = on, parity / VIC bank 15 selected for both
  5290  fa03 a9ff               	lda #$FF
  5291  fa05 8d05de             	sta tpi1+mir		; mask on all irq's
  5292                          ; pb4=output 1, to claim dbus
  5293  fa08 a95c               	lda #%01011100  	; wrt=lo unused netr=off
  5294  fa0a 8d01de             	sta tpi1+pb		; IEEE ifc=0, netw.=0, arb.sw.=1, cass. write=0,motor=1 
  5295  fa0d a97d               	lda #%01111101  	; set directions
  5296  fa0f 8d04de             	sta tpi1+ddpb		; input: cassette switch, IEEE srq
  5297                          				; output: IEEE ifc, network, arb.sw., cass. motor,write
  5298                          
  5299  fa12 a93d               	lda #%00111101		; IEEE controls off: dc=1, te=0, ren=1, atn=1, dav=1, eo=1
  5300  fa14 8d00de             	sta tpi1+pa
  5301  fa17 a93f               	lda #%00111111  	; IEEE control to transmitt, data to receive
  5302  fa19 8d03de             	sta tpi1+ddpa		; in: ndac, nfrd / out: dc, te, ren, atn, dav, eoi
  5303                          
  5304                          ; 6525 tpi2 initilization code
  5305  fa1c a9ff               	lda #$FF     		; set up keyboard outputs
  5306  fa1e 8d00df             	sta tpi2+pa             ; keyboard out 8-15=1
  5307  fa21 8d01de             	sta tpi1+pb             ; IEEE ifc=1, network=1, arb.sw.=1, cass. motor=1,write=1
  5308  fa24 8d03df             	sta tpi2+ddpa           ; dir keyboard 8-15 = output
  5309  fa27 8d04df             	sta tpi2+ddpb           ; dir keyboard 0-7 = output
  5310  fa2a 4e00df             	lsr tpi2+pa             ; clear keyboard 15 bit #7
  5311  fa2d a9c0               	lda #$C0		; set up vic selects=out for p-series
  5312  fa2f 8d02df             	sta tpi2+pc             ; VIC 16k bank select=11 $c000-$ffff
  5313  fa32 8d05df             	sta tpi2+ddpc           ; dir input: #0-5 keyboard 0-5 / output: #6-7 VIC 16k bank
  5314                          
  5315                          ; 6526 cia initilization code
  5316                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5317  fa35 a97f               	lda #$7f		; turn off all irq sources from 6526...
  5318                          	} else{
  5319                          	lda #$84		; set irq: #7=set, #2=ALRM enable TOD interrupt
  5320                          }
  5321  fa37 8d0ddc             	sta cia+icr
  5322  fa3a a000               	ldy #$00     		; all ieee in / same all game inputs
  5323  fa3c 8c02dc             	sty cia+ddra		; dir input: IEEE data, #6,7 also trigger 1,2
  5324  fa3f 8c03dc             	sty cia+ddrb		; dir input: game 1,2
  5325  fa42 8c0fdc             	sty cia+crb		; Timer B stop, PB7=off, cont, Phi2, activate TOD write
  5326                          ; activate tod
  5327  fa45 8d08dc             	sta cia+tod10		; clear TOD 1/10 seconds
  5328                          ; 60/50 hz test code for tod
  5329  fa48 8c02de             	sty tpi1+lir		; clear all interrupts
  5330  fa4b ad02de             io100:  lda tpi1+lir		; wait untill it happens again
  5331  fa4e 6a                 	ror			; shift bit #0 to carry
  5332  fa4f 90fa               	bcc io100		; pc0 = 1 -> 50/60hz irq
  5333  fa51 8c02de             	sty tpi1+lir		; clear it again
  5334                          ; start a timmer
  5335  fa54 a200               	ldx #0   
  5336  fa56 a000               	ldy #0
  5337  fa58 e8                 io110:  inx
  5338  fa59 d0fd               	bne io110		; delay 256x -> 1.28 ms @ 1MHz
  5339  fa5b c8                 	iny
  5340  fa5c ad02de             	lda tpi1+lir		; load interrrupt latch reg
  5341  fa5f 6a                 	ror
  5342  fa60 90f6               	bcc io110		; pc0 = 1 -> 50/60hz irq          
  5343  fa62 c00e               	cpy #id55hz   
  5344  fa64 9003               	bcc io120               ; it was 60 hz, signal appears again in 14 tries = <18ms
  5345  fa66 a988               	lda #%10001000		; set for 50hz
  5346  fa68 2c                 	!byte $2C		; skip two bytes
  5347  fa69 a908               io120:  lda #%00001000
  5348  fa6b 8d0edc             	sta cia+cra            ; set TOD=50/60Hz, run mode=continuous
  5349                          
  5350                          ; 6526  inter-process communication initialization
  5351                          ;   pra = data port
  5352                          ;   prb = ipc lines
  5353                          ;   irq's from 2nd processor via flag input
  5354  fa6e ad0ddb             	lda ipcia+icr		; clear icr
  5355  fa71 a990               	lda #$90    
  5356  fa73 8d0ddb             	sta ipcia+icr		; flag irqs on
  5357  fa76 a940               	lda #$40    
  5358  fa78 8d01db             	sta ipcia+prb		; no nmi to z80, sem6509 low
  5359  fa7b a900               	lda #$00    
  5360  fa7d 8d02db             	sta ipcia+ddra		; port a=input
  5361  fa80 8d0fdb             	sta ipcia+crb		; timer b off
  5362  fa83 8d0edb             	sta ipcia+cra		; timer a off
  5363  fa86 a948               	lda #%01001000		; port b lines sem65,ennmi are outs
  5364  fa88 8d03db             	sta ipcia+ddrb
  5365                          
  5366                          ; 6551 initilization code handled by reset  10/19/81 rsr
  5367                          
  5368                          ; turn off ifc
  5369  fa8b a901               	lda #ifc
  5370  fa8d 0d01de             	ora tpi1+pb		; TPI1 PB set bit #0 IEEE ifc=1
  5371  fa90 8d01de             	sta tpi1+pb 
  5372  fa93 60                 	rts         
  5373                          ; -------------------------------------------------------------------------------------------------
  5374                          ; ramtas - initilize lower ram with $00
  5375                          ;  and test all system dynamic ram
  5376                          ;  set ram limits (64k bank min size)
  5377                          ;  alocatate initial buffer space
  5378                          ;  turn off rs232 and cassette buffers
  5379                          ;  reset xtape vectors to non-cassette
  5380                          ;-----------------------------------------
  5381                          ; FA94 RAM-test / vector init
  5382  fa94 a900               ramtas: lda #0			; init value A = $00, counter X = 0
  5383  fa96 aa                 	tax
  5384  fa97 9d0200             px1:    sta $0002,x		; clear ZP above 6509 bank regs
  5385  fa9a 9d0002             	sta buf,x		; clear basic input buffer from $0200       
  5386  fa9d 9df802             	sta evect-$100,x	; clear kernal RAM till evct $03F8
  5387  faa0 e8                 	inx
  5388  faa1 d0f4               	bne px1			; clear next byte
  5389                          
  5390                          ; memory size check
  5391  faa3 a900               	lda #0			; bottom of memory always segment 0 (P500)
  5392  faa5 8501               	sta i6509
  5393  faa7 8d5a03             	sta memstr+2		; set bottom of user memory
  5394  faaa 8d5403             	sta lowadr+2		; ...and system memory
  5395  faad a902               	lda #2			; start at byte $0002
  5396  faaf 8d5803             	sta memstr
  5397  fab2 8d5203             	sta lowadr
  5398  fab5 c601               	dec i6509		; place back one segment for test
  5399                          
  5400                          ; memsiz,sal,lowadr are zeroed above
  5401  fab7 e601               sizlop: inc i6509		; claculate next ind bank
  5402  fab9 a501               	lda i6509
  5403  fabb c90f               	cmp #irom		; all slots full...exit
  5404  fabd f024               	beq size
  5405  fabf a002               	ldy #2			; always start at $0002, sal/sah already $0000
  5406  fac1 b193               siz100: lda (sal),y
  5407  fac3 aa                 	tax			; save memory value in X 
  5408  fac4 a955               	lda #$55		; test with $55
  5409  fac6 9193               	sta (sal),y
  5410  fac8 b193               	lda (sal),y
  5411  faca c955               	cmp #$55		; check if $55 
  5412  facc d015               	bne size		; end test if different
  5413  face 0a                 	asl			; test with $AA
  5414  facf 9193               	sta (sal),y
  5415  fad1 b193               	lda (sal),y
  5416  fad3 c9aa               	cmp #$AA		; check if $AA
  5417  fad5 d00c               	bne size		; end test if different
  5418  fad7 8a                 	txa
  5419  fad8 9193               	sta (sal),y		; restore old memory value from X
  5420                          !ifdef FULL_RAMTEST{		; ********** Full RAM-test **********
  5421                          	iny
  5422                          	bne siz100		; test next byte
  5423                          } else{				; ********** Fast RAM-test PATCH **********
  5424  fada ea                 	nop
  5425  fadb ea                 	nop
  5426  fadc ea                 	nop
  5427                          }
  5428  fadd e694               	inc sah
  5429  fadf d0e0               	bne siz100		; test next page
  5430  fae1 f0d4               	beq sizlop		; test next bank
  5431                          
  5432                          ; set top of memory
  5433  fae3 a601               size:   ldx i6509		; bank number of failure
  5434  fae5 ca                 	dex			; back up one segment
  5435  fae6 8a                 	txa			; .a= bank#
  5436  fae7 a2ff               	ldx #$FF
  5437                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5438  fae9 a0fd               	ldy #$FD		; reserve top two pages for swapping system
  5439  faeb 8d5703             	sta hiadr+2		; set system top of memory = $FDFF
  5440  faee 8c5603             	sty hiadr+1
  5441  faf1 8e5503             	stx hiadr
  5442                          
  5443                          ; allocate 3 pages (512funcs,256rs232)
  5444  faf4 a0fa               	ldy #$FD-3		; user memory top = $FAFF
  5445                          } else{
  5446                          	ldy #$FE		; reserve top page for swapping system
  5447                          	sta hiadr+2		; set system top of memory = $FEFF
  5448                          	sty hiadr+1
  5449                          	stx hiadr
  5450                          
  5451                          ; allocate 3 pages (512funcs,256rs232)
  5452                          	ldy #$FE-3		; user memory top = $FBFF
  5453                          }
  5454  faf6 18                 	clc
  5455  faf7 2087fb             	jsr memtop              ; set user top of memory
  5456                          
  5457                          ; flag buffers as not assigned =>$ff
  5458  fafa c6a8               	dec ribuf+2             ; init rs232 buffer bank to $FF
  5459  fafc c6a5               	dec tape1+2             ; init tape buffer bank to $FF
  5460  fafe a96b               	lda #<nocass		; set up cassette indirects to $FE6B
  5461  fb00 8d6a03             	sta itape
  5462  fb03 a9fe               	lda #>nocass
  5463  fb05 8d6b03             	sta itape+1
  5464  fb08 60                 	rts
  5465                          ; -------------------------------------------------------------------------------------------------
  5466                          ; FB09 standard vector table - initialized at boot from restor sub to cinv $0300
  5467  fb09 f8fb               jmptab: !word yirq		; FB09 -> FBF8 cinv	
  5468  fb0b 21ee               	!word timb		; FB0B -> EE21 cbinv....brk goes to monitor
  5469  fb0d b8fc               	!word panic		; FB0D -> FCB8 no.....nminv !!!!!
  5470  fb0f c6f6               	!word nopen		; FB0F -> F6C6 open file
  5471  fb11 f4f5               	!word nclose		; FB11 -> F5F4 close file
  5472  fb13 50f5               	!word nchkin		; FB13 -> F550 open channel in
  5473  fb15 aaf5               	!word nckout		; FB15 -> F5AA open channel out
  5474  fb17 adf6               	!word nclrch		; FB17 -> F6AD close channel
  5475  fb19 a3f4               	!word nbasin		; FB19 -> F4A3 input from channel
  5476  fb1b f5f4               	!word nbsout		; FB1B -> F4F5 output to channel
  5477  fb1d 72f9               	!word nstop		; FB1D -> F972 scan stop key
  5478  fb1f 44f4               	!word ngetin		; FB1F -> F444 scan keyboard
  5479  fb21 86f6               	!word nclall		; FB21 -> F686 close all files
  5480  fb23 4df7               	!word nload		; FB23 -> F74D load from file
  5481  fb25 53f8               	!word nsave		; FB25 -> F853 save to file
  5482  fb27 73ee               	!word s0		; FB27 -> EE73 monitor command parser
  5483  fb29 1fe0               	!word jescrt		; FB29 -> E01F esc key vector
  5484  fb2b 1fe0               	!word jescrt		; FB2B -> E01F user ctrl key vector
  5485  fb2d 7bf2               	!word nsecnd		; FB2D -> F27B IEEE listen secondary address
  5486  fb2f 87f2               	!word ntksa		; FB2F -> F287 IEEE talk secondary address
  5487  fb31 11f3               	!word nacptr		; FB31 -> F311 IEEE character in
  5488  fb33 9ef2               	!word nciout		; FB33 -> F29E IEEE character out
  5489  fb35 b2f2               	!word nuntlk		; FB35 -> F2B2 IEEE untalk bus
  5490  fb37 b6f2               	!word nunlsn		; FB37 -> F2B6 IEEE unlisten bus
  5491  fb39 3bf2               	!word nlistn		; FB39 -> F23B IEEE listen a device
  5492  fb3b 37f2               	!word ntalk		; FB3B -> F237 IEEE talk to a device
  5493                          tabend:
  5494                          ; -------------------------------------------------------------------------------------------------
  5495                          ; FB3D NMI entry, jumps indirect to NMI routine
  5496  fb3d 6c0403             nmi:    jmp (nminv)             ; ($0304) default -> panic = $FCB8
  5497                          ; -------------------------------------------------------------------------------------------------
  5498                          ; FB40 Set file name address
  5499                          ; .a = filename length
  5500                          ; .x = zero page location of 3 byte address
  5501  fb40 859d               setnam: sta fnlen		; store length
  5502  fb42 b500               	lda $00,x		; load and store address
  5503  fb44 8590               	sta fnadr
  5504  fb46 b501               	lda $01,x
  5505  fb48 8591               	sta fnadr+1
  5506  fb4a b502               	lda $02,x
  5507  fb4c 8592               	sta fnadr+2
  5508  fb4e 60                 	rts
  5509                          ; -------------------------------------------------------------------------------------------------
  5510                          ; FB4F Set file paramaters
  5511                          ; .a = logical address
  5512                          ; .x = first address
  5513                          ; .y = secundary address
  5514  fb4f 859e               setlfs: sta la
  5515  fb51 869f               	stx fa
  5516  fb53 84a0               	sty sa
  5517  fb55 60                 	rts
  5518                          ; -------------------------------------------------------------------------------------------------
  5519                          ; FB56 Read/write status
  5520                          ; carry set -- read device status into .a
  5521  fb56 901b               readst: bcc storst
  5522  fb58 a59f               	lda fa			; see which devices' to read
  5523  fb5a c902               	cmp #2
  5524  fb5c d00e               	bne readss		; not rs-232
  5525  fb5e ad7a03             	lda rsstat		; yes get it and remember it
  5526  fb61 48                 	pha
  5527  fb62 a900               	lda #00		; clear status when read
  5528  fb64 8d7a03             	sta rsstat
  5529  fb67 68                 	pla			; get status from stack
  5530  fb68 60                 	rts
  5531                          ; FB69 Set the system message flag
  5532  fb69 8d6103             setmsg: sta msgflg
  5533  fb6c a59c               readss: lda status		; read status
  5534                          ; set status bit
  5535  fb6e 059c               udst:   ora status		; set bit and store status
  5536  fb70 859c               	sta status
  5537  fb72 60                 	rts
  5538                          ; carry clear -- set device status with .a
  5539  fb73 48                 storst: pha
  5540  fb74 a59f               	lda fa
  5541  fb76 c902               	cmp #2
  5542  fb78 d005               	bne storss		; not rs-232
  5543  fb7a 68                 	pla
  5544  fb7b 8d7a03             	sta rsstat		; store rs-232 status
  5545  fb7e 60                 	rts
  5546                          
  5547  fb7f 68                 storss: pla
  5548  fb80 859c               	sta status		; store status
  5549  fb82 60                 	rts
  5550                          ; -------------------------------------------------------------------------------------------------
  5551                          ; FB83 IEC timeout on/off
  5552  fb83 8d5e03             settmo: sta timout
  5553  fb86 60                 	rts
  5554                          ; -------------------------------------------------------------------------------------------------
  5555                          ; FB87 Read/set top of memory
  5556  fb87 9009               memtop: bcc settop
  5557                          
  5558                          ; carry set--read top of memory
  5559  fb89 ad5d03             	lda memsiz+2		; load user memory top in .a.x.y
  5560  fb8c ae5b03             	ldx memsiz
  5561  fb8f ac5c03             	ldy memsiz+1
  5562                          
  5563                          ; carry clear--set top of memory
  5564  fb92 8e5b03             settop: stx memsiz		; set user memory top
  5565  fb95 8c5c03             	sty memsiz+1
  5566  fb98 8d5d03             	sta memsiz+2
  5567  fb9b 60                 	rts
  5568                          ; -------------------------------------------------------------------------------------------------
  5569                          ; FB9C Manage bottom of memory
  5570  fb9c 9009               membot: bcc setbot
  5571                          
  5572                          ; carry set--read bottom of memory
  5573  fb9e ad5a03             	lda memstr+2		; load bottom mem in .a.x.y
  5574  fba1 ae5803             	ldx memstr
  5575  fba4 ac5903             	ldy memstr+1
  5576                          
  5577                          ; carry clear--set bottom of memory
  5578  fba7 8e5803             setbot: stx memstr		; set bottom mem
  5579  fbaa 8c5903             	sty memstr+1
  5580  fbad 8d5a03             	sta memstr+2
  5581  fbb0 60                 	rts
  5582                          ; -------------------------------------------------------------------------------------------------
  5583                          ; FBB1 Restore ram i/o vectors at $0300
  5584  fbb1 a209               restor: ldx #<jmptab		; load vector table address in kernal
  5585  fbb3 a0fb               	ldy #>jmptab
  5586  fbb5 a90f               	lda #irom
  5587  fbb7 18                 	clc
  5588                          
  5589                          ; FBB8 Manage ram i/o vectors
  5590  fbb8 8693               vector: stx sal			; store address
  5591  fbba 8494               	sty sah
  5592  fbbc a601               	ldx i6509		; save indirect
  5593  fbbe 8501               	sta i6509		; set ibank .a 
  5594  fbc0 900a               	bcc vect50		; carry=0 -> set/restore table
  5595                          
  5596                          ; carry set--read vectors
  5597  fbc2 a033               	ldy #tabend-jmptab-1
  5598  fbc4 b90003             vect20: lda cinv,y		; from ram table $F0300
  5599  fbc7 9193               	sta (sal),y		; into user area
  5600  fbc9 88                 	dey
  5601  fbca 10f8               	bpl vect20
  5602                          
  5603                          ; carry clear--set vectors
  5604  fbcc a033               vect50: ldy #tabend-jmptab-1
  5605  fbce b193               vect60: lda (sal),y		; from user area
  5606  fbd0 990003             	sta cinv,y		; into ram table $F0300
  5607  fbd3 88                 	dey
  5608  fbd4 10f8               	bpl vect60
  5609                          
  5610  fbd6 8601               	stx i6509		; restore indirect
  5611  fbd8 60                 	rts
  5612                          ; -------------------------------------------------------------------------------------------------
  5613                          ; FBD9 vreset - reset vector flags and control
  5614                          ;   .x - low vector address  .y - high vector address
  5615  fbd9 8ef803             vreset: stx evect
  5616  fbdc 8cf903             	sty evect+1
  5617  fbdf a95a               	lda #winit
  5618  fbe1 8dfb03             	sta evect+3
  5619  fbe4 60                 	rts
  5620                          ; -------------------------------------------------------------------------------------------------
  5621                          ; ##### irq #####
  5622                          ;**********************************************
  5623                          ;* nirq - handler for:       10/30/81 rsr     *
  5624                          ;* 6525 irq's:::::::::::::::::::::::::::::::::*
  5625                          ;* 6551 irq's                                 *
  5626                          ;*   (receiver,transmitter,dcd & dsr changes) *
  5627                          ;* 6526 irq's                                 *
  5628                          ;*   (alarm, timera, timerb)                  *
  5629                          ;* 6526 irq's                                 *
  5630                          ;*   (2nd processor)                          *
  5631                          ;* ieee srq                                   *
  5632                          ;* keyboard scan (50/60hz irq)                *
  5633                          ;*                                            *
  5634                          ;* also at present does not handle any of the *
  5635                          ;* 6566 (vic) interrupts.                     *
  5636                          ;**********************************************
  5637                          ; FBE5 IRQ handler
  5638  fbe5 48                 nirq:	pha			; save registers
  5639  fbe6 8a                 	txa
  5640  fbe7 48                 	pha
  5641  fbe8 98                 	tya
  5642  fbe9 48                 	pha
  5643  fbea ba                 	tsx			; check for brk...
  5644  fbeb bd0401             	lda stack+4,x
  5645  fbee 2910               	and #$10
  5646  fbf0 d003               	bne brkirq		; yes...
  5647  fbf2 6c0003             	jmp (cinv)		; via vector -> yirq $FBF8
  5648  fbf5 6c0203             brkirq: jmp (cbinv)		; yes...
  5649                          
  5650                          ; FBF8 entry via indirect vector cinv
  5651  fbf8 a501               yirq:   lda i6509		; save indirect bank #
  5652  fbfa 48                 	pha
  5653                          	;lda pass	; external break handler
  5654                          	;pha
  5655                          	;lda #0 	; clear for normal return
  5656                          	;sta pass
  5657  fbfb d8                 	cld			; clear dec to prevent future problems
  5658  fbfc ad07de             	lda tpi1+air
  5659  fbff d003               	bne irq000		; handle priority irq's
  5660                          
  5661                          ; external irq (vic and others)
  5662                          ;  (no code!!!!!!!!!!)
  5663  fc01 4cb0fc             	jmp prendn
  5664                          
  5665                          ; FC04 Check for ACIA IRQ
  5666  fc04 c910               irq000:	cmp #$10		; find irq source
  5667  fc06 f003               	beq irq002		; not 6551...
  5668  fc08 4c69fc             	jmp irq100
  5669                          
  5670                          ; 6551 interrupt handler
  5671  fc0b ad01dd             irq002:	lda acia+srsn		; find irq source
  5672  fc0e aa                 	tax
  5673  fc0f 2960               	and #$60		; dcd/dsr changes ??
  5674  fc11 a8                 	tay
  5675  fc12 4d7b03             	eor dcdsr
  5676  fc15 f00d               	beq irq004		; no change...
  5677  fc17 98                 	tya
  5678  fc18 8d7b03             	sta dcdsr		; update old dsr/dcd status
  5679  fc1b 0d7a03             	ora rsstat		; update rs232 status
  5680  fc1e 8d7a03             	sta rsstat
  5681  fc21 4cadfc             	jmp irq900		; done!
  5682                          ;
  5683  fc24 8a                 irq004:	txa
  5684  fc25 2908               	and #$08		; receiver ??
  5685  fc27 f025               	beq irq010		; no...
  5686                          
  5687                          ; receiver service
  5688  fc29 ac7d03             	ldy ridbe		; check buffers
  5689  fc2c c8                 	iny
  5690  fc2d cc7c03             	cpy ridbs		; have we passed start?
  5691  fc30 d004               	bne irq005		; no...
  5692                          
  5693  fc32 a908               	lda #doverr		; input buffer full error
  5694  fc34 d012               	bne irq007		; bra...set status
  5695                          
  5696  fc36 8c7d03             irq005:	sty ridbe		; move end foward
  5697  fc39 88                 	dey
  5698  fc3a a6a8               	ldx ribuf+2
  5699  fc3c 8601               	stx i6509
  5700                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5701  fc3e ae01dd             	ldx acia+srsn		; get status register
  5702  fc41 2052ff             	jsr patch2		; moved to end because 1 byte missing here
  5703  fc44 8a                 	txa			; set status
  5704  fc45 ea                 	nop
  5705                          } else{
  5706                          	lda acia+drsn
  5707                          	sta (ribuf),y		; data to buffer
  5708                          	lda acia+srsn		; get status register
  5709                          }
  5710  fc46 2907               	and #$07
  5711  fc48 0d7a03             irq007:	ora rsstat		; set status
  5712  fc4b 8d7a03             	sta rsstat
  5713                          
  5714  fc4e ad01dd             irq010:	lda acia+srsn		; find irq source
  5715  fc51 2910               	and #$10		; transmitter ?
  5716  fc53 f011               	beq irq090		; no...
  5717  fc55 ad02dd             	lda acia+cdr		; check for transmitter on
  5718  fc58 290c               	and #$0c
  5719  fc5a c904               	cmp #$04		; bits(32)=01 => xmitter int enabled
  5720  fc5c d008               	bne irq090		; off...
  5721                          
  5722                          ; transmitter service (no interrrupt driven transmissions)
  5723  fc5e a9f3               	lda #%11110011		; turn of transmitter
  5724  fc60 2d02dd             	and acia+cdr
  5725  fc63 8d02dd             	sta acia+cdr
  5726  fc66 4cadfc             irq090:	jmp irq900		; exit..pop priority...
  5727                          
  5728                          ; FC69 Check for coprozessor IRQ
  5729  fc69 c908               irq100:	cmp #$08		; check if inter-process irq
  5730  fc6b d00a               	bne irq110		; no...
  5731  fc6d ad0ddb             	lda ipcia+icr		; clear irq condition
  5732  fc70 58                 	cli			; this irq can be interrupted
  5733  fc71 2056fd             	jsr ipserv		; do the request
  5734  fc74 4cadfc             	jmp irq900		; done!
  5735                          
  5736                          ; FC77 Check for CIA IRQ
  5737  fc77 58                 irq110:	cli			; all other irq's may be interrupted, too
  5738  fc78 c904               	cmp #$04		; check if 6526
  5739  fc7a d00c               	bne irq200		; no...
  5740                          
  5741                          ; 6526 interrupt reconized
  5742  fc7c ad0ddc             	lda cia+icr		; get active interrupts
  5743  fc7f 0d6903             	ora alarm		; in case we lose something
  5744  fc82 8d6903             	sta alarm
  5745                          
  5746                          ; nothing to do at present....need code ********
  5747  fc85 4cadfc             	jmp irq900		; ...dump interrupt
  5748                          
  5749                          ; FC88 Check for IEC bus IRQ (and ignore it)
  5750  fc88 c902               irq200:	cmp #$02		; check for ieee srq
  5751  fc8a d003               	bne irq300
  5752                          
  5753                          ; need code ************
  5754  fc8c 4cadfc             	jmp irq900		; ...dump interrupt
  5755                          
  5756                          ; FC8F Must be a 50/60Hz IRQ - poll keyboard, update time
  5757  fc8f 2013e0             irq300:	jsr jkey		; scan the keyboard
  5758  fc92 2080f9             	jsr udtim		; set stopkey flag
  5759                          
  5760                          ; test for cassette switch
  5761  fc95 ad01de             	lda tpi1+pb		; get cass switch
  5762  fc98 1009               	bpl irq310		; switch is down...
  5763  fc9a a000               	ldy #0			; flag motor off...
  5764  fc9c 8c7503             	sty cas1
  5765  fc9f 0940               	ora #$40		; turn motor off...
  5766  fca1 d007               	bne irq320		; jump
  5767  fca3 ac7503             irq310:	ldy cas1		; test for flag on...
  5768  fca6 d005               	bne irq900		; yes computer control..leave alone
  5769  fca8 29bf               	and #$FF-$40		; turn motor on...
  5770  fcaa 8d01de             irq320:	sta tpi1+pb		; store mods into port
  5771                          
  5772  fcad 8d07de             irq900:	sta tpi1+air		; pop the interrupt...
  5773                          
  5774                          prendn: ;lda pass	; check for foriegn call
  5775                          	;bne segrti	; yes...return
  5776                          	;pla
  5777                          	;sta pass	; restore interrupted interrupt
  5778  fcb0 68                 	pla             ;restore registers
  5779  fcb1 8501               	sta i6509
  5780  fcb3 68                 prend:	pla			; entry point for register only
  5781  fcb4 a8                 	tay
  5782  fcb5 68                 	pla
  5783  fcb6 aa                 	tax
  5784  fcb7 68                 	pla
  5785                          
  5786                          ; Default NMI routine
  5787  fcb8 40                 panic:	rti			; come here if no new nmi vector.
  5788                          ; -------------------------------------------------------------------------------------------------
  5789                          ; send a request
  5790                          ;   enter:   ipb buffer is initialized to hold the
  5791                          ;            command
  5792                          ;            input parameter bytes
  5793                          ;
  5794                          ;   exit:    ipb buffer holds
  5795                          ;            output parameter bytes
  5796                          ;            all other bytes in ipb unchanged
  5797                          ;---------------------------------------------------------------
  5798                          ; FCB9 Coprocessor request
  5799  fcb9 ad0008             iprqst:	lda ipb+ipccmd
  5800  fcbc 297f               	and #$7F
  5801  fcbe a8                 	tay
  5802  fcbf 202ffe             	jsr getpar		; get #ins,outs
  5803  fcc2 a904               	lda #sem88		; check 8088 semaphore
  5804  fcc4 2d01db             	and ipcia+prb
  5805  fcc7 d0f0               	bne iprqst		; locked out by other processor
  5806  fcc9 a908               	lda #sem65
  5807  fccb 0d01db             	ora ipcia+prb		; lock 6509 semaphore
  5808  fcce 8d01db             	sta ipcia+prb
  5809  fcd1 ea                 	nop			; a pause
  5810                          
  5811  fcd2 ad01db             	lda ipcia+prb		; collisions with 8088?
  5812  fcd5 aa                 	tax
  5813  fcd6 2904               	and #sem88
  5814  fcd8 f00c               	beq ipr100		; ok...
  5815  fcda 8a                 	txa
  5816  fcdb 4908               	eor #sem65
  5817  fcdd 8d01db             	sta ipcia+prb		; nope, clear 6509 semaphore
  5818  fce0 8a                 	txa			; kill some time
  5819  fce1 ea                 	nop
  5820  fce2 ea                 	nop
  5821  fce3 ea                 	nop
  5822  fce4 d0d3               	bne iprqst		; try again (br always)
  5823                          
  5824                          ;     send cmd byte and cause irq
  5825  fce6 a9ff               ipr100: lda #$FF
  5826  fce8 8d02db             	sta ipcia+ddra		; port direction = out
  5827  fceb ad0008             	lda ipb+ipccmd
  5828  fcee 8d00db             	sta ipcia+pra		; write cmd byte to port
  5829                          ; cause irq
  5830  fcf1 2016fe             	jsr frebus		; give up bus
  5831  fcf4 ad01db             	lda ipcia+prb		; pb6 := 0
  5832  fcf7 29bf               	and #$BF
  5833  fcf9 8d01db             	sta ipcia+prb
  5834  fcfc 0940               	ora #$40		; keep low for 4us (8 cycles)
  5835  fcfe 58                 	cli
  5836  fcff ea                 	nop
  5837  fd00 ea                 	nop
  5838  fd01 ea                 	nop
  5839  fd02 8d01db             	sta ipcia+prb		; pb6 := high
  5840                          
  5841  fd05 20fcfd             	jsr waithi		; sem8088 -> hi (cmd byte recvd)
  5842  fd08 a900               	lda #$00
  5843  fd0a 8d02db             	sta ipcia+ddra		; port direction = in
  5844  fd0d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5845  fd10 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5846                          
  5847                          ;    send data bytes, if any
  5848  fd13 a000               	ldy #0
  5849  fd15 f01d               	beq ipr250		; always
  5850                          
  5851  fd17 a9ff               ipr200:	lda #$FF
  5852  fd19 8d02db             	sta ipcia+ddra		; port direction = out
  5853  fd1c b90508             	lda ipb+ipcdat,y	; get next data byte
  5854  fd1f 8d00db             	sta ipcia+pra		; write cmd out
  5855  fd22 200dfe             	jsr ackhi		; sem6509 -> hi (data ready)
  5856  fd25 20fcfd             	jsr waithi		; sem8088 -> hi (data recvd)
  5857  fd28 a900               	lda #$00
  5858  fd2a 8d02db             	sta ipcia+ddra		; port direction = in
  5859  fd2d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5860  fd30 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5861  fd33 c8                 	iny			; bump index to next data byte
  5862  fd34 cc0308             ipr250:	cpy ipb+ipcin		; any more ??
  5863  fd37 d0de               	bne ipr200		; yes...
  5864                          
  5865                          ;    receive data bytes, if any
  5866  fd39 a000               	ldy #0
  5867  fd3b f013               	beq ipr350		; always
  5868                          
  5869  fd3d 200dfe             ipr300:	jsr ackhi		; sem6509 -> hi (rdy to receive)
  5870  fd40 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5871  fd43 ad00db             	lda ipcia+pra		; get data from port
  5872  fd46 990508             	sta ipb+ipcdat,y	; stuff it away
  5873  fd49 2004fe             	jsr acklo		; sem6509 -> lo (data recvd)
  5874  fd4c 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5875  fd4f c8                 	iny
  5876                          
  5877  fd50 cc0408             ipr350:	cpy ipb+ipcout		; more?
  5878  fd53 d0e8               	bne ipr300		; yes...
  5879  fd55 60                 	rts			; done!!
  5880                          ; -------------------------------------------------------------------------------------------------
  5881                          ; service an 8088 request
  5882                          ;-------------------------------------------------------------------
  5883                          ; FD56 Coprocessor irq handler
  5884                          ipserv: ;ldy #ipbsiz-1	; copy ip buffer to stack
  5885                          	;ips050 lda ipb,y
  5886                          	; pha
  5887                          	; dey
  5888                          	; bpl ips050
  5889                          
  5890  fd56 a900               	lda #0
  5891  fd58 8d02db             	sta ipcia+ddra		; port dir=in, just in case...
  5892  fd5b ad00db             	lda ipcia+pra		; read cmd from port
  5893  fd5e 8d0008             	sta ipb+ipccmd		; store cmd and decode it
  5894  fd61 297f               	and #$7F		; mask off bus bit
  5895  fd63 a8                 	tay
  5896  fd64 202ffe             	jsr getpar		; get param counts
  5897  fd67 98                 	tya			; adjust offset for jump table
  5898  fd68 0a                 	asl
  5899  fd69 a8                 	tay
  5900  fd6a b91008             	lda ipjtab,y		; jump address(lo)
  5901  fd6d 8d0108             	sta ipb+ipcjmp
  5902  fd70 c8                 	iny
  5903  fd71 b91008             	lda ipjtab,y		; jump address (hi)
  5904  fd74 8d0208             	sta ipb+ipcjmp+1
  5905  fd77 200dfe             	jsr ackhi		; sem6509 -> hi (cmd recvd)
  5906  fd7a 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5907                          
  5908                          ;    receive input bytes, if any
  5909  fd7d a000               	ldy #0
  5910                          
  5911  fd7f cc0308             ips100:	cpy ipb+ipcin		; any more?
  5912  fd82 f015               	beq ips200		; no...
  5913  fd84 2004fe             	jsr acklo		; sem6509 ->lo (ack ack)
  5914  fd87 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5915  fd8a ad00db             	lda ipcia+pra		; read data byte
  5916  fd8d 990508             	sta ipb+ipcdat,y	; store it
  5917  fd90 200dfe             	jsr ackhi		; sem6509 -> hi (data recvd)
  5918  fd93 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5919  fd96 c8                 	iny
  5920  fd97 d0e6               	bne ips100		; always...
  5921                          
  5922                          ;    process cmd
  5923  fd99 2c0008             ips200:	bit ipb+ipccmd		; cmd requires bus?
  5924  fd9c 3033               	bmi ips500		; yes...
  5925  fd9e a9fd               	lda #>ipsret		; push return
  5926  fda0 48                 	pha
  5927  fda1 a9a6               	lda #<ipsret
  5928  fda3 48                 	pha
  5929  fda4 6c0108             	jmp (ipb+ipcjmp)	; gone!!!
  5930                          
  5931                          ;    send return bytes, if any
  5932                          ips300:
  5933                          ipsret=ips300-1
  5934  fda7 2004fe             	jsr acklo		; sem6509 -> lo
  5935  fdaa a000               	ldy #0
  5936  fdac f01d               	beq ips350		; always
  5937                          ips310:
  5938  fdae 20fcfd             	jsr waithi		; sem8088 -> hi (8088 rdy to recv)
  5939  fdb1 a9ff               	lda #$FF
  5940  fdb3 8d02db             	sta ipcia+ddra		; port direction = out
  5941  fdb6 b90508             	lda ipb+ipcdat,y
  5942  fdb9 8d00db             	sta ipcia+pra		; write data to port
  5943  fdbc 200dfe             	jsr ackhi		; sem6509 -> hi (data available)
  5944  fdbf 20f4fd             	jsr waitlo		; sem8088 -> lo (data recvd)
  5945  fdc2 a900               	lda #0
  5946  fdc4 8d02db             	sta ipcia+ddra		; port direction = in
  5947  fdc7 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5948  fdca c8                 	iny
  5949  fdcb cc0408             ips350:	cpy ipb+ipcout		; any more?
  5950  fdce d0de               	bne ips310		; yes, repeat...
  5951                          
  5952                          ips400:	;ldy #0
  5953                          	;ips450 pla	; restore ip buffer
  5954                          	; sta ipb,y
  5955                          	; iny
  5956                          	; cpy #ipbsiz
  5957                          	; bne ips450
  5958  fdd0 60                 	rts			; done!
  5959                          
  5960                          ;      special,   for commands requiring the bus
  5961  fdd1 a9fd               ips500:	lda #>buret
  5962  fdd3 48                 	pha
  5963  fdd4 a9dc               	lda #<buret
  5964  fdd6 48                 	pha			; push return
  5965  fdd7 201ffe             	jsr getbus		; grab bus
  5966  fdda 6c0108             	jmp (ipb+ipcjmp)	; gone!
  5967                          
  5968                          ips600:
  5969                          buret=ips600-1
  5970  fddd 2016fe             	jsr frebus		; give up bus
  5971  fde0 ad0408             	lda ipb+ipcout		; #bytes to return
  5972  fde3 8d0308             	sta ipb+ipcin
  5973  fde6 8d0008             	sta ipb+ipccmd		; return op=#bytes to return
  5974  fde9 a900               	lda #0
  5975  fdeb 8d0408             	sta ipb+ipcout		; just send to 8088
  5976  fdee 20b9fc             	jsr iprqst
  5977  fdf1 4cd0fd             	jmp ips400		; done!
  5978                          
  5979                          ; FDF4 waitlo - wait until sem88 goes low
  5980  fdf4 ad01db             waitlo:	lda ipcia+prb
  5981  fdf7 2904               	and #sem88
  5982  fdf9 d0f9               	bne waitlo
  5983  fdfb 60                 	rts
  5984                          ; waithi - wait until sem88 goes high
  5985                          
  5986  fdfc ad01db             waithi:	lda ipcia+prb
  5987  fdff 2904               	and #sem88
  5988  fe01 f0f9               	beq waithi
  5989  fe03 60                 	rts
  5990                          
  5991                          ; acklo - acknowlegde sem65 low
  5992  fe04 ad01db             acklo:	lda ipcia+prb
  5993  fe07 29f7               	and #$FF-sem65
  5994  fe09 8d01db             	sta ipcia+prb
  5995  fe0c 60                 	rts
  5996                          
  5997                          ; ackhi - acknowledge sem6509 hi
  5998  fe0d a908               ackhi:	lda #sem65
  5999  fe0f 0d01db             	ora ipcia+prb
  6000  fe12 8d01db             	sta ipcia+prb
  6001  fe15 60                 	rts
  6002                          
  6003                          ; frebus - give up bus
  6004  fe16 ad01de             frebus:	lda tpi1+pb		; pb4 := 0
  6005  fe19 29ef               	and #$EF
  6006  fe1b 8d01de             	sta tpi1+pb
  6007  fe1e 60                 	rts
  6008                          
  6009                          ; getbus - grab bus
  6010                          getbus:
  6011  fe1f ad01db             	lda ipcia+prb		; check nbusy2
  6012  fe22 2902               	and #$02
  6013  fe24 f0f9               	beq getbus		; 2nd proc not off
  6014                          
  6015  fe26 ad01de             	lda tpi1+pb		; pb4 := 1
  6016  fe29 0910               	ora #$10
  6017  fe2b 8d01de             	sta tpi1+pb
  6018  fe2e 60                 	rts
  6019                          
  6020                          ; getpar
  6021                          ;  enter - .y = table offset
  6022                          ;  exit:   .y = table offset
  6023                          ;          #ins,#outs put into ipb buffer
  6024  fe2f b91009             getpar:	lda ipptab,y		; break apart nibbles
  6025  fe32 48                 	pha
  6026  fe33 290f               	and #$0F
  6027  fe35 8d0308             	sta ipb+ipcin		; #input bytes
  6028  fe38 68                 	pla
  6029  fe39 4a                 	lsr
  6030  fe3a 4a                 	lsr
  6031  fe3b 4a                 	lsr
  6032  fe3c 4a                 	lsr
  6033  fe3d 8d0408             	sta ipb+ipcout		; #output bytes
  6034  fe40 60                 	rts
  6035                          
  6036                          ; ipcgo - free bus, interrupt 2nd processor
  6037                          ;         go into a loop, waiting for requests.
  6038                          ;  * returns if bus error occurs
  6039  fe41 a2ff               ipcgo:	ldx #$FF
  6040  fe43 8601               	stx i6509		; indirects to bank f only
  6041  fe45 ad01de             	lda tpi1+pb		; tpi1 pb4:=0 frees dbus
  6042  fe48 29ef               	and #$EF
  6043  fe4a 8d01de             	sta tpi1+pb
  6044  fe4d ea                 	nop			; a pause
  6045  fe4e ad01db             	lda ipcia+prb		; check nbusy1
  6046  fe51 6a                 	ror
  6047  fe52 b001               	bcs ipcgx
  6048  fe54 60                 	rts			; bus not free!, error...
  6049                          
  6050  fe55 a900               ipcgx:	lda #0			; pb6 lo->hi in 4us...
  6051  fe57 78                 	sei
  6052  fe58 8d01db             	sta ipcia+prb		; interrupt 2nd processeor
  6053  fe5b a940               	lda #$40		; 2 cycles (4us=8cycles)
  6054  fe5d ea                 	nop
  6055  fe5e ea                 	nop
  6056  fe5f ea                 	nop
  6057  fe60 ea                 	nop			; 8 cycles of garb. 5us safer than 4!
  6058  fe61 8d01db             	sta ipcia+prb		; turn pb6 back on
  6059  fe64 58                 	cli
  6060  fe65 4c65fe             iploop:	jmp iploop		; sit down
  6061                          ; -------------------------------------------------------------------------------------------------
  6062                          ; FE68 no cassette routines avaliable
  6063  fe68 6c6a03             xtape:	jmp     (itape)		; goto tape device indirect -> nocass
  6064                          ;
  6065  fe6b 68                 nocass:	pla			; remove jsr xtape and return
  6066  fe6c 68                 	pla
  6067  fe6d 4c4cf9             	jmp error5		; send back ?device not present
  6068                          ; -------------------------------------------------------------------------------------------------
  6069                          ; some needed routines
  6070                          ; FE70 
  6071  fe70 a59a               rd300:	lda stah
  6072  fe72 8594               	sta sah
  6073  fe74 a599               	lda stal
  6074  fe76 8593               	sta sal
  6075  fe78 a59b               	lda stas
  6076  fe7a 8595               	sta sas
  6077  fe7c 8501               	sta i6509
  6078  fe7e 60                 	rts
  6079                          ; FE7F 
  6080  fe7f 38                 cmpste: sec
  6081  fe80 a593               	lda sal
  6082  fe82 e596               	sbc eal
  6083  fe84 a594               	lda sah
  6084  fe86 e597               	sbc eah
  6085  fe88 a595               	lda sas
  6086  fe8a e598               	sbc eas
  6087  fe8c 60                 	rts
  6088                          !ifndef CBMPATCH{
  6089                          ; FE8D
  6090                          incsal: inc sal
  6091                          	bne incr20
  6092                          	inc sah
  6093                          	bne incr20
  6094                          	inc sas
  6095                          	lda sas
  6096                          	sta i6509
  6097                          	lda #$02		; skip $0000 and $0001
  6098                          	sta sal
  6099                          incr20:	rts
  6100                          }
  6101                          ; -------------------------------------------------------------------------------------------------
  6102                          ;-------------------------------------
  6103                          ; tapery - get from the tape buffer
  6104                          ;   lda (tape1)y ;replacement
  6105                          ;-------------------------------------
  6106                          ;tapiry iny
  6107                          ;tapery ldx i6509
  6108                          ; lda tape1+2
  6109                          ; sta i6509
  6110                          ; lda (tape1)y
  6111                          ; stx i6509
  6112                          ; rts
  6113                          ;-------------------------------------
  6114                          ; tapewy - put char in the tape buffer
  6115                          ;   sta (tape1)y ;replacement
  6116                          ;-------------------------------------
  6117                          ;tapzwy ldy #$ff ;first byte in buffer
  6118                          ;tapiwy iny ;auto inc into buffer
  6119                          ;tapewy ldx i6509
  6120                          ; pha
  6121                          ; lda tape1+2
  6122                          ; sta i6509
  6123                          ; pla
  6124                          ; sta (tape1)y
  6125                          ; stx i6509
  6126                          ; rts
  6127                          ;-------------------------------------
  6128                          ; fnadry - get from file name buffer
  6129                          ;   lda (fnadr)y ;replacement
  6130                          ;-------------------------------------
  6131                          ; FEA0 Load a byte from the file name
  6132  fe8d a601               fnadry: ldx i6509
  6133  fe8f a592               	lda fnadr+2
  6134  fe91 8501               	sta i6509
  6135  fe93 b190               	lda (fnadr),y
  6136  fe95 8601               	stx i6509
  6137  fe97 60                 	rts
  6138                          ; -------------------------------------------------------------------------------------------------
  6139                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6140                          *= $FE9D
  6141                          ; ##### transx #####
  6142                          ; txjmp - transfer-of-execution jumper
  6143                          ;   entry - .a=seg # .x=low .y=high
  6144                          ;   caller must be a jsr txjmp
  6145                          ;   all registers and i6509 destroyed
  6146                          ;   returns directly to caller...
  6147  fe9d 8501               txjmp:	sta i6509		; bp routine
  6148  fe9f 8a                 	txa
  6149  fea0 18                 	clc
  6150  fea1 6902               	adc #2			; add 2 to target address
  6151  fea3 9001               	bcc txjmp1
  6152  fea5 c8                 	iny
  6153  fea6 aa                 txjmp1:	tax
  6154  fea7 98                 	tya
  6155  fea8 48                 	pha			; store target+2 to stack
  6156  fea9 8a                 	txa
  6157  feaa 48                 	pha
  6158  feab 2019ff             	jsr ipinit		; go initilize ipoint
  6159  feae a9fe               	lda #$fe
  6160  feb0 91ac               	sta (ipoint),y		; $fe to top of foreign stack
  6161                          ; 04/14/83 bp
  6162                          ; transfer exec routines for cbm2
  6163                          }
  6164                          ; -------------------------------------------------------------------------------------------------
  6165                          ; FEAB Support routine for cross bank calls
  6166  feb2 08                 exsub:	php			; save status
  6167  feb3 78                 	sei			; disable interrupts
  6168  feb4 48                 	pha			; .a
  6169  feb5 8a                 	txa
  6170  feb6 48                 	pha			; .x
  6171  feb7 98                 	tya
  6172  feb8 48                 	pha			; .y
  6173  feb9 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6174  febc a8                 	tay			; .y is xfer seg stack pointer
  6175  febd a500               	lda e6509		; push return segment to user stack
  6176  febf 202aff             	jsr putas		; push .a to other stack
  6177  fec2 a904               	lda #<excrt2		; xfer seg rts routn
  6178  fec4 a2ff               	ldx #>excrt2		; xfer seg rts routn
  6179  fec6 2024ff             	jsr putaxs		; put .a.x to xfer seg stack
  6180  fec9 ba                 	tsx
  6181  feca bd0501             	lda stack+5,x		; .sp +5 is actual routn addr lo
  6182  fecd 38                 	sec
  6183  fece e903               	sbc #03			; -3 for jsr to this routn
  6184  fed0 48                 	pha			; save .a
  6185  fed1 bd0601             	lda stack+6,x		; hi addr
  6186  fed4 e900               	sbc #00	
  6187  fed6 aa                 	tax			; .x hi
  6188  fed7 68                 	pla			; restore .a lo
  6189  fed8 2024ff             	jsr putaxs		; save .a.x onto xfer seg stack
  6190  fedb 98                 	tya			; xfer seg stack pointer
  6191  fedc 38                 excomm:	sec
  6192  fedd e904               	sbc #04			; 4 bytes .y.x.a.p
  6193  fedf 8dff01             	sta stackp		; xfer seg new stack pointer temp storage
  6194  fee2 a8                 	tay			; use this as new pointer also
  6195  fee3 a204               	ldx #04			; 4 bytes .y.x.a.p
  6196  fee5 68                 exsu10:	pla
  6197  fee6 c8                 	iny
  6198  fee7 91ac               	sta (ipoint),y		; push regs from this stack to xfer seg stack
  6199  fee9 ca                 	dex
  6200  feea d0f9               	bne exsu10
  6201  feec acff01             	ldy stackp		; restore .y as stack pointer for xfer seg
  6202  feef a92d               	lda #<expul2		; pull regs and rts routn
  6203  fef1 a2ff               	ldx #>expul2		; .hi prendn routn in xfer seg
  6204  fef3 2024ff             	jsr putaxs		; put .a.x on xfer seg stack
  6205  fef6 68                 	pla			; fix stack
  6206  fef7 68                 	pla			; fix stack
  6207  fef8 ba                 exgby:	tsx
  6208  fef9 8eff01             	stx stackp		; save current stack pointer this seg
  6209  fefc 98                 	tya			; .y is stack pointer for xfer seg
  6210  fefd aa                 	tax
  6211  fefe 9a                 	txs			; new stack for xfer seg
  6212  feff a501               	lda i6509		; xfer seg #
  6213  ff01 4cf6ff             	jmp gbye		; good bye
  6214                          ; -------------------------------------------------------------------------------------------------
  6215  ff04 ea                 	nop			; returns here if rti
  6216                          ; FEFE Return from call to foreign bank
  6217  ff05 08                 excrts: php			; .p
  6218  ff06 08                 	php			; .p
  6219                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6220  ff07 78                 	sei             	; dis ints
  6221                          }
  6222  ff08 48                 	pha			; .a
  6223  ff09 8a                 	txa
  6224  ff0a 48                 	pha			; .x
  6225  ff0b 98                 	tya
  6226  ff0c 48                 	pha			; .y
  6227  ff0d ba                 	tsx
  6228  ff0e bd0601             	lda stack+6,x		; sp +6 is return seg
  6229  ff11 8501               	sta i6509		; restore i6509 to return seg
  6230  ff13 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6231  ff16 4cdcfe             	jmp excomm
  6232                          ; -------------------------------------------------------------------------------------------------
  6233                          ; FF11 ipoint = $100, Y = $FF (stack)
  6234  ff19 a001               ipinit: ldy #01
  6235  ff1b 84ad               	sty ipoint+1
  6236  ff1d 88                 	dey
  6237  ff1e 84ac               	sty ipoint		; ipoint=$0100
  6238  ff20 88                 	dey			; .y=$ff
  6239  ff21 b1ac               	lda (ipoint),y		; load stack pointer from $001ff
  6240  ff23 60                 	rts
  6241                          ; -------------------------------------------------------------------------------------------------
  6242                          ; FF1C Place X/A to ipoint (build stack in foreign bank)
  6243  ff24 48                 putaxs: pha			; save A
  6244  ff25 8a                 	txa
  6245  ff26 91ac               	sta (ipoint),y		; .x hi
  6246  ff28 88                 	dey
  6247  ff29 68                 	pla
  6248                          ; FF22 Place A to ipoint (build stack in foreign bank)
  6249  ff2a 91ac               putas:  sta (ipoint),y		; .a lo
  6250  ff2c 88                 	dey
  6251  ff2d 60                 	rts
  6252                          ; -------------------------------------------------------------------------------------------------
  6253                          ; FF26 Pull registers after calling subroutine in foreign bank
  6254  ff2e 68                 expull: pla
  6255  ff2f a8                 	tay			; .y
  6256  ff30 68                 	pla
  6257  ff31 aa                 	tax			; .x
  6258  ff32 68                 	pla			; .a
  6259  ff33 28                 	plp			; .p
  6260  ff34 60                 	rts
  6261                          ; -------------------------------------------------------------------------------------------------
  6262                          ; FF2D Helper routine to route interrupts from foreign to system bank
  6263  ff35 08                 exnmi:  php			; .p
  6264  ff36 6cfaff             	jmp (hwnmi)		; do nmi proc
  6265                          ; -------------------------------------------------------------------------------------------------
  6266                          ; FF31 Helper routine to route BRK insns from foreign to system bank
  6267  ff39 00                 exbrk:  brk
  6268  ff3a ea                 	nop
  6269  ff3b 60                 	rts
  6270                          ; -------------------------------------------------------------------------------------------------
  6271                          ; FF34 Helper routine to route interrupts from foreign to system bank
  6272  ff3c 58                 exirq:  cli
  6273  ff3d 60                 	rts
  6274                          exend:
  6275                          ;
  6276                          excrt2=excrts-1
  6277                          expul2=expull-1
  6278                          ; -------------------------------------------------------------------------------------------------
  6279                          ; (FF36) Unused space
  6280  ff3e ac                 	!byte $AC
  6281                          ; -------------------------------------------------------------------------------------------------
  6282                          !ifdef CBMPATCH{		; ***** moved to place to transfer routines right!
  6283                          ; FE8D 
  6284  ff3f e693               incsal: inc sal
  6285  ff41 d00e               	bne incr20
  6286  ff43 e694               	inc sah
  6287  ff45 d00a               	bne incr20
  6288  ff47 e695               	inc sas
  6289  ff49 a595               	lda sas
  6290  ff4b 8501               	sta i6509
  6291  ff4d a902               	lda #$02		; skip $0000 and $0001
  6292  ff4f 8593               	sta sal
  6293  ff51 60                 incr20:	rts
  6294                          
  6295                          patch2:				; ********** cbmii revision -03 PATCH  ACIA-IRQ routine **********
  6296  ff52 ad00dd             	lda acia+drsn
  6297  ff55 91a6               	sta (ribuf),y		; data to buffer
  6298  ff57 60                 	rts
  6299                          }
  6300                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  6301  ff58 a95a               chkwarm:lda #winit
  6302  ff5a cdfb03             	cmp evect+3		; check winit ?
  6303  ff5d d003               	bne xcold		; no -> cold start
  6304  ff5f 4cfbf9             	jmp swarm		; yes -> warm start
  6305                          
  6306  ff62 4cadf9             xcold:	jmp scold
  6307                          }
  6308                          ; -------------------------------------------------------------------------------------------------
  6309                          ; ##### vectors #####
  6310                          ; FF6F (FF6C) Jump table kernal functions
  6311                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6312                          *= $FF6C
  6313  ff6c 4c9dfe             newsys:	jmp txjmp		; Transfer-of-execution jumper
  6314                          }
  6315                          *= $FF6F
  6316  ff6f 4cd9fb             	jmp vreset		; Power-on/off vector reset
  6317  ff72 4c41fe             ipcgov:	jmp ipcgo		; Loop for ipc system
  6318  ff75 4c22e0             	jmp jfunky		; Function key vector
  6319  ff78 4cb9fc             	jmp iprqst		; Send ipc request
  6320  ff7b 4cfef9             	jmp ioinit		; I/O initialization
  6321  ff7e 4c04e0             	jmp jcint		; Screen initialization
  6322  ff81 4c07f4             aloca:	jmp alocat		; Allocation routine
  6323  ff84 4cb8fb             	jmp vector		; read/set I/O vectors
  6324  ff87 4cb1fb             	jmp restor		; restore I/O vectors
  6325  ff8a 4c67f6             	jmp lkupsa		; Match sa--return sa,fa
  6326  ff8d 4c7ff6             	jmp lkupla		; Match la--return sa,fa
  6327  ff90 4c69fb             	jmp setmsg		; Control o.s. messages
  6328  ff93 6c2403             secnd:	jmp (isecnd)		; Send sa after listen
  6329  ff96 6c2603             tksa:	jmp (itksa)		; Send sa after talk
  6330  ff99 4c87fb             	jmp memtop		; set/read top of memory
  6331  ff9c 4c9cfb             	jmp membot		; set/read bottom of memory
  6332  ff9f 4c13e0             	jmp jkey		; Scan keyboard
  6333  ffa2 4c83fb             	jmp settmo		; set timeout in IEEE
  6334  ffa5 6c2803             acptr:	jmp (iacptr)		; Handshake IEEE byte in
  6335  ffa8 6c2a03             ciout:	jmp (iciout)		; Handshake IEEE byte out
  6336  ffab 6c2c03             untlk:	jmp (iuntlk)		; Send untalk out IEEE
  6337  ffae 6c2e03             unlsn:	jmp (iunlsn)		; Send unlisten out IEEE
  6338  ffb1 6c3003             listn:	jmp (ilistn)		; Send listen out IEEE
  6339  ffb4 6c3203             talk:	jmp (italk)		; Send talk out IEEE
  6340  ffb7 4c56fb             	jmp readst		; read/write I/O status byte
  6341  ffba 4c4ffb             	jmp setlfs		; set la, fa, sa
  6342  ffbd 4c40fb             	jmp setnam		; set length and fn adr
  6343  ffc0 6c0603             open:	jmp (iopen)		; Open logical file/transmit command
  6344  ffc3 6c0803             close:	jmp (iclose)		; Close logical file
  6345  ffc6 6c0a03             chkin:	jmp (ichkin)		; Open channel in
  6346  ffc9 6c0c03             ckout:	jmp (ickout)		; Open channel out
  6347  ffcc 6c0e03             clrch:	jmp (iclrch)		; Close I/O channel
  6348  ffcf 6c1003             basin:	jmp (ibasin)		; Input from channel
  6349  ffd2 6c1203             bsout:	jmp (ibsout)		; Output to channel
  6350  ffd5 6c1a03             load:	jmp (iload)		; Load from file
  6351  ffd8 6c1c03             save:	jmp (isave)		; Save to file
  6352  ffdb 4c15f9             	jmp settim		; Set internal clock
  6353  ffde 4cedf8             	jmp rdtim		; read internal clock
  6354  ffe1 6c1403             stop: 	jmp (istop)		; scan stop key
  6355  ffe4 6c1603             getin:	jmp (igetin)		; Get char from q
  6356  ffe7 6c1803             clall:	jmp (iclall)		; Close all files
  6357  ffea 4c80f9             	jmp udtim		; increment clock
  6358  ffed 4c10e0             	jmp jscror		; Screen org
  6359  fff0 4c19e0             	jmp jplot		; read/set x,y coord
  6360  fff3 4c1ce0             	jmp jiobas		; return I/O base
  6361                          ; -------------------------------------------------------------------------------------------------
  6362                          ; FFF6 Actual execution segment switch routine
  6363  fff6 8500               gbye:	sta e6509		; goodbye...
  6364  fff8 60                 	rts
  6365  fff9 80                 	!byte $80
  6366                          *= $FFFA
  6367                          ; -------------------------------------------------------------------------------------------------
  6368                          ; FFFA Hardware vectors
  6369  fffa 3dfb               hwnmi:  !word nmi		; FB3D Program defineable
  6370  fffc 9ef9               	!word start		; F99E Initialization code
