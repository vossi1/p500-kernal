
; ******** Source: p500kernal.b
     1                          ; Commodore P500 Kernal 901234-02 with Fastboot Patches from Steve Gray
     2                          ; disassembled with DA65 18.4.2020 (Info-file from Ulrich Bassewitz)
     3                          ; modified for ACME assembling by Vossi 05/2020, last update 05/2024
     4                          ; v1.1 special f-keys
     5                          ; v1.2 full ramtest selection (fast test checks only byte $0002 in each page)
     6                          ; v1.3 all patches selectable
     7                          ; v1.4 new F-keys for petsd+
     8                          ; v1.5 superfast video if always in indirect bank 15
     9                          ; v1.6 add txjmp routine from b-series rev -03 kernal (diagtest detects too much RAM - only vice!)
    10                          ; v1.7 moved tx-routines in the correct place = 100% identical to cbm2 04a kernal
    11                          ; v1.8 basic SYS patched - now to selected bank -> Basic $8063 csys vector =  $EDDC-1: $DB, $ED
    12                          ; v1.9 movchar single line screen, slow scroll preserve flags patches rev -03 kernal
    13                          ; v2.0 added complete rev -03 new patched key functions in the editor
    14                          ; v2.1 optional solid Atari Style cursor ;)
    15                          ; v2.2 optional IEEE rev -03 patch with ren
    16                          ; v2.3 dclose patch from b-series rev -03 kernal
    17                          ; v2.4 patch rev. -03 reserves two top pages for swapping system
    18                          ; v2.5 finished all comments, labels, patches
    19                          ; v2.6 correct cbm checksum $e0
    20                          ; v2.7 reset sid
    21                          ; v2.8 patch rev. 04a clear insert flag, rs232
    22                          ; v2.9 SRAM patch - checks warm flags reliable to allow usage of any SRAM chip type
    23                          ; v3.0 Checksum byte constant
    24                          !cpu 6502
    25                          !ct pet		; Standard text/char conversion table -> pet = petscii
    26                          !to "kernal.bin", plain
    27                          ; * switches
    28                          ;STANDARD_FKEYS	= 1	; Standard F-keys
    29                          ;FULL_RAMTEST	= 1	; Standard full and slow RAM-test
    30                          SOLID_CURSOR	= 1	; solid "Atari style cursor"
    31                          ;STANDARD_VIDEO	= 1	; Standard doublechecked video writes (original kernal unfinished)
    32                          CBMPATCH	= 1	; CBM B-series patches -03/-04, Vossi $3BF patches
    33                          CBMPATCH4A	= 1	; CBM B-series patches -04a
    34                          IEEEPATCH	= 1	; CBM-B-series ieee-patches -03 (with ren)
    35                          BANK15_VIDEO	= 1	; Superfast Video with standard vram in bank15
    36                          			;   with vram in bank 0 the kernal doesnt write the color in bank 15!
    37                          SYSPATCH	= 1	; patched Basic SYS command to start code in all banks
    38                          			;   for a return is the txjump kernal part in the ram bank necessary! 
    39                          			;   the patched basic lo with the new sys-vector is also necessary 
    40                          SRAMPATCH	= 1	; checks warm flags reliable to allow usage of any SRAM chip type
    41                          ; the checksum must be adjusted for each individual configuration!
    42                          ; * constants
    43                          FILL		= $AA	; Fills free memory areas with $AA
    44                          TEXTCOL		= $06	; Default text color:   $06 = blue
    45                          BGRCOL		= $01	; background color      $01 = white
    46                          EXTCOL		= $03	; exterior color        $03 = cyan
    47                          CHECKSUM	= $28	; ROM checksum byte (original $00)
    48                          ; ########################################### INFO ################################################
    49                          ; ROM-CHECKSUM-BYTE: cksume
    50                          ; loop3 E129 = Main loop - wait for key input
    51                          ; **************************************** DISCLAIMER *********************************************
    52                          ;***************************************
    53                          ;*                                     *
    54                          ;* KK  K EEEEE RRRR  NN  N  AAA  LL    *
    55                          ;* KK KK EE    RR  R NNN N AA  A LL    *
    56                          ;* KKK   EE    RR  R NNN N AA  A LL    *
    57                          ;* KKK   EEEE  RRRR  NNNNN AAAAA LL    *
    58                          ;* KK K  EE    RR  R NN NN AA  A LL    *
    59                          ;* KK KK EE    RR  R NN NN AA  A LL    *
    60                          ;* KK KK EEEEE RR  R NN NN AA  A LLLLL *
    61                          ;*                                     *
    62                          ;***************************************
    63                          ;***************************************
    64                          ;* CBM KERNAL                          *
    65                          ;*   MEMORY AND I/O DEPENDENT ROUTINES *
    66                          ;* DRIVING THE HARDWARE OF THE         *
    67                          ;* FOLLOWING CBM MODEL :               *
    68                          ;*   P-SERIES (5XX)                    *
    69                          ;* COPYRIGHT (C) 1983 BY               *
    70                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
    71                          ;***************************************
    72                          ;
    73                          ; 6509  used to extend memory on bc2 & p2 systems
    74                          ;   location - used to direct
    75                          ;   $0000 -  execution register (4 bits)
    76                          ;   $0001 -  indirect  register (4 bits)
    77                          ;
    78                          ;   these registers provide 4 extra high-order address control lines.  
    79                          ;     on 6509 reset all lines are high.
    80                          ;
    81                          ; current memory map:
    82                          ;   segment 15- $ffff-$e000  rom (kernal)
    83                          ;               $dfff-$df00  i/o  6525 tpi2
    84                          ;               $deff-$de00  i/o  6525 tpi1
    85                          ;               $ddff-$dd00  i/o  6551 acia
    86                          ;               $dcff-$dc00  i/o  6526 cia
    87                          ;               $dbff-$db00  i/o  unused (z80,8088,68008)
    88                          ;               $daff-$da00  i/o  6581 sid
    89                          ;               $d9ff-$d900  i/o  unused (disks)
    90                          ;               $d8ff-$d800  i/o  6569 vic
    91                          ;               $d7ff-$d400  color nybles
    92                          ;               $d3ff-$d000  video matrix
    93                          ;               $cfff-$c000  character dot rom
    94                          ;               $bfff-$8000  roms external (language)
    95                          ;               $7fff-$4000  roms external (extensions)
    96                          ;               $3fff-$2000  rom  external
    97                          ;               $1fff-$1000  rom  internal
    98                          ;               $0fff-$0400  unused
    99                          ;               $03ff-$0002  ram (kernal/basic system)
   100                          ;   segment 14- segment 4 open (future expansion)
   101                          ;   segment 3 - $ffff-$0002  ram p2 optinal
   102                          ;   segment 2 - $ffff-$0002  ram p2 optinal
   103                          ;   segment 1 - $ffff-$0002  ram p2 standard
   104                          ;   segment 0 - $ffff-$0002  ram p2 standard
   105                          ;
   106                          ; the 6509 registers appear in locations $0000 and $0001 in all segments of memory.
   107                          ; ***************************************** ZEROPAGE **********************************************
   108                          	e6509		= $00		; 6509 execution bank reg
   109                          	i6509		= $01		; 6509 indirect bank reg
   110                          ;
   111                          ; $02-$8f BASIC zeropage 
   112                          ;
   113                          ; Kernal page zero variables
   114                          ; Kernal indirect address variables
   115                          	fnadr		= $90		; Address of file name string
   116                          	sal		= $93		; Current load/store address
   117                          	sah		= $94		;   low, high, bank
   118                          	sas		= $95
   119                          	eal		= $96		; End of load/save
   120                          	eah		= $97
   121                          	eas		= $98
   122                          	stal		= $99		; Start of load/save
   123                          	stah		= $9A
   124                          	stas		= $9B
   125                          	; Frequently used kernal variables
   126                          	status		= $9C		; I/O operation status
   127                          	fnlen		= $9D		; File name length
   128                          	la		= $9E		; Current logical index
   129                          	fa		= $9F		; Current first address
   130                          	sa		= $A0		; Current secondary address
   131                          	dfltn		= $A1		; Default input device
   132                          	dflto		= $A2		; Default output device
   133                          ; Tape buffer pointer
   134                          	tape1		= $A3		; Address of tape buffer
   135                          ; RS-232 input buffer
   136                          	ribuf		= $A6		; Input buffer
   137                          ; Variables for kernal speed
   138                          	stkey		= $A9		; Stop key flag
   139                          	ctemp		= $A9		; used to reduce cassette read times 
   140                          	c3po		= $AA		; IEEE buffer flag
   141                          	snsw1		= $AA		; used to reduce cassette read times 
   142                          	bsour		= $AB		; IEEE character buffer 
   143                          ; Cassette temps - overlays IPC buffer
   144                          	ipoint		= $AC		; next 2 bytes used for transx code
   145                          	syno		= $AC
   146                          	dpsw		= $AD
   147                          ; next 18 bytes also used for monitor
   148                          	ptr1		= $AE		; index to pass1 errors
   149                          	ptr2		= $AF		; index to pass2 errors
   150                          	pcntr		= $B0
   151                          	firt		= $B1
   152                          	cntdn		= $B2
   153                          	shcnl		= $B3
   154                          	rer		= $B4
   155                          	rez		= $B5
   156                          	rdflg		= $B6
   157                          	flagt1		= $B7		; temp during bit read time
   158                          	shcnh		= $B7
   159                          	cmp0		= $B8
   160                          	diff		= $B9
   161                          	prp		= $BA
   162                          	ochar		= $BB
   163                          	prty		= $BC
   164                          	fsblk		= $BD
   165                          	mych		= $BE
   166                          	cdata		= $BF		; how to turn cassette timers on
   167                          ; Monitor virtual registers - Place in these locations temporarly...
   168                          	pch		= $AE		; counter
   169                          	pcl		= $AF
   170                          	flgs		= $B0		; Processor status
   171                          	acc		= $B1		; Accumulator
   172                          	xr		= $B2		; X register
   173                          	yr		= $B3		; Y register
   174                          	sp		= $B4		; Stack pointer
   175                          	xi6509		= $B5		; Old indirection segment
   176                          	re6509		= $B6		; Return execution segment
   177                          	invh		= $B7		; User interrupt vector
   178                          	invl		= $B8
   179                          ; Monitor indirect variables
   180                          	tmp0		= $B9		; Temp pointer
   181                          	tmp2		= $BB		; Temp pointer
   182                          ; Other monitor variables
   183                          	tmpc		= $BD		; Place to save last cmd
   184                          	t6509		= $BE		; Temporary i6509
   185                          	ddisk		= $BF		; Default disk unit # for monitor
   186                          ; Screen editor page zero variables
   187                          ; Editor indirect variables
   188                          	pkybuf		= $C0		; Start adr of pgm key
   189                          	keypnt		= $C2		; Current pgm key buf
   190                          	sedsal		= $C4		; Scroll ptr
   191                          	sedeal		= $C6		; Scroll ptr
   192                          	pnt		= $C8		; Current character pointer
   193                          ; Editor variables for speed & size
   194                          	tblx		= $CA		; Cursor line
   195                          	pntr		= $CB		; Cursor column
   196                          	grmode		= $CC		; Graphic/text mode flag $00=graphic, $02=text
   197                          	lstx		= $CD		; Last character index
   198                          	lstp		= $CE		; Screen editor start position
   199                          	lsxp		= $CF		; Screen editor start row
   200                          	crsw		= $D0		; cr flag - cr pressed -> input from screen
   201                          	ndx		= $D1		; Index to keyd queue
   202                          	qtsw		= $D2		; Quote mode flag
   203                          	insrt		= $D3		; Insert mode flag
   204                          	config		= $D4		; Char before blink (petii)
   205                          	indx		= $D5		; last byte position on line (##234-02##244-02)
   206                          	kyndx		= $D6		; count of program key string
   207                          	rptcnt		= $D7		; Deelay tween chars
   208                          	delay		= $D8		; Delay to next repeat
   209                          	sedt1		= $D9		; Frequently used temp variables
   210                          	sedt2		= $DA
   211                          ; Frequently used editor variables
   212                          	data		= $DB		; Current print data
   213                          	sctop		= $DC		; Top screen 0-24 of current window
   214                          	scbot		= $DD		; Bottom 0-24
   215                          	sclf		= $DE		; Left margin
   216                          	scrt		= $DF		; Right margin
   217                          	modkey		= $E0		; Keyscanner shift/control flags ($ff-nokey)
   218                          	norkey		= $E1		; Keyscanner normal key number ($ff-nokey)
   219                          ; Screen editor usage
   220                          	bitabl		= $E2		; Wrap bitmap
   221                          	blnon		= $E6		; Blinking cursor on = $00
   222                          	blncnt		= $E7		; Blink counter
   223                          	user		= $E8		; Pointer to color RAM
   224                          	tcolor		= $EA		; Temporary color
   225                          	blnsw		= $EB		; Blink switch
   226                          	color		= $EC		; Character color
   227                          	gdcol		= $ED		; Color behind cursor
   228                          	saver		= $EE		; Temp store for output char
   229                          	scrseg		= $EF		; Segment /bank of video RAM
   230                          ; Free zero page space, 16 bytes
   231                          	zpend		= $F0
   232                          ; ***************************************** ABSOLUTE **********************************************
   233                          ; System stack area
   234                          	stack		= $0100		; Stack
   235                          	bad		= $0100		; Cassette bad address table
   236                          	stackp		= $01FF		; System Stack pointer transx code
   237                          ; -------------------------------------------------------------------------------------------------
   238                          ; $200 - $256 Basic's ROM page work area
   239                          	buf		= $0200		; Basic input buffer
   240                          ; Basic RAM vectors
   241                          	ierror		= $0280         ; Basic error indirect
   242                          ; -------------------------------------------------------------------------------------------------
   243                          ; System RAM vectors
   244                          	cinv		= $0300		; IRQ vector
   245                          	cbinv		= $0302		; BRK vector
   246                          	nminv		= $0304		; NMI vector
   247                          	iopen		= $0306		; Open file vector
   248                          	iclose		= $0308		; Close file vector
   249                          	ichkin		= $030A		; Open channel in vector
   250                          	ickout		= $030C		; Open channel out vector
   251                          	iclrch		= $030E		; Close channel vector
   252                          	ibasin		= $0310		; Input from channel vector 
   253                          	ibsout		= $0312		; Output to channel vector
   254                          	istop		= $0314		; Check stop key vector
   255                          	igetin		= $0316		; Get from queue vector
   256                          	iclall		= $0318		; Close all files vector
   257                          	iload		= $031A		; Load from file vector
   258                          	isave		= $031C		; Save to file vector
   259                          	usrcmd		= $031E		; Monitor extension vector
   260                          	escvec		= $0320		; User ESC key vector
   261                          	ctlvec		= $0322		; unused control key vector
   262                          	isecnd		= $0324		; IEEE listen secondary address
   263                          	itksa		= $0326		; IEEE talk secondary address
   264                          	iacptr		= $0328		; IEEE character in routine
   265                          	iciout		= $032A		; IEEE character out routine
   266                          	iuntlk		= $032C		; IEEE bus untalk
   267                          	iunlsn		= $032E		; IEEE bus unlisten
   268                          	ilistn		= $0330		; IEEE listen device primary address
   269                          	italk		= $0332		; IEEE talk device primary address
   270                          ; Kernal absolute variables
   271                          	lat		= $0334		; Logical file numbers / table
   272                          	fat		= $033E		; Device numbers / table
   273                          	sat		= $0348		; Secondary addresses / table
   274                          ;
   275                          	lowadr		= $0352		; Start of system memory: low, high, bank
   276                          	hiadr		= $0355		; Top of system memory: low, high, bank
   277                          	memstr		= $0358		; Start of user memory: low, high, bank
   278                          	memsiz		= $035B		; Top of user memory: low, high, bank
   279                          	timout		= $035E		; IEEE timeout enable
   280                          	verck		= $035F		; load/verify flag
   281                          	ldtnd		= $0360		; Device table index
   282                          	msgflg		= $0361		; Message flag
   283                          	bufpt		= $0362		; Cassette buffer index
   284                          ; Kernal temporary (local) variables
   285                          	t1		= $0363
   286                          	t2		= $0364 
   287                          	xsav		= $0365 
   288                          	savx		= $0366 
   289                          	svxt		= $0367 
   290                          	temp		= $0368 
   291                          	alarm		= $0369		; IRQ variable holds 6526 IRQ's
   292                          ; Kernal cassette variables
   293                          	itape		= $036A		; Indirect for cassette code
   294                          	cassvo		= $036C		; Cassette read variable
   295                          	aservo		= $036D		; Flag1***indicates t1 timeout cassette read
   296                          	caston		= $036E		; How to turn on timers
   297                          	relsal		= $036F		; moveable start load address
   298                          	relsah		= $0370		; 
   299                          	relsas		= $0371		; 
   300                          	oldinv		= $0372		; restore user IRQ and i6509 after cassettes
   301                          	cas1		= $0375		; Cassette switch flag
   302                          ; RS-232 information storage
   303                          	m51ctr		= $0376		; 6551 control image
   304                          	m51cdr		= $0377		; 6551 command image
   305                          	rsstat		= $037A		; perm. RS-232 status
   306                          	dcdsr		= $037B		; last DCD/DSR value
   307                          	ridbs		= $037C		; Input start index
   308                          	ridbe		= $037D		; Input end index
   309                          ; Screen editor absolute
   310                          ; $037E - $037F Block some area for editor
   311                          	pkyend		= $0380		; Program key buffer end address
   312                          	keyseg		= $0382		; Segment / bank of function key texts
   313                          	rvs		= $0383		; Reverse mode flag
   314                          	lintmp		= $0384		; Line # between in and out 
   315                          	lstchr		= $0385		; Last char printed
   316                          	insflg		= $0386		; Insert mode flag
   317                          	scrdis		= $0387		; Scroll disable flag
   318                          	bitmsk		= $0388		; Temorary bitmask
   319                          	fktmp		= $0388		;   also used for function key temporary
   320                          	keyidx		= $0389		; Index to programmables
   321                          	logscr		= $038A		; Logical/physical scroll flag
   322                          	bellmd		= $038B		; Bell on/off flag
   323                          	pagsav		= $038C		; Temp RAM page
   324                          	keysiz		= $038D		; Sizes of function key texts
   325                          	tab		= $03A1		; Tabstop flags
   326                          	keyd		= $03AB		; Keyboard buffer
   327                          	funvec		= $03B5		; Vector: funktion key handler
   328                          	iwrtvrm		= $03B7		; Vector: video ram write routine
   329                          	iwrtcrm		= $03B9		; Vector: color ram write routine
   330                          	iunkwn1		= $03BB		; Vector: -> E039 nofunc
   331                          	iunkwn2		= $03BD		; Vector: -> E039 nofunc
   332                          	unknwn		= $03BF		; unknown from old editor (some flag like quote or insert?)
   333                          ; $03C0 - $3F7 Free absolute space
   334                          	absend		= $03C0
   335                          ; System warm start variables and vectors
   336                          	evect		= $03F8		; Warm start vector and flags 5 bytes
   337                          ; -------------------------------------------------------------------------------------------------
   338                          ; Free bank 15 RAM 1024 bytes
   339                          	ramloc          = $0400		; First free ram location
   340                          ; -------------------------------------------------------------------------------------------------
   341                          ; Kernal inter-process communication variables 
   342                          	ipbsiz		= 16            ; Ipc buffer size
   343                          	ipb		= $0800		; IPC buffer
   344                          	ipjtab		= ipb+ipbsiz	; IPC jump table
   345                          	ipptab		= $0910		; IPC param spec table
   346                          ; Ipc buffer offsets
   347                          	ipccmd		= 0		; Ipc command
   348                          	ipcjmp		= 1		; Ipc jump address
   349                          	ipcin		= 3		; Ipc #input bytes
   350                          	ipcout		= 4		; Ipc #output bytes
   351                          	ipcdat		= 5		; Ipc data buffer (8 bytes max)
   352                          ; *************************************** IO / EQUATES ********************************************
   353                          ; Equates
   354                          	irom	= $F		; System bank
   355                          	id55hz	= 14		; 55hz value required by ioinit
   356                          	warm	= $A5		; Warm start flag
   357                          	winit	= $5A  		; Initialization complete flag
   358                          	llen	= 40            ; Screen length
   359                          	nrows	= 25            ; Screen length
   360                          	scxmax	= llen-1        ; Max column number
   361                          	scymax	= nrows-1       ; Max line number
   362                          	keymax	= 9             ; Keyboard buffer size - 1
   363                          	dblzer	= 89            ; Key code for double zero
   364                          	pgmkys	= 20            ; Number of progam keys
   365                          ; Tape block types
   366                          	eot	= 5             ; End of tape
   367                          	blf	= 1             ; Basic load file
   368                          	bdf	= 2             ; Basic data file
   369                          	bdfh	= 4             ; Basic data file header
   370                          	bufsz	= 192           ; Buffer size
   371                          	cr	= $d            ; Carriage return
   372                          ; ROM / RAM addresses
   373                          	basic	= $8000		; Start of ROM (language)
   374                          	chrrom	= $C000		; Character ROM
   375                          	scnram	= $D000		; Video RAM
   376                          	clrram	= $D400		; Color RAM nibbles
   377                          	kernal	= $E000		; Start of ROM (kernal)
   378                          ; 6569 VIC Video interface device
   379                          	vic	= $D800		; VIC
   380                          	memptr	= $18		; VIC memory pointers register
   381                          ; 6581 SID Sound interface device
   382                          	sid	= $DA00
   383                          	osc1	= $00		; base addresses osc1, osc2, osc3
   384                          	osc2	= $07
   385                          	osc3	= $0E
   386                          	freqlo	= $00		; osc registers
   387                          	freqhi	= $01
   388                          	pulsef	= $02
   389                          	pulsec	= $03
   390                          	oscctl	= $04
   391                          	atkdcy	= $05
   392                          	susrel	= $06
   393                          	fclow	= $15		; filter control
   394                          	fchi	= $16
   395                          	resnce	= $17
   396                          	volume	= $18
   397                          	potx	= $19		; pots, random number and env3 out
   398                          	poty	= $1A
   399                          	random	= $1B
   400                          	env3	= $1C
   401                          ; 6526 CIA for inter-process communication
   402                          	ipcia	= $DB00
   403                          	; pra  = data port
   404                          	; prb0 = busy1 (1=>6509 off dbus)
   405                          	; prb1 = busy2 (1=>8088/z80 off dbus)
   406                          	; prb2 = semaphore 8088/z80
   407                          	; prb3 = semaphore 6509
   408                          	; prb4 = unused
   409                          	; prb5 = unused
   410                          	; prb6 = irq to 8088/z80 (lo)
   411                          	; prb7 = unused
   412                          	sem88	= $04	; prb bit2
   413                          	sem65	= $08	; prb bit3
   414                          ; 6526 CIA Complex interface adapter - game / IEEE data / user
   415                          	; timer a: ieee local / cass local / music / game
   416                          	; timer b: ieee deadm / cass deadm / music / game
   417                          	;
   418                          	; pra0: ieee data1 / user / paddle game 1
   419                          	; pra1: ieee data2 / user / paddle game 2
   420                          	; pra2: ieee data3 / user
   421                          	; pra3: ieee data4 / user
   422                          	; pra4: ieee data5 / user
   423                          	; pra5: ieee data6 / user
   424                          	; pra6: ieee data7 / user / game trigger 14
   425                          	; pra7: ieee data8 / user / game trigger 24
   426                          	;
   427                          	; prb0: user / game 10
   428                          	; prb1: user / game 11
   429                          	; prb2: user / game 12
   430                          	; prb3: user / game 13
   431                          	; prb4: user / game 20
   432                          	; prb5: user / game 21
   433                          	; prb6: user / game 22
   434                          	; prb7: user / game 23
   435                          	;
   436                          	; flag: user / cassette read
   437                          	cia	= $DC00
   438                          	pra	= $0	; Data reg A
   439                          	prb	= $1	; Data reg B
   440                          	ddra	= $2	; Direction reg a
   441                          	ddrb	= $3	; Direction reg b
   442                          	talo	= $4	; Timer A low  byte
   443                          	tahi	= $5	; Timer A high byte
   444                          	tblo	= $6	; Timer B low  byte
   445                          	tbhi	= $7	; Timer B high byte
   446                          	tod10	= $8	; 10ths of seconds
   447                          	todsec	= $9	; Seconds
   448                          	todmin	= $A	; Minutes
   449                          	todhr	= $B	; Hours
   450                          	sdr	= $C	; Serial data register
   451                          	icr	= $D	; Interrupt control register
   452                          	cra	= $E	; Control register A
   453                          	crb	= $F	; Control register B
   454                          ; 6551 ACIA RS-232 and network interface
   455                          	acia	= $DD00
   456                          	drsn	= $0	; Transmitt/receive data register
   457                          	srsn	= $1	; Status register
   458                          	cdr	= $2	; Command register
   459                          	ctr	= $3	; Control register
   460                          	; Equates
   461                          	dsrerr	= $40	; Data set ready error
   462                          	dcderr	= $20	; Data carrier detect error
   463                          	doverr	= $08	; Receiver outer buffer overrun
   464                          ; 6525 TPI1 Triport interface device #1 - IEEE control / cassette / network / vic / irq
   465                          	tpi1	= $DE00
   466                          	; pa0: ieee dc control (ti parts)
   467                          	; pa1: ieee te control (ti parts) (t/r)
   468                          	; pa2: ieee ren
   469                          	; pa3: ieee atn
   470                          	; pa4: ieee dav
   471                          	; pa5: ieee eoi
   472                          	; pa6: ieee ndac
   473                          	; pa7: ieee nrfd
   474                          	;
   475                          	; pb0: ieee ifc
   476                          	; pb1: ieee srq
   477                          	; pb2: network transmitter enable
   478                          	; pb3: network receiver enable
   479                          	; pb4: arbitration logic switch
   480                          	; pb5: cassette write
   481                          	; pb6: cassette motor
   482                          	; pb7: cassette switch
   483                          	;
   484                          	; irq0: 50/60 hz irq
   485                          	; irq1: ieee srq
   486                          	; irq2: 6526 irq
   487                          	; irq3: (opt) 6526 inter-processor
   488                          	; irq4: 6551
   489                          	; *irq: 6569 (vic) / user devices
   490                          	; cb:   vic dot select - cr #7-6 11=bank 15, 01=bank 0
   491                          	; ca:   vic matrix select - cr #5-4 11=bank 15, 01=bank 0
   492                          	pa	= $0	; Port register A
   493                          	pb	= $1	; Port register B
   494                          	pc	= $2	; Port register C
   495                          	lir	= $2	; Interrupt latch register mc=1
   496                          	ddpa	= $3	; Data direction register A
   497                          	ddpb	= $4	; Data direction register B
   498                          	ddpc	= $5	; Data direction register C
   499                          	mir	= $5	; Interrupt mask register mc=1
   500                          	creg	= $6	; Control reg: #0 mc=IRQ mode / #1 ip= IRQ parity / #2-3 edge i3,i4	
   501                          	air	= $7	; Active interrupt register
   502                          	; Equates
   503                          	dc	= $01	; 75160/75161 control line
   504                          	te	= $02	; 75160/75161 control line
   505                          !ifdef IEEEPATCH{
   506                          	ren	= $04	; Remote enable
   507                          } else{
   508                          	ren	= 0	; Remote enable
   509                          }
   510                          	atn	= $08	; Attention
   511                          	dav	= $10	; Data available
   512                          	eoi	= $20	; End or identify
   513                          	ndac	= $40	; Not data accepted
   514                          	nrfd	= $80	; Not ready for data
   515                          	ifc	= $01	; Interface clear
   516                          	srq	= $02	; Service request
   517                          	
   518                          	rddb	= nrfd+ndac+te+dc+ren	;directions for receiver
   519                          	tddb	= eoi+dav+atn+te+dc+ren	;directions for transmitt
   520                          	
   521                          	eoist	= $40	; eoi status test
   522                          	tlkr	= $40	; device is talker
   523                          	lstnr	= $20	; device is listener
   524                          	utlkr	= $5f	; device untalk
   525                          	ulstn	= $3f	; device unlisten
   526                          	       
   527                          	toout	= $01	; timeout status on output
   528                          	toin	= $02	; timeout status on input
   529                          	eoist	= $40	; eoi on input
   530                          	nodev	= $80	; no device on bus.
   531                          	sperr	= $10	; verify error
   532                          	; Equates for c3p0 flag bits 6 and 7.
   533                          	slock	= $40	; screen editor lock-out
   534                          	dibf	= $80	; data in output buffer
   535                          ; 6525 TPI2 Triport interface device #2
   536                          	tpi2	= $DF00
   537                          	; pa: kyrd out 8-15
   538                          	; pb: kybd out 0-7
   539                          	;
   540                          	; pc0: kybd in 0
   541                          	; pc1: kybd in 1
   542                          	; pc2: kybd in 2
   543                          	; pc3: kybd in 3
   544                          	; pc4: kybd in 4
   545                          	; pc5: kybd in 5
   546                          	; pc6: vic 16k bank select low
   547                          	; pc7: vic 16k bank select hi
   548                          ; **************************************** COLD START *********************************************
   549                          !initmem FILL                   ; All unused memory filled with $AA
   550                          !zone cold
   551                          *= kernal
   552  e000 4c09ee             jmoncld:jmp monoff		; Monitor cold start
   553  e003 ea                 	nop
   554                          ; ****************************************** EDITOR ***********************************************
   555                          ;***************************************
   556                          ;*                                     *
   557                          ;* EEEEE DDD   IIIII TTTTT  OOO  RRRR  *
   558                          ;* E     D  D    I     T   O   O R   R *
   559                          ;* E     D   D   I     T   O   O R   R *
   560                          ;* EEE   D   D   I     T   O   O RRRR  *
   561                          ;* E     D   D   I     T   O   O R R   *
   562                          ;* E     D  D    I     T   O   O R  R  *
   563                          ;* EEEE  DDD   IIIII   T    OOO  R   R *
   564                          ;*                                     *
   565                          ;***************************************
   566                          ;***************************************
   567                          ;*   CBM EDITOR FOR P-SERIES SYSTEMS   *
   568                          ;*   KEYBOARD AND SCREEN EDIT ROUTINES *
   569                          ;* DRIVING THE HARDWARE OF THE         *
   570                          ;* FOLLOWING CBM MODELS:               *
   571                          ;*   P-SERIES                          *
   572                          ;* COPYRIGHT (C) 1983 BY               *
   573                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
   574                          ;***************************************
   575                          !zone editor
   576                          *= kernal+4
   577                          ;****************************************
   578                          ;
   579                          ;  40 column pet ii screen editor
   580                          ;    with unlimited screen line wrap
   581                          ;
   582                          ;****************************************
   583                          ; E004 Jump vector table
   584  e004 4c44e0             jcint:  jmp cint		; Init Screen editor, VIC, F-keys
   585  e007 4cf4e0             jlp2:	jmp lp2			; Read a key from keyboard to A
   586  e00a 4c74e1             jloop5:	jmp loop5		; Read character from screen to A
   587  e00d 4c84e2             jprt:	jmp prt			; Print character from A on screen
   588  e010 4c3fe0             jscror:	jmp scrorg		; Return screen dimensions to X, Y
   589  e013 4c0ce9             jkey:	jmp scnkey		; Keyboard scan
   590  e016 4c36e0             jmvcur: jmp nofunc		; not used in P500 - only for CRTC hardware cursor in b-series
   591  e019 4c25e0             jplot:  jmp plot		; Get/set the cursor position to/from X, Y
   592  e01c 4c3ae0             jiobas:	jmp iobase		; Return CIA base address to X, Y
   593  e01f 4c3cea             jescrt:	jmp escape		; Handle an escape sequence
   594  e022 4ca1e7             jfunky:	jmp keyfun		; Get/set/list function keys
   595                          ; -------------------------------------------------------------------------------------------------
   596                          ; E025 Get/set the cursor position
   597  e025 b00b               plot:   bcs rdplt		; if C=1 get cursor position
   598                          ; set cursor
   599  e027 86ca               	stx tblx		; store line, last line 
   600  e029 86cf               	stx lsxp
   601  e02b 84cb               	sty pntr		; store column, last column
   602  e02d 84ce               	sty lstp
   603                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
   604  e02f 20dfe0             	jsr stupt		; Change pointer to this new line
   605  e032 a6ca               rdplt:  ldx tblx
   606  e034 a4cb               	ldy pntr		; load column, row
   607  e036 60                 nofunc: rts
   608                          } else{
   609                          	jsr sreset		; set full screen window
   610                          	jsr stupt		; Change pointer to this new line
   611                          ; get cursor pos
   612                          rdplt:  ldx tblx		; load row, column
   613                          	ldy pntr
   614                          nofunc: rts
   615                          }
   616                          *= $E03A
   617                          ; -------------------------------------------------------------------------------------------------
   618                          ; E03A Return CIA base address
   619  e03a a200               iobase: ldx #<cia
   620  e03c a0dc               	ldy #>cia
   621  e03e 60                 	rts
   622                          ; -------------------------------------------------------------------------------------------------
   623                          ; E03F Return screen dimensions
   624  e03f a228               scrorg: ldx #llen		; 40 columns
   625  e041 a019               	ldy #nrows		; 25 rows
   626  e043 60                 	rts
   627                          ; -------------------------------------------------------------------------------------------------
   628                          ; $E044 Screen editor init (editor, F-Keys, VIC)
   629                          ; Clear editor variables
   630  e044 a900               cint:   lda #0
   631  e046 a22d               	ldx #zpend-keypnt-1	; $C2-$EF
   632  e048 95c2               cloop1: sta keypnt,x		; clear page 0 variables
   633  e04a ca                 	dex
   634  e04b 10fb               	bpl cloop1
   635                          
   636  e04d a23c               	ldx #absend-rvs-1	; $38D-$3C9
   637  e04f 9d8d03             cloop2: sta keysiz,x		; clear absolute variables
   638  e052 ca                 	dex
   639  e053 10fa               	bpl cloop2
   640                          ; init some variables
   641  e055 a90f               	lda #irom
   642  e057 85ef               	sta scrseg		; store bank with video RAM = system bank
   643  e059 a90c               	lda #$C
   644  e05b 85e7               	sta blncnt		; init blink counter
   645  e05d 85e6               	sta blnon
   646                          ; init F-keys
   647  e05f a5c0               	lda pkybuf		; check if buffers are allocated
   648  e061 05c1               	ora pkybuf+1
   649  e063 d022               	bne keycpy		; yes..just copy f-keys (erased with absolute vars)
   650  e065 ad5503             	lda hiadr		; get end of key area
   651  e068 8d8003             	sta pkyend
   652  e06b ad5603             	lda hiadr+1
   653  e06e 8d8103             	sta pkyend+1
   654  e071 a940               	lda #$40		; NO SENSE - will be overwritten in alocat                
   655  e073 a200               	ldx #0	
   656  e075 a002               	ldy #2
   657  e077 2081ff             	jsr aloca		; get 512 bytes at end of system memory $FEFF
   658  e07a b026               	bcs noroom		; no room found...just reset the screen
   659  e07c 8d8203             	sta keyseg		; store bank for F-keys
   660  e07f e8                 	inx
   661  e080 86c0               	stx pkybuf		; save start address (returned X+1)
   662  e082 d001               	bne room10
   663  e084 c8                 	iny
   664  e085 84c1               room10: sty pkybuf+1		; save start address
   665  e087 a039               keycpy: ldy #keyend-keydef	; load size of F-key texts
   666  e089 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   667  e08c b9b5ec             kyset1: lda keydef-1,y
   668  e08f 88                 	dey
   669  e090 91c0               	sta (pkybuf),y		; copy key texts to buffer
   670  e092 d0f8               	bne kyset1
   671                          
   672  e094 207ce2             	jsr pagres		; restore ram page (indirect segment)
   673  e097 a00a               	ldy #keydef-keylen	; 10 F-key length bytes
   674  e099 b9abec             kyset2: lda keylen-1,y
   675  e09c 998c03             	sta keysiz-1,y		; copy F-key text length to $38D
   676  e09f 88                 	dey
   677  e0a0 d0f7               	bne kyset2
   678                          ; init VIC, screen
   679  e0a2 2093ea             noroom: jsr sreset		; set full screen window
   680  e0a5 a211               	ldx #$11		; init vic regs $21-$11
   681  e0a7 a021               	ldy #$21
   682  e0a9 bdf6ec             vicint:	lda tvic-1,x
   683  e0ac 2012e6             	jsr wrtvic		; write A to VIC register Y
   684  e0af 88                 	dey
   685  e0b0 ca                 	dex
   686  e0b1 d0f6               	bne vicint
   687  e0b3 2053e2             	jsr txcrt		; set text mode/char rom
   688                          
   689  e0b6 a20a               	ldx #$0A
   690  e0b8 bd07ed             edvecl: lda edvect-1,x		; copy extended editor vector table to $3B5
   691  e0bb 9db403             	sta funvec-1,x
   692  e0be ca                 	dex
   693  e0bf d0f7               	bne edvecl
   694                          
   695  e0c1 a906               	lda #TEXTCOL
   696  e0c3 85ec               	sta color		; init color
   697                          ; E0C8 Clear screen, cursor home
   698  e0c5 20d3e0             clsr:	jsr nxtd		; Start at top of window
   699  e0c8 20e1e0             cls10:	jsr scrset		; set screen pointers
   700  e0cb 2024e2             	jsr clrln		; clear the line
   701  e0ce e4dd               	cpx scbot		; done ?
   702  e0d0 e8                 	inx
   703  e0d1 90f5               	bcc cls10		; no
   704                          ; E0D3 Cursor home
   705  e0d3 a6dc               nxtd:   ldx sctop		; move to top
   706  e0d5 86ca               	stx tblx
   707  e0d7 86cf               	stx lsxp		; for input after home or clear
   708  e0d9 a4de               stu10:  ldy sclf		; left of the screen window
   709  e0db 84cb               	sty pntr
   710  e0dd 84ce               	sty lstp
   711                          ; E0DF Reset screen ptr to line begin
   712  e0df a6ca               stupt:	ldx tblx		; get curent line index
   713                          ; E0F1 Set screen ptr to line X 
   714  e0e1 bd3aec             scrset: lda ldtb2,x		; load start of screen line low
   715  e0e4 85c8               	sta pnt			; and store to screen, color RAM ptr
   716  e0e6 85e8               	sta user
   717  e0e8 bd53ec             	lda ldtb1,x		; load high
   718  e0eb 85c9               	sta pnt+1		; and store to char pointer
   719  e0ed 2903               	and #$03
   720  e0ef 09d4               	ora #>clrram		; calc color RAM high and store to color RAM ptr
   721  e0f1 85e9               	sta user+1
   722  e0f3 60                 	rts
   723                          ; -------------------------------------------------------------------------------------------------
   724                          ; *** Input routines ***
   725                          ; E0F4 Remove character from queue
   726  e0f4 a6d6               lp2:  	ldx kyndx		; are there any pgm keys
   727  e0f6 f012               	beq lp3			; branch if not
   728  e0f8 ac8903             	ldy keyidx		; get index to current char
   729  e0fb 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   730  e0fe b1c2               	lda (keypnt),y		; get current byt
   731  e100 207ce2             	jsr pagres		; restore ram page (indirect segment)
   732  e103 c6d6               	dec kyndx		; 1 byte down
   733  e105 ee8903             	inc keyidx		; bump index to next char
   734  e108 58                 	cli
   735  e109 60                 	rts
   736                          ; No F-key
   737  e10a acab03             lp3: 	ldy keyd		; get key from irq buffer
   738  e10d a200               	ldx #0
   739  e10f bdac03             lp1:  	lda keyd+1,x		; shift key buffer
   740  e112 9dab03             	sta keyd,x
   741  e115 e8                 	inx
   742  e116 e4d1               	cpx ndx			; shift till last key in buffer
   743  e118 d0f5               	bne lp1
   744  e11a c6d1               	dec ndx			; decrease key index
   745  e11c 98                 	tya			; return char in A
   746  e11d 58                 	cli
   747  e11e 60                 	rts
   748                          ; -------------------------------------------------------------------------------------------------
   749                          ; E11F Screen input - Main loop
   750  e11f 2084e2             loop4:	jsr prt			; print the character
   751                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
   752  e122 4c28e1             	jmp loop3
   753                          } else{
   754                          	asl unknwn
   755                          	lsr unknwn		; clear bit#7 in $03BF
   756                          }
   757                          *= $E128
   758                          ; wait for key input
   759  e128 a5d1               loop3:  lda ndx			; check key and pgm-key index
   760  e12a 05d6               	ora kyndx
   761  e12c 85e6               	sta blnon
   762  e12e f0f8               	beq loop3		; loop - wait for key input
   763                          ; key available
   764  e130 78                 	sei			; disable interrupts
   765  e131 a5eb               	lda blnsw
   766  e133 f00b               	beq lp21		; skip if cursor blink already switched off
   767  e135 a5d4               	lda config		; load char before blink
   768  e137 a000               	ldy #$00
   769  e139 84eb               	sty blnsw		; switch off cursor blink
   770  e13b a6ed               	ldx gdcol		; load color behind cursor
   771  e13d 200fe2             	jsr dspcol		; write char before blink
   772                          ; check key
   773  e140 20f4e0             lp21:	jsr lp2			; get key input
   774  e143 c90d               	cmp #$D
   775  e145 d0d8               	bne loop4		; print char if not cr
   776                          ; return recognized
   777  e147 85d0               	sta crsw		; set cr flag - we pass chars now
   778  e149 20f7e4             	jsr fndend		; check nxt line for cont (double line?)
   779  e14c 8e8403             	stx lintmp		; save last line number of sentence
   780                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
   781  e14f 202fed             	jsr patch4a2		; ***** patch4a-2 - make space for clear insert flag *****
   782  e152 85d3               	sta insrt		; ***** patch4a-2 - clear insert flag *****
   783                          } else{
   784                          	jsr fistrt		; find begining of line
   785                          	lda #0
   786                          }
   787  e154 85d2               	sta qtsw		; clear quote mode
   788  e156 a4de               	ldy sclf		; retrieve from line start if left it
   789  e158 a5cf               	lda lsxp		; input started row
   790  e15a 3013               	bmi lp80		; flag we left start line
   791  e15c c5ca               	cmp tblx
   792  e15e 900f               	bcc lp80
   793  e160 a4ce               	ldy lstp		; input started column
   794  e162 cd8403             	cmp lintmp		; on start line
   795  e165 d004               	bne lp70
   796  e167 c4d5               	cpy indx		; past start column
   797  e169 f002               	beq lp75		; ok if the same
   798  e16b b011               lp70:	bcs clp2		; yes - null input
   799  e16d 85ca               lp75:	sta tblx		; start from here on input
   800  e16f 84cb               lp80:	sty pntr
   801  e171 4c86e1             	jmp lop5		; input a line
   802                          ; -------------------------------------------------------------------------------------------------
   803                          ; E174 Read character from screen
   804  e174 98                 loop5:	tya
   805  e175 48                 	pha
   806  e176 8a                 	txa
   807  e177 48                 	pha
   808  e178 a5d0               	lda crsw		; passing chars to input
   809  e17a f0ac               	beq loop3		; no - buffer on screen
   810  e17c 1008               	bpl lop5		; not done - get next char
   811  e17e a900               clp2:	lda #0			; input done clear flag
   812  e180 85d0               	sta crsw
   813  e182 a90d               	lda #$D			; pass a return
   814  e184 d039               	bne clp7
   815  e186 20dfe0             lop5:	jsr stupt		; set pnt and user
   816  e189 203fe2             	jsr get1ch		; get a screen char
   817                          ; convert screencode to petscii
   818  e18c 85db               	sta data		; store screen code for bit#5,6,7 check temporary
   819  e18e 293f               	and #$3F		; clear bit#6,7 in A
   820  e190 06db               	asl data		; check: scrcode bit#7->C
   821  e192 24db               	bit data		; check: scrcode bit#6->N, #5->V (shiftet to left)
   822  e194 1002               	bpl lop54		; skip if scrcode #6=0 x0x -> 00x
   823  e196 0980               	ora #$80		; x1x -> 10x
   824  e198 9004               lop54:	bcc lop52		; skip if scrcode #7=0 (not reverse)
   825  e19a a6d2               	ldx qtsw
   826  e19c d004               	bne lop53		; skip if bit#7=1 & quote on: 10x -> 00x, 11x -> 10x
   827                          				; if quote off or bit#7=0:
   828  e19e 7002               lop52:	bvs lop53		; skip if scrcode #5=1: 001 -> 001, 011 -> 101
   829  e1a0 0940               	ora #$40		; 000 -> 010, 100 -> 110
   830  e1a2 20c8e1             lop53:	jsr qtswc
   831  e1a5 a4ca               	ldy tblx		; on input end line ?
   832  e1a7 cc8403             	cpy lintmp
   833  e1aa 900a               	bcc clp00		; no
   834  e1ac a4cb               	ldy pntr		; on input end column ?
   835  e1ae c4d5               	cpy indx
   836  e1b0 9004               	bcc clp00		; no
   837  e1b2 66d0               	ror crsw		; c=1 minus flags last char sent
   838  e1b4 3003               	bmi clp1		; always
   839                          
   840  e1b6 2021e5             clp00:	jsr nxtchr		; at next char
   841  e1b9 c9de               clp1:	cmp #$DE		; a pi ?
   842  e1bb d002               	bne clp7		; no
   843  e1bd a9ff               	lda #$FF		; translate
   844  e1bf 85db               clp7:	sta data
   845  e1c1 68                 	pla
   846  e1c2 aa                 	tax
   847  e1c3 68                 	pla
   848  e1c4 a8                 	tay
   849  e1c5 a5db               	lda data		; return petscii char in A
   850  e1c7 60                 	rts
   851                          ; -------------------------------------------------------------------------------------------------
   852                          ; *** Test for quote mode ***
   853                          ; E1C8 Switch quote mode depending on in A
   854  e1c8 c922               qtswc:	cmp #$22 ; "
   855  e1ca d008               	bne qtswl		; skip if no quote-char
   856  e1cc a5d2               	lda qtsw
   857  e1ce 4901               	eor #$1			; toggle quoteswitch
   858  e1d0 85d2               	sta qtsw
   859  e1d2 a922               	lda #$22 ; "		; restore quote in A
   860  e1d4 60                 qtswl:	rts
   861                          ; -------------------------------------------------------------------------------------------------
   862                          ; E1D5 *** Output chars ***
   863  e1d5 2c8303             nxt3:	bit rvs
   864  e1d8 1002               	bpl nvs
   865  e1da 0980               	ora #$80
   866  e1dc a6d3               nvs:	ldx insrt
   867  e1de f002               	beq nvsa
   868  e1e0 c6d3               	dec insrt
   869  e1e2 2c8603             nvsa:	bit insflg		; are we in auto insert mode?
   870  e1e5 1009               	bpl nvs1		; branch if not
   871  e1e7 48                 	pha			; save the char
   872  e1e8 2091e5             	jsr insert		; make room for this char
   873  e1eb a200               	ldx #0
   874  e1ed 86d3               	stx insrt		; make sure we turn off insert mode.
   875  e1ef 68                 	pla			; restore char
   876  e1f0 2009e2             nvs1:	jsr dsppcc		; display the character
   877  e1f3 20dbe5             	jsr movchr		; move to next char pos
   878                          ; -------------------------------------------------------------------------------------------------
   879                          ; E1F6 ********* exit from prt *********
   880  e1f6 a5db               loop2:	lda data		; copy last char
   881  e1f8 8d8503             	sta lstchr
   882  e1fb 68                 	pla
   883  e1fc a8                 	tay
   884  e1fd a5d3               	lda insrt
   885  e1ff f002               	beq lop2
   886  e201 46d2               	lsr qtsw		; clear quote switch if in insert mode
   887  e203 68                 lop2:	pla
   888  e204 aa                 	tax
   889  e205 68                 	pla
   890  e206 60                 	rts
   891                          ; -------------------------------------------------------------------------------------------------
   892                          ;********************************
   893                          ; Display a character
   894                          ;********************************
   895                          ; E207 Write blank ($20) at cusor position
   896  e207 a920               doblnk: lda #' '		; load blank
   897                          ; E209 Write char A with color or tcolor if color bit#7=1
   898  e209 a6ec               dsppcc: ldx color		; load char color
   899  e20b 1002               	bpl dspcol
   900                          ; E20D Write char A with tcolor
   901  e20d a6ea               dsptco: ldx tcolor
   902                          ; E20f Write char A with color X and set blink counter
   903  e20f a002               dspcol: ldy #$02
   904  e211 84e7               	sty blncnt		; blink cusor
   905                          ; E213 Write char A with color X
   906  e213 a4cb               dspp:   ldy pntr		; get char index
   907  e215 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
   908  e218 206fe6             	jsr jwrvrm		; write char to screen
   909  e21b 48                 	pha
   910  e21c 8a                 	txa			; move color to A
   911  e21d 2072e6             	jsr jwrcrm		; write color to color RAM
   912  e220 68                 	pla
   913  e221 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
   914                          ; -------------------------------------------------------------------------------------------------
   915                          ; E224 Subroutine to clear one line
   916                          ;   x = line number
   917                          ;   clrln :  blank entire line
   918                          ;   clrprt:  y = starting column position
   919  e224 a4de               clrln:	ldy sclf		; load left margin
   920  e226 20b6e4             	jsr clrbit		; make sure non-continued line
   921  e229 8a                 clrprt:	txa
   922  e22a 48                 	pha			; save X
   923  e22b a5cb               	lda pntr
   924  e22d 48                 	pha			; remember column
   925  e22e 88                 	dey
   926  e22f c8                 clr10:	iny
   927  e230 84cb               	sty pntr
   928  e232 2007e2             	jsr doblnk		; print a blank
   929  e235 c4df               	cpy scrt		; line completely blank?
   930  e237 d0f6               	bne clr10		; branch if not
   931                          
   932  e239 68                 	pla
   933  e23a 85cb               	sta pntr
   934  e23c 68                 	pla
   935  e23d aa                 	tax
   936  e23e 60                 	rts
   937                          ; -------------------------------------------------------------------------------------------------
   938                          ; E23F Grab a character from screen
   939  e23f a4cb               get1ch: ldy pntr		; get char/color index
   940                          ; E241 Get char from column Y
   941  e241 206ee2             getych: jsr pagscr		; switch to screen memory page (indirect segment)
   942  e244 b1c8               	lda (pnt),y		; get the character
   943  e246 48                 	pha
   944  e247 a900               	lda #$00
   945  e249 11e8               	ora (user),y		; get color (ORA = always systembank)
   946  e24b 85ea               	sta tcolor		; and store it to tcolor
   947  e24d 68                 	pla
   948  e24e 4c7ce2             	jmp pagres      	; restore ram page (indirect segment)
   949                          ; -------------------------------------------------------------------------------------------------
   950                          ; E251 Set text/graphic mode (C=1 graphic)
   951  e251 b004               ctext:	bcs grcrt		; skip if graphic mode
   952  e253 a002               txcrt:	ldy #$02		; set Bit#1 for text character set   
   953  e255 d002               	bne crtset
   954  e257 a000               grcrt:	ldy #$00		; clear Bit#1 for graphic char set
   955  e259 84cc               crtset: sty grmode		; store new mode
   956  e25b ad18d8             	lda vic+memptr		; load vic memory pointers register
   957  e25e 29fd               	and #$FD
   958  e260 05cc               	ora grmode		; clear bit #1 and set to desired mode (char-ROM base-adr bit#11)
   959  e262 a018               	ldy #memptr
   960  e264 4c12e6             	jmp wrtvic		; write VIC memory pointers reg
   961                          ; -------------------------------------------------------------------------------------------------
   962                          ;**************************************************
   963                          ;   Handle ram paging (indirect segment)
   964                          ;**************************************************
   965                          ; E267 Switch to segment with key buffer
   966  e267 48                 pagkey: pha
   967  e268 ad8203             	lda keyseg              ; for function key page (segment)
   968  e26b 4c71e2             	jmp pagsub
   969                          ; E26E Switch to segment with video screen
   970  e26e 48                 pagscr: pha
   971  e26f a5ef               	lda scrseg              ; for screen memory page (segment)
   972  e271 48                 pagsub: pha
   973  e272 a501               	lda i6509		; get current page (segment) number
   974  e274 8d8c03             	sta pagsav              ; - and save it
   975  e277 68                 	pla
   976  e278 8501               	sta i6509               ; switch to new indirect segment
   977  e27a 68                 	pla                     ; restore a-reg
   978  e27b 60                 	rts
   979                          ; -------------------------------------------------------------------------------------------------
   980                          ; E27C Restore indirect segment
   981  e27c 48                 pagres: pha			; save a-reg
   982  e27d ad8c03             	lda pagsav		; get saved ram page (segment) number
   983  e280 8501               	sta i6509               ; restore ram page number
   984  e282 68                 	pla			; restore a-reg
   985  e283 60                 	rts
   986                          ; -------------------------------------------------------------------------------------------------
   987                          ; E284 *** Print a char ***
   988  e284 48                 prt:	pha
   989  e285 c9ff               	cmp #$FF
   990  e287 d002               	bne prt10
   991  e289 a9de               	lda #$DE		; convert pi character
   992  e28b 85db               prt10:	sta data		; save char
   993  e28d 8a                 	txa			; save regs
   994  e28e 48                 	pha
   995  e28f 98                 	tya
   996  e290 48                 	pha
   997  e291 a900               	lda #0			; clear cr flag
   998  e293 85d0               	sta crsw
   999  e295 a4cb               	ldy pntr		; column we are in
  1000  e297 a5db               	lda data
  1001  e299 297f               	and #$7F
  1002  e29b c920               	cmp #$20		; test if control character (< $20)
  1003  e29d 9041               	bcc ntcn		; yes
  1004                          !ifndef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1005                          	ldx qtsw		; test if in quote mode...
  1006                          	beq njt1		; if not, skip
  1007                          	ldx unknwn		; ?
  1008                          	beq njt2
  1009                          	jsr junkwn1		; vector -> nofunc (rts)
  1010                          	lda data
  1011                          	jmp njt2
  1012                          njt1:	ldx insrt		; test if in insert mode
  1013                          	bne njt2		; if not, skip
  1014                          	bit unknwn		; ?
  1015                          	bpl njt2
  1016                          	jsr junkwn1		; vector -> nofunc (rts)
  1017                          	lda data
  1018                          	cmp #$22
  1019                          	beq njt10
  1020                          	jmp loop2
  1021                          }
  1022  e29f ae8503             njt2:	ldx lstchr		; was last char an esc
  1023  e2a2 e01b               	cpx #$1B
  1024  e2a4 d006               	bne njt10		; no
  1025  e2a6 20dee6             	jsr sequen		; yes - do esc sequence
  1026  e2a9 4cf6e1             	jmp loop2
  1027  e2ac 293f               njt10:	and #$3F		; no - make a screen char
  1028  e2ae 24db               njt20:	bit data
  1029  e2b0 1002               	bpl njt30		; skip ahead if normal set - 00 - 3f
  1030  e2b2 0940               	ora #$40		; convert a0 - bf to 60 - 7f & c0 - df to 40 - 5f
  1031  e2b4 20c8e1             njt30:	jsr qtswc		; test for quote
  1032  e2b7 4cd5e1             	jmp nxt3		; put on screen
  1033                          *= $E2E0
  1034                          ; E2E0 ********* Control keys *********
  1035  e2e0 c90d               ntcn:	cmp #$0D		; test if a return
  1036  e2e2 f029               	beq ntcn20		; no inverse if yes
  1037                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1038  e2e4 c914               	cmp #$14		; test if insert or delete
  1039  e2e6 f025               	beq ntcn20		; allow in insert or quote mode
  1040  e2e8 c91b               	cmp #$1b		; test if escape key
  1041  e2ea d011               	bne ntcn1
  1042  e2ec 24db               	bit data
  1043  e2ee 300d               	bmi ntcn1		; its a $9b
  1044  e2f0 a5d2               	lda qtsw		; test if in quote mode...
  1045  e2f2 05d3               	ora insrt		; ...or insert mode
  1046  e2f4 f017               	beq ntcn20		; if not, go execute remaining code
  1047  e2f6 2072e7             	jsr toqm		; else go turn off all modes
  1048  e2f9 85db               	sta data		; and forget about this character
  1049  e2fb f010               	beq ntcn20		; always
  1050  e2fd c903               ntcn1	cmp #$03		; test if a run/load or stop
  1051                          } else{
  1052                          	cmp #$1B		; test if escape key
  1053                          	bne ntcn1
  1054                          	bit data
  1055                          	bmi ntcn1		; its a $9b
  1056                          	lda qtsw		; test if in quote mode...
  1057                          	ora insrt		; ...or insert mode
  1058                          	beq ntcn20		; if not, go execute remaining code
  1059                          	jsr toqm		; else go turn off all modes
  1060                          	sta data		; and forget about this character
  1061                          	beq ntcn20		; always
  1062                          ntcn1:	cmp #$03		; test if a run/load or stop
  1063                          	beq ntcn20
  1064                          	cmp #$14		; test if insert or delete
  1065                          }
  1066  e2ff f00c               	beq ntcn20		; no inverse if yes
  1067  e301 a4d3               	ldy insrt		; test if in insert mode
  1068  e303 d004               	bne ntcn10		; go reverse - if yes
  1069  e305 a4d2               	ldy qtsw		; check for quote mode
  1070  e307 f004               	beq ntcn20		; do not reverse if not
  1071  e309 0980               ntcn10:	ora #$80		; make reverse
  1072  e30b d0a1               	bne njt20
  1073  e30d a5db               ntcn20:	lda data
  1074  e30f 0a                 	asl			; set carry if shifted ctrl
  1075  e310 aa                 	tax
  1076  e311 2017e3             	jsr ctdsp		; indirect jsr
  1077  e314 4cf6e1             	jmp loop2
  1078                          *= $E317
  1079                          ; E317 Control code dispatcher
  1080  e317 bd6dec             ctdsp:	lda ctable+1,x		; hi byte
  1081  e31a 48                 	pha
  1082  e31b bd6cec             	lda ctable,x		; low byte
  1083  e31e 48                 	pha
  1084  e31f a5db               	lda data
  1085  e321 60                 	rts			; indirect jmp
  1086                          ; -------------------------------------------------------------------------------------------------
  1087                          ; E322 User control code jump vector
  1088  e322 6c2203             cuser:	jmp (ctlvec)
  1089                          ; -------------------------------------------------------------------------------------------------
  1090                          ; E325 Cursor down/up
  1091  e325 b00d               cdnup:  bcs cup			; cursor up
  1092                          ; cursor down
  1093  e327 208be3             cdwn:	jsr nxln
  1094  e32a 20a6e4             cdn10:	jsr getbit		; a wrapped line ?
  1095  e32d b003               	bcs cdrts		; skip if yes
  1096  e32f 38                 	sec			; flag we left line
  1097  e330 66cf               	ror lsxp
  1098                          
  1099  e332 18                 cdrts:  clc
  1100  e333 60                 	rts
  1101                          ; E334 Cursor up
  1102  e334 a6dc               cup:	ldx sctop		; cursor up
  1103  e336 e4ca               	cpx tblx		; at top of window ?
  1104  e338 b00f               	bcs critgo		; yes - do nothing
  1105  e33a 202ae3             cup10:	jsr cdn10		; about to wrap to a new line ?
  1106  e33d c6ca               	dec tblx		; up a line
  1107  e33f 4cdfe0             	jmp stupt
  1108                          ; -------------------------------------------------------------------------------------------------
  1109                          ; E342 Cursor right/left
  1110  e342 b006               crtlf:  bcs cleft		; cursor left
  1111                          ; cursor right
  1112  e344 2021e5             crit:	jsr nxtchr		; cursor right
  1113  e347 b0e1               	bcs cdn10		; yes - test for wrap
  1114                          
  1115  e349 60                 critgo: rts
  1116                          ; E34A Cursor left
  1117  e34a 2034e5             cleft:  jsr bakchr		; move back
  1118  e34d b0fa               	bcs critgo		; abort if at top left
  1119  e34f d0e1               	bne cdrts		; no - exit
  1120  e351 e6ca               	inc tblx
  1121  e353 d0e5               	bne cup10		; go set flag if needed
  1122                          ; -------------------------------------------------------------------------------------------------
  1123                          ; E355 RVS on/off
  1124  e355 4980               rvsf:   eor #$80
  1125  e357 8d8303             	sta rvs
  1126  e35a 60                 	rts
  1127                          ; -------------------------------------------------------------------------------------------------
  1128                          ; E35B Home/clear
  1129  e35b 9003               homclr:	bcc homes		; if C=0 home
  1130  e35d 4cc5e0             	jmp clsr		; Clear screen, cursor home
  1131                          ; E360 Cursor home
  1132  e360 cd8503             homes:	cmp lstchr		; last char a home ?
  1133  e363 d003               	bne hm110		; no
  1134  e365 2093ea             	jsr sreset		; top=0,left=0,bot=nrows-1,rt=cols-1
  1135  e368 4cd3e0             hm110:  jmp nxtd		; set to top left
  1136                          ; -------------------------------------------------------------------------------------------------
  1137                          ; E36B Tab function
  1138  e36b a4cb               tabit:  ldy pntr
  1139  e36d b012               	bcs tabtog		; a tab toggle
  1140  e36f c4df               tab1:	cpy scrt		; at right of window
  1141  e371 9005               	bcc tab2		; no - tab to next
  1142  e373 a5df               	lda scrt		; set to screen right
  1143  e375 85cb               	sta pntr
  1144  e377 60                 	rts
  1145                          
  1146  e378 c8                 tab2:   iny			; find next tab stop
  1147  e379 2026ea             	jsr gettab
  1148  e37c f0f1               	beq tab1		; not yet !
  1149  e37e 84cb               	sty pntr
  1150  e380 60                 	rts
  1151                          ; E381 Toggle tabulator
  1152  e381 2026ea             tabtog: jsr gettab		; flip tab stop
  1153  e384 4d8803             	eor bitmsk
  1154  e387 9da103             	sta tab,x
  1155  e38a 60                 	rts
  1156                          ; -------------------------------------------------------------------------------------------------
  1157                          ; E38B Skip to next line
  1158                          ;   wrap to top if scroll disabled
  1159  e38b a6ca               nxln:	ldx tblx
  1160  e38d e4dd               	cpx scbot		; of the bottom of window ?
  1161  e38f 900f               	bcc nxln1		; no
  1162  e391 2c8703             	bit scrdis		; what if scrolling is disabled?
  1163  e394 1006               	bpl doscrl		; branch if scroll is enabled
  1164  e396 a5dc               	lda sctop		; wrap to top
  1165  e398 85ca               	sta tblx
  1166  e39a b006               	bcs nowhop		; always
  1167                          
  1168  e39c 2008e4             doscrl:	jsr scrup		; scroll it all
  1169  e39f 18                 	clc			; indicate scroll ok
  1170  e3a0 e6ca               nxln1:	inc tblx
  1171  e3a2 4cdfe0             nowhop:	jmp stupt		; set line base adr
  1172                          ; -------------------------------------------------------------------------------------------------
  1173                          ; E3A5 A return or shift return
  1174  e3a5 20f7e4             nxt1:   jsr fndend		; find the end of the current line
  1175  e3a8 e8                 	inx
  1176  e3a9 20b6e4             	jsr clrbit		; set next line as non-continued
  1177  e3ac a4de               	ldy sclf		; else point to start of next line
  1178  e3ae 84cb               	sty pntr
  1179  e3b0 208be3             	jsr nxln		; set up next line
  1180  e3b3 4c72e7             	jmp toqm		; turn off all modes
  1181                          ; -------------------------------------------------------------------------------------------------
  1182                          ; ****** scroll routines ******
  1183                          ; E3B6 Move one line
  1184  e3b6 bd3aec             movlin:	lda ldtb2,x		; set pointers to line address lo
  1185  e3b9 85c6               	sta sedeal
  1186  e3bb 85c4               	sta sedsal
  1187  e3bd bd53ec             	lda ldtb1,x
  1188  e3c0 85c5               	sta sedsal+1		; set pointer hi to vram
  1189  e3c2 2903               	and #$03
  1190  e3c4 09d4               	ora #>clrram		; calc colorram hi and set second pointer
  1191  e3c6 85c7               	sta sedeal+1
  1192                          
  1193  e3c8 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
  1194  e3cb b1c4               movl10: lda (sedsal),y
  1195  e3cd 206fe6             	jsr jwrvrm		; copy vram
  1196  e3d0 a900               	lda #$00
  1197  e3d2 11c6               	ora (sedeal),y		; read from color ram (ora() always from kernal bank)
  1198  e3d4 2072e6             	jsr jwrcrm		; write color ram
  1199  e3d7 c4df               	cpy scrt		; done a whole line ?
  1200  e3d9 c8                 	iny
  1201  e3da 90ef               	bcc movl10		; no
  1202                          
  1203  e3dc 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
  1204                          ; -------------------------------------------------------------------------------------------------
  1205                          ; E3DF ****** Scroll down ******
  1206  e3df a6cf               scrdwn: ldx lsxp
  1207  e3e1 3006               	bmi scd30		; skip if new line flag already set
  1208  e3e3 e4ca               	cpx tblx
  1209  e3e5 9002               	bcc scd30		; skip if old line is below scroll area
  1210  e3e7 e6cf               	inc lsxp		; else inc start line number
  1211  e3e9 a6dd               scd30:  ldx scbot		; scroll down, start bottom
  1212                          
  1213  e3eb 20e1e0             scd10:  jsr scrset		; set pnt to line
  1214  e3ee a4de               	ldy sclf
  1215  e3f0 e4ca               	cpx tblx		; test if at destination line
  1216  e3f2 f00e               	beq scd20		; done if yes
  1217  e3f4 ca                 	dex			; point to previous line as source
  1218  e3f5 20a8e4             	jsr getbt1
  1219  e3f8 e8                 	inx
  1220  e3f9 20b4e4             	jsr putbt1		; move continuation byte
  1221  e3fc ca                 	dex
  1222  e3fd 20b6e3             	jsr movlin		; move one line
  1223  e400 b0e9               	bcs scd10		; always
  1224                          
  1225  e402 2024e2             scd20:	jsr clrln		; set line to blanks
  1226  e405 4cc3e4             	jmp setbit		; mark as continuation line
  1227                          ; -------------------------------------------------------------------------------------------------
  1228                          ; E408 ****** Scroll up ******
  1229  e408 a6dc               scrup:  ldx sctop
  1230  e40a e8                 scru00: inx
  1231  e40b 20a8e4             	jsr getbt1		; find first non-continued line
  1232  e40e 900a               	bcc scru15
  1233  e410 e4dd               	cpx scbot		; is entire screen 1 line?
  1234  e412 90f6               	bcc scru00		; do normal scroll if not
  1235                          
  1236  e414 a6dc               	ldx sctop
  1237  e416 e8                 	inx
  1238  e417 20b6e4             	jsr clrbit		; clear to only scroll 1 line
  1239                          
  1240  e41a c6ca               scru15:	dec tblx
  1241  e41c 24cf               	bit lsxp
  1242  e41e 3002               	bmi scru20		; no change if already new line
  1243  e420 c6cf               	dec lsxp		; move input up one
  1244  e422 a6dc               scru20:	ldx sctop
  1245  e424 e4da               	cpx sedt2
  1246  e426 b002               	bcs scru30
  1247  e428 c6da               	dec sedt2		; in case doing insert
  1248  e42a 203fe4             scru30:	jsr scr10		; scroll
  1249  e42d a6dc               	ldx sctop
  1250  e42f 20a8e4             	jsr getbt1
  1251  e432 08                 	php
  1252  e433 20b6e4             	jsr clrbit		; make sure top line is not continuation
  1253  e436 28                 	plp
  1254  e437 9005               	bcc scru10		; done if top line off
  1255  e439 2c8a03             	bit logscr		; logical scroll ?
  1256  e43c 30ca               	bmi scrup		; yes - keep scrolling  ********** b128 v4: -> scru15
  1257  e43e 60                 scru10: rts
  1258                          ; E43F
  1259  e43f 20e1e0             scr10:	jsr scrset		; point to start of line
  1260  e442 a4de               	ldy sclf
  1261  e444 e4dd               	cpx scbot		; at last line ?
  1262  e446 b00e               	bcs scr40		; yes
  1263  e448 e8                 	inx			; point to next line
  1264  e449 20a8e4             	jsr getbt1
  1265  e44c ca                 	dex
  1266  e44d 20b4e4             	jsr putbt1		; move continuation byte
  1267  e450 e8                 	inx
  1268  e451 20b6e3             	jsr movlin		; move one line
  1269  e454 b0e9               	bcs scr10
  1270                          ; E456 Test for slow scroll
  1271  e456 2024e2             scr40:  jsr clrln		; make last line blank
  1272  e459 a2ff               	ldx #$FF
  1273  e45b a0fe               	ldy #$FE		; allow only output line 0
  1274  e45d 2098e4             	jsr getlin		; get input
  1275  e460 2920               	and #$20		; check if interrupt i5 = control
  1276  e462 d013               	bne scr80		; if not skip ahead - not slow scroll
  1277                          ; E464 Slow scroll delay loop
  1278                          scr60:
  1279                          !ifndef CBMPATCH{		; ********** PATCH nop's are for 2MHz B-series, P is slow enough ;)
  1280                          				;            get an extra byte for the cbmii patch below!
  1281                          	nop			; yes - waste time
  1282                          	nop
  1283                          }
  1284  e464 ca                 	dex
  1285  e465 d0fd               	bne scr60
  1286  e467 88                 	dey
  1287  e468 d0fa               	bne scr60
  1288                          
  1289  e46a 84d1               scr70:  sty ndx
  1290  e46c a27f               scr75:  ldx #$7F
  1291  e46e 8e00df             	stx tpi2+pa
  1292  e471 a2ff               	ldx #$FF
  1293  e473 8e01df             	stx tpi2+pb
  1294  e476 60                 	rts
  1295                          ; E479 Scroll stop
  1296  e477 a2f7               scr80:  ldx #$F7		; allow only output line 11
  1297  e479 a0ff               	ldy #$FF
  1298  e47b 2098e4             	jsr getlin		; get input lines key
  1299  e47e 2910               	and #$10		; check for the commodore key
  1300  e480 d0ea               	bne scr75		; exit if not - no stop scroll
  1301                          
  1302  e482 2098e4             scr90:	jsr getlin		; get input lines
  1303  e485 2910               	and #$10		; check for the commodore key
  1304  e487 f0f9               	beq scr90		; wait until com.key not depressed
  1305                          
  1306  e489 a000               scr95:	ldy #0
  1307  e48b a200               	ldx #0			; allow all output lines
  1308  e48d 2098e4             	jsr getlin		; get inputs
  1309  e490 293f               	and #$3F		; check for any input
  1310  e492 493f               	eor #$3F
  1311  e494 f0f3               	beq scr95		; wait
  1312  e496 d0d2               	bne scr70		; always
  1313                          ; E49A Keyboard check for slow scroll
  1314                          getlin: 
  1315                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1316  e498 08                  	php			; preserve the irq flag
  1317                          }
  1318  e499 78                 	sei
  1319  e49a 8e00df             	stx tpi2+pa		; set port-a output
  1320  e49d 8c01df             	sty tpi2+pb		; set port-b outputs
  1321  e4a0 20eae9             	jsr getkey		; get port-c inputs
  1322                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1323  e4a3 28                 	plp
  1324                          } else{
  1325                          	cli
  1326                          }
  1327  e4a4 60                 	rts
  1328                          *= $E4A6
  1329                          ; -------------------------------------------------------------------------------------------------
  1330                          ; ****** wrap table subroutines *******
  1331                          ; E4A6 Check for a double length line
  1332  e4a6 a6ca               getbit: ldx tblx		; load current line
  1333                          ; E4a8 Check line X for double length
  1334  e4a8 20cfe4             getbt1: jsr bitpos		; get byte & bit positions
  1335  e4ab 35e2               	and bitabl,x		; check if bit for line is set in table
  1336  e4ad c901               	cmp #1			; make carry clear if zero
  1337  e4af 4cbfe4             	jmp bitout		; return 0 if not a double length line
  1338                          ; -------------------------------------------------------------------------------------------------
  1339                          ; E4B2 Mark current line as double length C=1, unmark C=0
  1340                          ; putbit - set bit according to carry
  1341  e4b2 a6ca               putbit: ldx tblx		; load current line
  1342                          ; Mark line X
  1343  e4b4 b00d               putbt1: bcs setbit		; go if to mark as wrappped line
  1344                          ; clrbit - clear wrap bit
  1345  e4b6 20cfe4             clrbit: jsr bitpos		; get byte & bit positions
  1346  e4b9 49ff               	eor #$FF		; invert bit position
  1347  e4bb 35e2               	and bitabl,x		; clear bit
  1348  e4bd 95e2               bitsav: sta bitabl,x		; and store it to table at byte position X
  1349  e4bf ae8803             bitout: ldx bitmsk		; move byte table position to X
  1350  e4c2 60                 	rts
  1351                          ; setbit  -  set bit to mark as wrapped line
  1352  e4c3 2c8703             setbit: bit scrdis		; auto line link disable...
  1353  e4c6 70e0               	bvs getbt1		; branch if scrolling is disabled
  1354  e4c8 20cfe4             	jsr bitpos		; get byte & bit position
  1355  e4cb 15e2               	ora bitabl,x		; set wrap bit
  1356  e4cd d0ee               	bne bitsav		; always
  1357                          ; Find bit table position for line X
  1358  e4cf 8e8803             bitpos: stx bitmsk		; remember line
  1359  e4d2 8a                 	txa
  1360  e4d3 2907               	and #$07		; get bit position
  1361  e4d5 aa                 	tax
  1362  e4d6 bdefec             	lda bits,x		; get bit mask
  1363  e4d9 48                 	pha			; remember it
  1364  e4da ad8803             	lda bitmsk
  1365  e4dd 4a                 	lsr
  1366  e4de 4a                 	lsr			; shift to get byte position (/8)
  1367  e4df 4a                 	lsr
  1368  e4e0 aa                 	tax			; move byte pos to X
  1369  e4e1 68                 	pla			; return bit value in A
  1370  e4e2 60                 	rts
  1371                          ; -------------------------------------------------------------------------------------------------
  1372                          ; E4E2 ****** Move to start of line
  1373                          ; Find line start/end
  1374  e4e3 9012               	bcc fndend		; if C=0 find line end - NOT USED
  1375                          ; E4E5 cursor to line start (esc-j)
  1376  e4e5 a4de               fndfst:	ldy sclf
  1377  e4e7 84cb               	sty pntr		; set to leftmost column
  1378  e4e9 20a6e4             fistrt:	jsr getbit		; find start of current line
  1379  e4ec 9006               	bcc fnd0		; branch if found
  1380  e4ee c6ca               	dec tblx		; up a line
  1381  e4f0 10f7               	bpl fistrt		; always
  1382  e4f2 e6ca               	inc tblx		; whoops went too far
  1383  e4f4 4cdfe0             fnd0:	jmp stupt		; set line base adr
  1384                          ; -------------------------------------------------------------------------------------------------
  1385                          ; E4F7 ****** Find last non-blank char of line
  1386                          ;   pntr= column #
  1387                          ;   tblx= line #
  1388                          ; cursor to end of line (esc-k)
  1389  e4f7 e6ca               fndend:	inc tblx
  1390  e4f9 20a6e4             	jsr getbit		; is this line continued
  1391  e4fc b0f9               	bcs fndend		; branch if so
  1392  e4fe c6ca               	dec tblx		; found it - compensate for inc tblx
  1393  e500 20dfe0             	jsr stupt		; reset screen pointer to line start
  1394  e503 a4df               	ldy scrt		; get right margin
  1395  e505 84cb               	sty pntr		; point to right margin
  1396  e507 1005               	bpl eloup2		; always
  1397  e509 2034e5             eloup1:	jsr bakchr		; backup one char
  1398  e50c b010               	bcs endbye		; if at top left get out
  1399  e50e 203fe2             eloup2: jsr get1ch		; get char from screen
  1400  e511 c920               	cmp #$20
  1401  e513 d009               	bne endbye		; yes, space
  1402  e515 c4de               	cpy sclf		; are we at the left margin?
  1403  e517 d0f0               	bne eloup1		; branch if not
  1404  e519 20a6e4             	jsr getbit		; if we're on a wraped line
  1405  e51c b0eb               	bcs eloup1		; always scan the above line
  1406                          
  1407  e51e 84d5               endbye: sty indx		; remember this
  1408  e520 60                 	rts
  1409                          ; -------------------------------------------------------------------------------------------------
  1410                          ; E521 ****** Move to next char
  1411                          ; scroll if enabled
  1412                          ; wrap to top if disabled
  1413  e521 48                 nxtchr:	pha
  1414  e522 a4cb               	ldy pntr
  1415  e524 c4df               	cpy scrt		; are we at the right margin?
  1416  e526 9007               	bcc bumpnt		; branch if not
  1417                          
  1418  e528 208be3             	jsr nxln		; point to nextline
  1419  e52b a4de               	ldy sclf		; point to first char of 1st line
  1420  e52d 88                 	dey
  1421  e52e 38                 	sec			; set to show moved to new line
  1422  e52f c8                 bumpnt:	iny			; increment char index
  1423  e530 84cb               	sty pntr
  1424  e532 68                 	pla
  1425  e533 60                 	rts
  1426                          ; -------------------------------------------------------------------------------------------------
  1427                          ; E534 Backup one char - Move one char left
  1428                          ; wrap up and stop a top left
  1429  e534 a4cb               bakchr:	ldy pntr
  1430  e536 88                 	dey
  1431  e537 3004               	bmi bakot1
  1432  e539 c4de               	cpy sclf		; are we at the left margin
  1433  e53b b00f               	bcs bakout		; no - past it
  1434  e53d a4dc               bakot1:	ldy sctop
  1435  e53f c4ca               	cpy tblx		; are we at top line last character?
  1436  e541 b00e               	bcs bakot2		; leave with carry set
  1437  e543 c6ca               	dec tblx		; else backup a line
  1438  e545 48                 	pha
  1439  e546 20dfe0             	jsr stupt		; set line base adr
  1440  e549 68                 	pla
  1441  e54a a4df               	ldy scrt		; move cursor to right side
  1442  e54c 84cb               bakout: sty pntr
  1443  e54e c4df               	cpy scrt		; set z-flag if moved to new line
  1444  e550 18                 	clc			; always clear
  1445  e551 60                 bakot2: rts
  1446                          ; -------------------------------------------------------------------------------------------------
  1447                          ; E552 savpos - Save row & column position
  1448  e552 a4cb               savpos: ldy pntr
  1449  e554 84d9               	sty sedt1
  1450  e556 a6ca               	ldx tblx
  1451  e558 86da               	stx sedt2
  1452  e55a 60                 	rts
  1453                          ; -------------------------------------------------------------------------------------------------
  1454                          ; E55B Delete or insert a character
  1455  e55b b034               delins: bcs insert		; C=1 is insert
  1456                          ; delete a character
  1457  e55d 204ae3             deleet: jsr cleft		; move back 1 position
  1458  e560 2052e5             	jsr savpos		; save column & row positions
  1459  e563 b00f               	bcs delout		; abort if at top left corner
  1460                          
  1461  e565 c4df               deloop: cpy scrt		; at right margin?
  1462  e567 9016               	bcc delop1		; no - skip ahaed
  1463  e569 a6ca               	ldx tblx
  1464  e56b e8                 	inx
  1465  e56c 20a8e4             	jsr getbt1		; is next line a wrapped line?
  1466  e56f b00e               	bcs delop1		; yes - continue with delete
  1467  e571 2007e2             	jsr doblnk		; no - blank last character
  1468                          
  1469  e574 a5d9               delout: lda sedt1		; restore column and row positions
  1470  e576 85cb               	sta pntr
  1471  e578 a5da               	lda sedt2
  1472  e57a 85ca               	sta tblx
  1473  e57c 4cdfe0             	jmp stupt		; restore pnt and exit
  1474                          ; E57F
  1475  e57f 2021e5             delop1: jsr nxtchr
  1476  e582 203fe2             	jsr get1ch		; get next character
  1477  e585 2034e5             	jsr bakchr
  1478  e588 200de2             	jsr dsptco		; move it back 1 position
  1479  e58b 2021e5             	jsr nxtchr		; move up 1 position
  1480  e58e 4c65e5             	jmp deloop		; loop until at end of line
  1481                          ; E591 Insert a character 
  1482  e591 2052e5             insert: jsr savpos		; save column & row positions
  1483  e594 20f7e4             	jsr fndend		; move to last char on the line
  1484  e597 e4da               	cpx sedt2		; last row equal to starting row?
  1485  e599 d002               	bne ins10		; no - skip ahead
  1486  e59b c4d9               	cpy sedt1		; is last position before starting position?
  1487  e59d 9021               ins10:	bcc ins50		; yes - no need to move anything
  1488  e59f 20dbe5             	jsr movchr		; move to next char position
  1489  e5a2 b022               	bcs insout		; abort if scroll needed but disabled
  1490                          
  1491  e5a4 2034e5             ins30:	jsr bakchr
  1492  e5a7 203fe2             	jsr get1ch		; move char forward 1 position
  1493  e5aa 2021e5             	jsr nxtchr
  1494  e5ad 200de2             	jsr dsptco
  1495  e5b0 2034e5             	jsr bakchr
  1496  e5b3 a6ca               	ldx tblx
  1497  e5b5 e4da               	cpx sedt2		; at original position
  1498  e5b7 d0eb               	bne ins30
  1499  e5b9 c4d9               	cpy sedt1
  1500  e5bb d0e7               	bne ins30		; no - loop till we are
  1501                          
  1502  e5bd 2007e2             	jsr doblnk		; insert a blank
  1503  e5c0 e6d3               ins50:	inc insrt		; inc insert count
  1504  e5c2 d002               	bne insout		; only allow up to 255
  1505  e5c4 c6d3               	dec insrt
  1506  e5c6 4c74e5             insout:	jmp delout		; restore original position
  1507                          ; -------------------------------------------------------------------------------------------------
  1508                          ; E5C9 Stop/run
  1509  e5c9 900f               stprun: bcc runrts		; exit if a stop code
  1510  e5cb 78                 	sei			; disable interrupts
  1511  e5cc a209               	ldx #9
  1512  e5ce 86d1               	stx ndx			; set keyboard queue size
  1513  e5d0 bd30ec             runlop:	lda runtb-1,x
  1514  e5d3 9daa03             	sta keyd-1,x		; load run character sequence into kybd queue
  1515  e5d6 ca                 	dex
  1516  e5d7 d0f7               	bne runlop
  1517                          
  1518  e5d9 58                 	cli			; enable interrupts
  1519  e5da 60                 runrts: rts
  1520                          ; -------------------------------------------------------------------------------------------------
  1521                          ; E5DB movchr  -  Move to next char position
  1522                          ; insert blank line if at end of line
  1523                          ;   y = column position
  1524                          ;   on exit - carry set = abort - scroll disabled
  1525  e5db c4df               movchr: cpy scrt
  1526  e5dd 900b               	bcc movc10		; easy if not at end of line
  1527  e5df a6ca               	ldx tblx
  1528  e5e1 e4dd               	cpx scbot
  1529  e5e3 9005               	bcc movc10		; skip if not last line of screen
  1530  e5e5 2c8703             	bit scrdis
  1531  e5e8 3017               	bmi movc30		; abort if scrolling disabled
  1532                          
  1533  e5ea 20dfe0             movc10:	jsr stupt		; set pnt address
  1534  e5ed 2021e5             	jsr nxtchr		; move to next char position
  1535  e5f0 900f               	bcc movc30		; done if not move to new line
  1536  e5f2 20a6e4             	jsr getbit		; check if on a continued line
  1537  e5f5 b009               	bcs movc20		; skip ahead if not
  1538                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1539  e5f7 2023ed             	jsr patch1		; patch in a check for single line screen
  1540  e5fa 38                 	sec			; prep for abort...
  1541                          } else{
  1542                          	sec			; prep for abort...
  1543                          	bit scrdis
  1544                          }
  1545  e5fb 7004               	bvs movc30
  1546  e5fd 20dfe3             	jsr scrdwn		; else insert a blank line
  1547                          
  1548  e600 18                 movc20:	clc			; for clean exit
  1549  e601 60                 movc30: rts
  1550                          ; -------------------------------------------------------------------------------------------------
  1551                          ; E602 Change color
  1552  e602 a010               chkcol:	ldy #16			; there's 16 colors
  1553  e604 88                 chk1a:	dey
  1554  e605 3008               	bmi chk1b
  1555  e607 d912ed             	cmp coltab,y
  1556  e60a d0f8               	bne chk1a
  1557  e60c 84ec               	sty color		; change the color
  1558  e60e 60                 	rts
  1559                          
  1560  e60f 4c22e3             chk1b:	jmp cuser
  1561                          ; -------------------------------------------------------------------------------------------------
  1562                          ; E612 Write a byte to the VIC chip
  1563                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1564                          wrtvic: sta saver		; remember value
  1565                          wrtvrpt:lda saver
  1566                          	sta vic,y		; store value to VIC register
  1567                          	eor vic,y		; check stored value
  1568                          	beq wrtvok		; jump to end if success
  1569                          	cpy #$20
  1570                          	bcs wrtvg20		; jump if reg >= $20
  1571                          	cpy #$11
  1572                          	bcc wrtvrpt		; write again if register < $10 is different
  1573                          	and wrtvtbl - $11,y	; clear unused bits with register mask table 
  1574                          	bne wrtvrpt		; write register again if different
  1575                          wrtvg20:and #$0F		; clear upper nibble because only bit#0-3 used
  1576                          	bne wrtvrpt		; write register again if different
  1577                          wrtvok: lda saver
  1578                          	rts
  1579                          wrtvtbl:!byte $7F,$00,$00,$00,$FF,$3F,$FF,$FE
  1580                          	!byte $00,$0F,$FF,$FF,$FF,$FF,$FF
  1581                          } else{				; ********** Fast video PATCH **********
  1582  e612 9900d8             wrtvic: sta vic,y
  1583  e615 60                 	rts
  1584                          }
  1585                          *= $E641
  1586                          ; -------------------------------------------------------------------------------------------------
  1587                          ; E641 Write char A to screen at current line, column Y
  1588                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1589                          wrvram:	sta saver		; remember value
  1590                          wrtrrpt:lda saver
  1591                          	sta (pnt),y		; store to screen RAM
  1592                          	lda (pnt),y		; load from screen
  1593                          	eor saver		; check if same
  1594                          	bne wrtrrpt		; repeat store if not equal
  1595                          
  1596                          	lda saver
  1597                          	rts
  1598                          } else{                         ; ********** Fast video PATCH **********
  1599  e641 91c8               wrvram:	sta (pnt),y		; store byte to screen line pointer + coulmn X
  1600  e643 60                 	rts
  1601                          }
  1602                          *= $E650
  1603                          ; -------------------------------------------------------------------------------------------------
  1604                          ; E650 Write color to color RAM at current line, column Y
  1605                          !ifdef STANDARD_VIDEO{          ; ********** Standard video **********
  1606                          wrcram:	sta saver		; remember value
  1607                          	lda i6509
  1608                          	pha			; remember indirect bank
  1609                          	lda #irom
  1610                          	sta i6509		; switch to system bank
  1611                          wrtcrpt:lda saver
  1612                          	sta (user),y		; store to color RAM
  1613                          	eor (user),y		; check if same
  1614                          	and #$0F		; load and isolate low nibble
  1615                          	bne wrtcrpt		; repeat if not equal
  1616                          
  1617                          	pla
  1618                          	sta i6509		; restore ibank
  1619                          	lda saver
  1620                          	rts
  1621                          } else{
  1622                          !ifdef BANK15_VIDEO{            ; ********** Video bank15 PATCH **********
  1623  e650 91e8               wrcram:	sta (user),y		; store to color RAM
  1624  e652 60                 	rts
  1625                          	} else{                 ; ********** Fast video PATCH **********
  1626                          wrcram:	sta saver		; remember value
  1627                          	lda i6509
  1628                          	pha			; remember indirect bank
  1629                          	lda #irom
  1630                          	sta i6509		; switch to system bank
  1631                          	lda saver
  1632                          	sta (user),y		; store to color RAM
  1633                          	pla
  1634                          	sta i6509		; restore ibank
  1635                          	lda saver
  1636                          	rts
  1637                          }
  1638                          }
  1639                          *= $E669
  1640                          ; -------------------------------------------------------------------------------------------------
  1641                          ; E669 Vector unused
  1642  e669 6cbb03             junkwn1:jmp (iunkwn1)		; vector -> nofunc (rts)
  1643                          ; -------------------------------------------------------------------------------------------------
  1644                          ; E66C Vector unused
  1645  e66c 6cbd03             junkwn2:jmp (iunkwn2)		; vector -> nofunc (rts)
  1646                          ; -------------------------------------------------------------------------------------------------
  1647                          ; E66F Jump vector: Write char to screen
  1648  e66f 6cb703             jwrvrm:	jmp (iwrtvrm)		; -> $03B7 -> $E641
  1649                          ; -------------------------------------------------------------------------------------------------
  1650                          ; E672 Jump vector: Write color to color RAM
  1651  e672 6cb903             jwrcrm:	jmp (iwrtcrm)		; -> $03B9 -> $E650
  1652                          ; -------------------------------------------------------------------------------------------------
  1653                          ; E675 Ring the bell, if enabled
  1654  e675 ad8b03             bell:   lda bellmd
  1655  e678 d028               	bne bellgo
  1656  e67a a90f               	lda #$0F
  1657  e67c 8d18da             	sta sid+volume		; turn up volume
  1658  e67f a900               	lda #$00
  1659  e681 8d05da             	sta sid+osc1+atkdcy	; attack=0, decay=0
  1660  e684 a9f8               	lda #$F8
  1661  e686 8d06da             	sta sid+osc1+susrel	; sustain=15, release=8
  1662  e689 a940               	lda #$40
  1663  e68b 8d01da             	sta sid+osc1+freqhi	; voice 1 freq.
  1664  e68e a980               	lda #$80
  1665  e690 8d0fda             	sta sid+osc3+freqhi	; voice 3 freq.
  1666  e693 a215               	ldx #$15
  1667  e695 8e04da             	stx sid+osc1+oscctl	; voice 1 gate on, triangle, ring mod. 
  1668  e698 a000               	ldy #$00
  1669  e69a c8                 bell10:	iny
  1670  e69b ea                 	nop			; wait to reach sustain level
  1671  e69c d0fc               	bne bell10
  1672                          
  1673  e69e ca                 	dex
  1674  e69f 8e04da             	stx sid+osc1+oscctl	; gate off
  1675  e6a2 60                 bellgo: rts
  1676                          ; -------------------------------------------------------------------------------------------------
  1677                          ; E6A3 ce - Clear entry
  1678                          ;   always deletes last character entered
  1679                          ;   will delete all <#>s. (0 1 2 3 4 5 6 7 8 9 .)
  1680                          ;   will delete if (<#>e<+/->)
  1681                          ;   cursor must be next posistion beyond entry being deleted.
  1682  e6a3 a5cb               ce:	lda pntr		; get index on line
  1683  e6a5 48                 	pha			; save for final delete if necessary
  1684  e6a6 a4cb               cet0:	ldy pntr
  1685  e6a8 88                 	dey
  1686  e6a9 2041e2             	jsr getych		; get previous character
  1687  e6ac c92b               	cmp #'+'		; (+)
  1688  e6ae f004               	beq cet1
  1689  e6b0 c92d               	cmp #'-'		; (-)
  1690  e6b2 d008               	bne cet2
  1691                          
  1692  e6b4 88                 cet1:	dey			; try for an <#>e
  1693  e6b5 2041e2             	jsr getych
  1694  e6b8 c905               	cmp #5			; (e)
  1695  e6ba d01a               	bne cet4		; exit if not...it can only be an <#>e
  1696                          
  1697  e6bc c905               cet2:	cmp #5			; (e)
  1698  e6be d004               	bne cet3
  1699  e6c0 88                 	dey
  1700  e6c1 2041e2             	jsr getych
  1701                          
  1702  e6c4 c92e               cet3:	cmp #'.'		; try for a <#>
  1703  e6c6 900e               	bcc cet4		; (.)
  1704  e6c8 c92f               	cmp #'0'-1
  1705  e6ca f00a               	beq cet4
  1706  e6cc c93a               	cmp #'9'+1		; (0-9)
  1707  e6ce b006               	bcs cet4
  1708                          
  1709  e6d0 205de5             	jsr deleet
  1710  e6d3 4ca6e6             	jmp cet0
  1711                          
  1712  e6d6 68                 cet4:	pla			; check if any deletes occured
  1713  e6d7 c5cb               	cmp pntr
  1714  e6d9 d0c7               	bne bellgo		; yes...exit
  1715  e6db 4c5de5             	jmp deleet		; else... go delete a character
  1716                          ; -------------------------------------------------------------------------------------------------
  1717                          ; E6DE Escape sequence vector
  1718  e6de 6c2003             sequen:	jmp (escvec)		; escape indirect
  1719                          ; -------------------------------------------------------------------------------------------------
  1720                          ;******************************
  1721                          ; E6E1 Insert line (esc-i)
  1722                          ;*****************************
  1723  e6e1 20dfe3             iline:	jsr scrdwn		; insert a blank line
  1724  e6e4 20d9e0             	jsr stu10		; move to start of line
  1725  e6e7 e8                 	inx
  1726  e6e8 20a8e4             	jsr getbt1
  1727  e6eb 08                 	php
  1728  e6ec 20b2e4             	jsr putbit		; set continuation same as in previous line
  1729  e6ef 28                 	plp
  1730  e6f0 b003               	bcs linrts		; skip if was wrapped
  1731  e6f2 38                 	sec
  1732  e6f3 66cf               	ror lsxp  		; set flag - new line
  1733                          
  1734  e6f5 60                 linrts: rts
  1735                          ; -------------------------------------------------------------------------------------------------
  1736                          ;**************************
  1737                          ; Delete line (esc-d)
  1738                          ;**************************
  1739                          ; E6F8 Insert or delete a line
  1740  e6f6 b0e9               	bcs iline		; insert if C=1
  1741                          
  1742  e6f8 20e9e4             dline:	jsr fistrt		; find start of line
  1743  e6fb a5dc               	lda sctop		; save current of window
  1744  e6fd 48                 	pha
  1745  e6fe a5ca               	lda tblx		; make 1st display line top of window
  1746  e700 85dc               	sta sctop
  1747  e702 ad8a03             	lda logscr		; make sure logical scrl is off
  1748  e705 48                 	pha
  1749  e706 a980               	lda #$80
  1750  e708 8d8a03             	sta logscr
  1751  e70b 201ae4             	jsr scru15		; scroll the top line away
  1752  e70e 68                 	pla
  1753  e70f 8d8a03             	sta logscr
  1754  e712 a5dc               	lda sctop		; make old 1st line of this 1 current
  1755  e714 85ca               	sta tblx
  1756  e716 68                 	pla
  1757  e717 85dc               	sta sctop
  1758  e719 38                 	sec
  1759  e71a 66cf               	ror lsxp		; set flag - new line
  1760  e71c 4cd9e0             	jmp stu10		; make this line the current one
  1761                          ; -------------------------------------------------------------------------------------------------
  1762                          ;******************************
  1763                          ; E71F Erase to end of line (esc-q)
  1764                          ;******************************
  1765  e71f 18                 etoeol: clc
  1766  e720 24                 	!byte $24               ; skip next instruction
  1767                          ;******************************
  1768                          ; E721 Erase to start of line (esc-p)
  1769                          ;******************************
  1770  e721 38                 etosol: sec
  1771  e722 2052e5             	jsr savpos
  1772  e725 b012               	bcs etstol
  1773                          ; Erase to end of line
  1774  e727 2029e2             etol:	jsr clrprt		; blank rest of line
  1775  e72a e6ca               	inc tblx		; move to next line
  1776  e72c 20dfe0             	jsr stupt
  1777  e72f a4de               	ldy sclf
  1778  e731 20a6e4             	jsr getbit		; check if next is wrapped line
  1779  e734 b0f1               	bcs etol		; yes - blank next line
  1780                          
  1781  e736 4c74e5             etout:	jmp delout		; exit and restore original position
  1782                          ; Erase to start of line
  1783  e739 2007e2             etstol:	jsr doblnk		; do a blank
  1784  e73c c4de               	cpy sclf		; done a line ?
  1785  e73e d005               	bne ets100		; no
  1786  e740 20a6e4             	jsr getbit		; at top of line
  1787  e743 90f1               	bcc etout		; yes - exit
  1788  e745 2034e5             ets100:	jsr bakchr		; back up
  1789  e748 90ef               	bcc etstol		; always
  1790                          ; -------------------------------------------------------------------------------------------------
  1791                          ;*****************************
  1792                          ; E74A Scroll up (esc-v)
  1793                          ;*****************************
  1794  e74a 18                 esuup:	clc
  1795  e74b 24                 	!byte $24               ; skips next instruction
  1796                          ;*****************************
  1797                          ; E74C Scroll down (esc-w)
  1798                          ;*****************************
  1799  e74c 38                 esddn:	sec
  1800                          ; E74D Scroll screen depending on carry
  1801  e74d 2052e5             suup:	jsr savpos
  1802  e750 b00b               	bcs sddn		; scroll down if C=1
  1803                          ; Scroll up
  1804  e752 8a                 	txa
  1805  e753 48                 	pha
  1806  e754 2008e4             	jsr scrup
  1807  e757 68                 	pla
  1808  e758 85da               	sta sedt2
  1809  e75a 4c36e7             	jmp etout		; always
  1810                          ; Scroll down
  1811  e75d 20a6e4             sddn:   jsr getbit
  1812  e760 b003               	bcs sddn2
  1813  e762 38                 	sec
  1814  e763 66cf               	ror lsxp		; set flag - left line
  1815  e765 a5dc               sddn2:  lda sctop
  1816  e767 85ca               	sta tblx		; scroll from screen top
  1817  e769 20dfe3             	jsr scrdwn
  1818  e76c 20b6e4             	jsr clrbit		; make first line non-continued
  1819  e76f 4c36e7             	jmp etout		; always
  1820                          ; -------------------------------------------------------------------------------------------------
  1821                          ;**************************************
  1822                          ; Turn off all modes
  1823                          ;   expected to return zero
  1824                          ;**************************************
  1825                          ; E772 Reset modes: insert, reverse, quote
  1826  e772 a900               toqm:	lda #0
  1827  e774 85d3               	sta insrt
  1828  e776 8d8303             	sta rvs
  1829  e779 85d2               	sta qtsw
  1830                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1831  e77b 8d18da             	sta sid+volume		; turn off sid
  1832                          } else{
  1833                          	sta unknwn
  1834                          }
  1835  e77e 60                 	rts
  1836                          *= $E77F
  1837                          ; -------------------------------------------------------------------------------------------------
  1838                          ; E77F Enable scrolling (esc-l)
  1839  e77f 18                 scrsw0:	clc
  1840  e780 9001               	bcc scrsw
  1841                          ; E782 Disable scrolling (esc-m)
  1842  e782 38                 scrsw1:	sec
  1843                          ; Scrolling enable/disable
  1844                          ;           carry set = disable
  1845  e783 a900               scrsw:	lda #0
  1846  e785 6a                 	ror
  1847  e786 8d8703             	sta scrdis		; store flag: $00 = enable, $80 = disable
  1848  e789 60                 	rts
  1849                          ; -------------------------------------------------------------------------------------------------
  1850                          ; E78A Insert mode off
  1851  e78a 18                 insoff:	clc
  1852  e78b 9001               	bcc inssw
  1853                          ; E78D Insert mode on
  1854  e78d 38                 inson:	sec
  1855                          ; Auto insert on/off
  1856                          ;           carry set = on
  1857  e78e a900               inssw:	lda #0
  1858  e790 6a                 	ror
  1859  e791 8d8603             	sta insflg		; store flag: $00 = off, $80 = on
  1860  e794 60                 	rts
  1861                          ; -------------------------------------------------------------------------------------------------
  1862                          ; E795 Enable/Disable logical scroll
  1863  e795 18                 logoff:	clc			; disable logical scroll (single line scroll)
  1864  e796 9001               	bcc logsw
  1865                          
  1866  e798 38                 logon:	sec			; enable logical scroll (scroll a set of lines)
  1867                          ; Logical scroll enable/disable
  1868                          ;   carry set = enable
  1869  e799 a900               logsw:	lda #0
  1870  e79b 6a                 	ror
  1871  e79c 8d8a03             	sta logscr		; store flag: $00 = disable, $80 = enable
  1872  e79f 60                 	rts
  1873                          ; -------------------------------------------------------------------------------------------------
  1874                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1875                          ; E7A0 This function is not used - removed in patch 3
  1876  e7a0 60                 unused:	rts			; something related to $03BF
  1877                          				;   code removed to free space for new f-key functions below
  1878                          ; -------------------------------------------------------------------------------------------------
  1879                          ; ********** Patched new f-key functions with sei/cli and chr$(141) for shift-return **********
  1880  e7a1 78                 keyfun: sei			; prevent fight over variables with keyscan...
  1881  e7a2 88                 	dey
  1882  e7a3 3003               	bmi listky		; do list if no parameters given
  1883  e7a5 4c64e8             	jmp addkey		; - else go add a new key definition
  1884                          ; list key defintions
  1885  e7a8 a000               listky:	ldy #0			; initialize key counter
  1886                          
  1887  e7aa c8                 listlp:	iny
  1888  e7ab 84d9               	sty sedt1
  1889  e7ad 88                 	dey			; minus 1 for indexing
  1890  e7ae b98d03             	lda keysiz,y		; get key length
  1891  e7b1 f06b               	beq nodefn		; no listing if no defintion
  1892  e7b3 8d8903             	sta keyidx		; save key length
  1893  e7b6 2015ea             	jsr findky		; get buffer start addr for function key
  1894  e7b9 85c2               	sta keypnt
  1895  e7bb 86c3               	stx keypnt+1		; save 2 byte address in temp loc
  1896                          ; print 'key ' preamble
  1897  e7bd a203               	ldx #3
  1898  e7bf bd4ce8             preamb:	lda keword,x
  1899  e7c2 20d2ff             	jsr bsout
  1900  e7c5 ca                 	dex
  1901  e7c6 10f7               	bpl preamb
  1902                          ; convert to 1 or 2 digit ascii
  1903  e7c8 a22f               	ldx #$2F
  1904  e7ca a5d9               	lda sedt1		; get key number
  1905  e7cc 38                 	sec
  1906  e7cd e8                 ky2asc:	inx			; .x=$30, if two digits it will inc to $31
  1907  e7ce e90a               	sbc #10
  1908  e7d0 b0fb               	bcs ky2asc		; repeat if >9
  1909  e7d2 693a               	adc #$3A		; add 10 & make ascii
  1910  e7d4 e030               	cpx #$30
  1911  e7d6 f006               	beq nosec		; skip 2nd digit print
  1912  e7d8 48                 	pha			; save first digit-10
  1913  e7d9 8a                 	txa
  1914  e7da 20d2ff             	jsr bsout		; print second digit
  1915  e7dd 68                 	pla			; restore first digit-10
  1916                          ; print key string
  1917  e7de 20d2ff             nosec:	jsr bsout		; print first digit
  1918  e7e1 a000               	ldy #0			; init string position counter
  1919  e7e3 a92c               	lda #','		; for comma print
  1920  e7e5 20d2ff             lstk20:	jsr bsout		; print char - comma or plus-sign
  1921  e7e8 a207               	ldx #7			; for chr$ printing - no plus-sign or quote to preceed
  1922  e7ea 2067e2             txtprt:	jsr pagkey		; make sure function key ram page (indirect segment)
  1923  e7ed b1c2               	lda (keypnt),y		; get byte
  1924  e7ef 207ce2             	jsr pagres		; restore ram page (indirect segment)
  1925  e7f2 c90d               	cmp #13
  1926  e7f4 f031               	beq lstkcr		; print chr$(13) for return
  1927  e7f6 c98d               	cmp #141
  1928  e7f8 f030               	beq lstksc		; print chr$(141) for shift-return
  1929  e7fa c922               	cmp #34
  1930  e7fc f02f               	beq lstkqt		; print chr$(34) for quote
  1931  e7fe e009               	cpx #9			; was a normal char printed last time
  1932  e800 f007               	beq lstk10		; yes - skip ahead
  1933  e802 48                 	pha			; save char
  1934  e803 a922               	lda #$22
  1935  e805 20d2ff             	jsr bsout		; print a quote
  1936  e808 68                 	pla			; restore the char
  1937                          
  1938  e809 20d2ff             lstk10:	jsr bsout		; print the char
  1939  e80c a209               	ldx #9			; for chr$ - print quote and plus next time
  1940  e80e c8                 	iny
  1941  e80f cc8903             	cpy keyidx
  1942  e812 d0d6               	bne txtprt		; loop to end of string
  1943                          
  1944  e814 a922               	lda #$22
  1945  e816 20d2ff             	jsr bsout		; print ending quote
  1946                          
  1947  e819 a90d               lstk30:	lda #$0D
  1948  e81b 20d2ff             	jsr bsout		; do a return
  1949                          
  1950  e81e a4d9               nodefn:	ldy sedt1		; get key number
  1951  e820 c014               	cpy #pgmkys
  1952  e822 d086               	bne listlp		; loop til all keys checked
  1953                          
  1954  e824 58                 	cli			; all done...clear the keyscan holdoff
  1955  e825 18                 	clc			; okay return always
  1956  e826 60                 	rts
  1957                          
  1958  e827 a20a               lstkcr:	ldx #qtword-cdword-1	; index for return
  1959  e829 2c                 	!byte $2c		; skip 2
  1960  e82a a213               lstksc:	ldx #addkey-cdword-1	; index for shifted-return
  1961  e82c 2c                 	!byte $2c		; skip 2
  1962  e82d a20e               lstkqt:	ldx #scword-cdword-1	; index for quote
  1963                          
  1964  e82f 8a                 lstk:	txa			; save value index....
  1965  e830 48                 	pha			; save .x
  1966  e831 a206               	ldx #crword-cdword-1	; print chr$(
  1967  e833 bd50e8             lstklp:	lda cdword,x		; print loop
  1968  e836 f00a               	beq lstk40		; zero is end...
  1969  e838 20d2ff             	jsr bsout
  1970  e83b ca                 	dex
  1971  e83c 10f5               	bpl lstklp
  1972                          
  1973  e83e 68                 	pla			; move number and repeat
  1974  e83f aa                 	tax
  1975  e840 d0f1               	bne lstklp		; loop again for 'xxx)' ending part
  1976                          
  1977  e842 c8                 lstk40:	iny
  1978  e843 cc8903             	cpy keyidx
  1979  e846 f0d1               	beq lstk30		; exit if all string printed
  1980  e848 a92b               	lda #'+'		; set to print plus sign
  1981  e84a d099               	bne lstk20		; return to routine
  1982                          
  1983  e84c 2059454b           keword:	!pet " yek"
  1984  e850 28245248432b22     cdword:	!pet "($rhc+",$22
  1985  e857 00293331           crword:	!pet 0,")31"
  1986  e85b 00293433           qtword:	!pet 0,")43"
  1987  e85f 0029313431         scword:	!pet 0,")141"
  1988                          
  1989                          ; insert a new key defintion
  1990  e864 48                 addkey:	pha			; save zero page address of params
  1991  e865 aa                 	tax
  1992  e866 84d9               	sty sedt1		; save key number in temp loc
  1993  e868 b500               	lda $0,x		; get new string length
  1994  e86a 38                 	sec
  1995  e86b f98d03             	sbc keysiz,y		; subtract old length
  1996  e86e 85da               	sta sedt2		; save difference in temp location
  1997  e870 6e8803             	ror fktmp		; save the carry
  1998  e873 c8                 	iny
  1999  e874 2015ea             	jsr findky		; find start addr of next function key
  2000  e877 85c4               	sta sedsal
  2001  e879 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  2002  e87b a014               	ldy #pgmkys
  2003  e87d 2015ea             	jsr findky		; find end of last function key
  2004  e880 85c6               	sta sedeal
  2005  e882 86c7               	stx sedeal+1		; save next free byte addr in temp loc
  2006  e884 ac8803             	ldy fktmp		; check if new string is longer or shorter
  2007  e887 1013               	bpl keysho		; skip ahead if shorter
  2008  e889 18                 	clc
  2009  e88a ed8003             	sbc pkyend		; subtract last available adress
  2010  e88d a8                 	tay
  2011  e88e 8a                 	txa
  2012  e88f ed8103             	sbc pkyend+1
  2013  e892 aa                 	tax
  2014  e893 98                 	tya
  2015  e894 18                 	clc
  2016  e895 65da               	adc sedt2		; add difference
  2017  e897 8a                 	txa
  2018  e898 6900               	adc #0
  2019  e89a b06c               	bcs kyxit		; exit if no room, skip if memory not full
  2020                          
  2021                          ; expand or contract key area to make room for new key definition.
  2022  e89c 2067e2             keysho:	jsr pagkey		; set up function key ram page (indirect segment)
  2023  e89f a5c6               kymove:	lda sedeal
  2024  e8a1 18                 	clc			; check if entire area expanded or contracted
  2025  e8a2 e5c4               	sbc sedsal
  2026  e8a4 a5c7               	lda sedeal+1
  2027  e8a6 e5c5               	sbc sedsal+1
  2028  e8a8 902a               	bcc keyins		; go insert new key defintion if yes
  2029  e8aa a000               	ldy #0
  2030  e8ac ad8803             	lda fktmp		; check if expand or contract
  2031  e8af 1011               	bpl kshort		; skip if needs to be contracted
  2032                          
  2033  e8b1 a5c6               	lda sedeal
  2034  e8b3 d002               	bne newky4		; dec 1 from source addr
  2035  e8b5 c6c7               	dec sedeal+1		; sub 1 for borrow
  2036  e8b7 c6c6               newky4:	dec sedeal
  2037  e8b9 b1c6               	lda (sedeal),y		; move 1 byte up to expand
  2038  e8bb a4da               	ldy sedt2		; get offset = difference
  2039  e8bd 91c6               	sta (sedeal),y		; move byte up
  2040  e8bf 4c9fe8             	jmp kymove		; loop until all bytes moved
  2041                          
  2042  e8c2 b1c4               kshort:	lda (sedsal),y		; get source byte
  2043  e8c4 a4da               	ldy sedt2		; get offset = difference
  2044  e8c6 c6c5               	dec sedsal+1		; sub 1 to move down
  2045  e8c8 91c4               	sta (sedsal),y		; move the byte down
  2046  e8ca e6c5               	inc sedsal+1
  2047  e8cc e6c4               	inc sedsal		; move source up 1 byte
  2048  e8ce d0cf               	bne kymove
  2049  e8d0 e6c5               	inc sedsal+1		; add 1 for carry
  2050  e8d2 d0cb               	bne kymove		; always
  2051                          ; insert the new string defintion
  2052  e8d4 a4d9               keyins:	ldy sedt1		; get the key index
  2053  e8d6 2015ea             	jsr findky		; find buffer start address for this key
  2054  e8d9 85c4               	sta sedsal
  2055  e8db 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  2056  e8dd a4d9               	ldy sedt1
  2057  e8df 68                 	pla
  2058  e8e0 48                 	pha
  2059  e8e1 aa                 	tax			; get zero page addr of params
  2060  e8e2 b500               	lda $0,x
  2061  e8e4 998d03             	sta keysiz,y		; save key length
  2062  e8e7 a8                 	tay
  2063  e8e8 f01a               	beq kyinok		; equal to zero no keys...exit
  2064  e8ea b501               	lda $1,x		; get & save low byte of string address
  2065  e8ec 85c6               	sta sedeal
  2066  e8ee b502               	lda $2,x		; get & save high byte of string address
  2067  e8f0 85c7               	sta sedeal+1
  2068                          
  2069  e8f2 88                 kyinlp:	dey
  2070  e8f3 b503               	lda $3,x		; get string ram page
  2071  e8f5 8501               	sta i6509
  2072  e8f7 b1c6               	lda (sedeal),y		; get byte
  2073  e8f9 207ce2             	jsr pagres		; restore ram page (indirect segment)
  2074  e8fc 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
  2075  e8ff 91c4               	sta (sedsal),y		; store into buffer
  2076  e901 98                 	tya			; .y flags...end?
  2077  e902 d0ee               	bne kyinlp		; no... loop
  2078                          
  2079  e904 207ce2             kyinok:	jsr pagres		; restore ram page (indirect segment)
  2080  e907 18                 	clc			; for good exit carry clear
  2081  e908 68                 kyxit:	pla			; pop zero page address for params
  2082  e909 58                 	cli			; all done...release keyscan
  2083  e90a 60                 	rts			; c-set is memory full error
  2084                          } else{			; ********* OLD version without chr$(141) and sei/cli
  2085                          ; -------------------------------------------------------------------------------------------------
  2086                          ; E7A0 Not used - removed in patch 3
  2087                          unused:	lda unknwn		; ($03BF)
  2088                          	eor #$C0
  2089                          	sta unknwn
  2090                          	rts
  2091                          ; -------------------------------------------------------------------------------------------------
  2092                          ;******************************************
  2093                          ; E7A9 Programmable key functions
  2094                          ;******************************************
  2095                          keyfun:	dey
  2096                          	bmi listky		; do list if no parameters given
  2097                          	jmp addkey		; - else go add a new key definition
  2098                          ; List function keys
  2099                          listky:	ldy #0			; initialize key counter
  2100                          
  2101                          listlp: iny
  2102                          	sty sedt1
  2103                          	dey			; minus 1 for indexing
  2104                          	lda keysiz,y		; get key length
  2105                          	beq nodefn		; no listing if no defintion
  2106                          	sta keyidx		; save key length
  2107                          	jsr findky		; get buffer start addr for function key
  2108                          	sta keypnt
  2109                          	stx keypnt+1		; save 2 byte address in temp loc
  2110                          	ldx #3
  2111                          ; print 'key ' preamble
  2112                          preamb: lda keword,x
  2113                          	jsr jbsout
  2114                          	dex
  2115                          	bpl preamb
  2116                          ; convert to 1 or 2 digit ascii
  2117                          	ldx #$2F
  2118                          	lda sedt1		; get key number
  2119                          	sec
  2120                          ky2asc: inx			; .x=$30, if two digits it will inc to $31
  2121                          	sbc #10
  2122                          	bcs ky2asc		; repeat if >9
  2123                          	adc #$3A		; add 10 & make ascii
  2124                          	cpx #'0'
  2125                          	beq nosec		; skip 2nd digit print
  2126                          	pha			; save first digit-10
  2127                          	txa
  2128                          	jsr jbsout		; print second digit '1'
  2129                          	pla			; restore first digit-10
  2130                          
  2131                          nosec:  jsr jbsout		; print first digit
  2132                          	ldy #0			; init string position counter
  2133                          	lda #','		; for comma print
  2134                          	ldx #6
  2135                          txtprt:	cpx #8
  2136                          	beq lstk00		; skip if normal char last time
  2137                          	jsr jbsout		; print char - comma or plus-sign
  2138                          lstk00:	php
  2139                          	jsr pagkey		; set up function key ram page (indirect segment)
  2140                          	lda (keypnt),y		; get byte
  2141                          	jsr pagres		; restore ram page (indirect segment)
  2142                          	plp
  2143                          	cmp #$0D
  2144                          	beq lstkcr		; print chr$(13) for return
  2145                          	cmp #$8D
  2146                          	beq lstkcr		; print chr$(13) for shift-return
  2147                          	cmp #$22
  2148                          	beq lstkqt		; print chr$(34) for quote
  2149                          	cpx #8			; was a normal char printed last time
  2150                          	beq lstk10		; yes - skip ahead
  2151                          	pha			; save char
  2152                          	lda #$22
  2153                          	jsr jbsout		; print a quote
  2154                          	pla
  2155                          	ldx #8			; skip next print at loop start
  2156                          lstk10: jsr jbsout		; print char
  2157                          	lda #'+'
  2158                          	iny
  2159                          	cpy keyidx
  2160                          	bne txtprt		; loop to end of string
  2161                          
  2162                          	cpx #6
  2163                          	beq lstk30
  2164                          	lda #$22
  2165                          	jsr jbsout		; print ending quote
  2166                          
  2167                          lstk30: lda #$0D
  2168                          	jsr jbsout		; do a return
  2169                          
  2170                          nodefn: ldy sedt1		; get key number
  2171                          	cpy #pgmkys
  2172                          	beq listx		; exit if finished list
  2173                          	jmp listlp		; print next key definition
  2174                          
  2175                          listx:	clc
  2176                          	rts
  2177                          ; E83C
  2178                          lstkcr:	clc
  2179                          lstklp:	lda crword,x		; load chr$(13 string
  2180                          lstkqt:	bcc lstk40
  2181                          	lda qtword,x		; load chr$(34 string
  2182                          lstk40:	php			; preserce carry flag for string selection
  2183                          	jsr jbsout
  2184                          	plp
  2185                          	dex
  2186                          	bpl lstklp		; next char
  2187                          
  2188                          	lda #')' 
  2189                          	ldx #6			; mark to print ')' at loop start
  2190                          	bne lstk10
  2191                          ; Jump vector: bsout via indirect vector
  2192                          jbsout:	jmp (ibsout)
  2193                          ; -------------------------------------------------------------------------------------------------
  2194                          ; E856 
  2195                          keword: !pet " yek"		; 'key '
  2196                          crword: !pet "31($rhc+", $22	; "+chr$(13
  2197                          qtword: !pet "43($rhc+", $22	; "+chr$(34
  2198                          ; -------------------------------------------------------------------------------------------------
  2199                          ; E86C Insert a new key defintion
  2200                          addkey: pha			; save zero page address of params
  2201                          	tax
  2202                          	sty sedt1		; save key number in temp loc
  2203                          	lda $00,x		; get new string length
  2204                          	sec
  2205                          	sbc keysiz,y		; subtract old length
  2206                          	sta sedt2		; save difference in temp location
  2207                          	iny
  2208                          	jsr findky		; find start addr of next function key
  2209                          	sta sedsal
  2210                          	stx sedsal+1		; save 2 byte address in temp loc
  2211                          	ldy #pgmkys
  2212                          	jsr findky		; find end of last function key
  2213                          	sta sedeal
  2214                          	stx sedeal+1		; save next free byte addr in temp loc
  2215                          	ldy sedt2		; load difference
  2216                          	bmi keysho		; skip ahead if old key shorter
  2217                          	clc
  2218                          	sbc pkyend		; subtract last available adress
  2219                          	tay
  2220                          	txa
  2221                          	sbc pkyend+1
  2222                          	tax
  2223                          	tya
  2224                          	clc
  2225                          	adc sedt2		; add difference
  2226                          	txa
  2227                          	adc #0			; add carry
  2228                          	bcc keysho		; make room for definition
  2229                          	pla
  2230                          	rts			; exit if no room
  2231                          ; E8A2 expand or contract key area to make room for new key definition.
  2232                          keysho: jsr pagkey		; set up function key ram page (indirect segment)
  2233                          kymove: lda sedeal
  2234                          	clc 			; check if entire area expanded or contracted
  2235                          	sbc sedsal
  2236                          	lda sedeal+1
  2237                          	sbc sedsal+1
  2238                          	bcc keyins		; go insert new key defintion if yes
  2239                          	ldy #0
  2240                          	lda sedt2		; check if expand or contract
  2241                          	bmi kshort		; skip if needs to be contracted
  2242                          
  2243                          	lda sedeal
  2244                          	bne newky4		; dec 1 from source addr
  2245                          	dec sedeal+1		; sub 1 for borrow
  2246                          newky4: dec sedeal
  2247                          	lda (sedeal),y		; move 1 byte up to expand
  2248                          	ldy sedt2		; get offset = difference
  2249                          	sta (sedeal),y		; move byte up
  2250                          	bpl kymove		; loop until all bytes moved
  2251                          
  2252                          kshort:	lda (sedsal),y		; get source byte
  2253                          	ldy sedt2		; get offset = difference
  2254                          	dec sedsal+1		; sub 1 to move down
  2255                          	sta (sedsal),y		; move the byte down
  2256                          	inc sedsal+1
  2257                          	inc sedsal		; move source up 1 byte
  2258                          	bne kymove
  2259                          	inc sedsal+1		; add 1 for carry
  2260                          	bne kymove		; always
  2261                          ;  insert the new string defintion
  2262                          keyins: ldy sedt1		; get the key index
  2263                          	jsr findky		; find buffer start address for this key
  2264                          	sta sedsal
  2265                          	stx sedsal+1		; save 2 byte address in temp loc
  2266                          	ldy sedt1
  2267                          	pla
  2268                          	tax			; get zero page addr of params
  2269                          	lda $00,x
  2270                          	sta keysiz,y		; save key length
  2271                          	tay
  2272                          	lda $01,x		; get & save low byte of string address
  2273                          	sta sedeal
  2274                          	lda $02,x		; get & save high byte of string address
  2275                          	sta sedeal+1
  2276                          
  2277                          kyinlp: dey 
  2278                          	bmi kyinok
  2279                          	lda $03,x		; get string ram bank
  2280                          	sta i6509
  2281                          	lda (sedeal),y		; get byte
  2282                          	jsr pagres		; restore ram page (indirect segment)
  2283                          	jsr pagkey		; set up function key ram page (indirect segment)
  2284                          	sta (sedsal),y		; store into buffer
  2285                          	jmp kyinlp		; next 
  2286                          
  2287                          kyinok: jsr pagres    		; restore indirect bank
  2288                          	clc 			; for good exit carry clear
  2289                          	rts
  2290                          }
  2291                          *= $E90C
  2292                          ; -------------------------------------------------------------------------------------------------
  2293                          ;*******************************
  2294                          ; E90C Keyboard scanner
  2295                          ;*******************************
  2296                          ; Cursor blink routine
  2297  e90c 206ce6             scnkey: jsr junkwn2		; vector -> nofunc (rts)
  2298  e90f a5e6               	lda blnon
  2299  e911 d020               	bne key			; skip if blinking cursor is off (run mode)
  2300                          
  2301                          !ifdef SOLID_CURSOR{		; ********** Solid cursor patch ***********
  2302  e913 a5eb               	lda blnsw
  2303  e915 d01c               	bne key			; skip if cursor already visible
  2304                          	
  2305  e917 e6eb               	inc blnsw		; set visibility switch
  2306  e919 203fe2             	jsr get1ch		; get char and color under cursor
  2307  e91c a6ed               	ldx gdcol
  2308  e91e 85d4               	sta config		; remember char under cursor
  2309  e920 a6ea               	ldx tcolor
  2310  e922 86ed               	stx gdcol		; remember char color
  2311  e924 a6ec               	ldx color		; load actual color
  2312  e926 4980               scnk10:	eor #$80		; inverse char
  2313  e928 2013e2             	jsr dspp		; print (reversed) char
  2314  e92b 4c33e9             	jmp key
  2315                          } else{				; ********** Blinking standard cursor **********
  2316                          	dec blncnt
  2317                          	bne key			; skip if blink counter not zero
  2318                          	lda #20
  2319                          	sta blncnt		; reset blink counter
  2320                          	jsr get1ch		; get char and color under cursor
  2321                          	ldx gdcol
  2322                          	lsr blnsw		; reset blink switch
  2323                          	bcs scnk10		; if cursor is off -> reverse char
  2324                          	inc blnsw		; set blink switch
  2325                          	sta config		; remember char under cursor
  2326                          	ldx tcolor
  2327                          	stx gdcol		; remember char color
  2328                          	ldx color		; load actual color
  2329                          scnk10:	eor #$80		; inverse char
  2330                          	jsr dspp		; print (reversed) char
  2331                          }
  2332                          *= $E933
  2333                          ; E933 Keyboard scanner
  2334  e933 a0ff               key:    ldy #$FF		; say no keys pressed (real-time keyscan)
  2335  e935 84e0               	sty modkey
  2336  e937 84e1               	sty norkey
  2337  e939 c8                 	iny			; init base kybd index = 0
  2338  e93a 8c01df             	sty tpi2+pb		; allow all output lines
  2339  e93d 8c00df             	sty tpi2+pa
  2340  e940 20eae9             	jsr getkey		; get keybd input
  2341  e943 293f               	and #$3F		; check if any inputs
  2342  e945 493f               	eor #$3F
  2343  e947 f076               	beq nulxit		; exit if none
  2344  e949 a9ff               	lda #$FF
  2345  e94b 8d00df             	sta tpi2+pa		; allow only output line 0
  2346  e94e 0a                 	asl
  2347  e94f 8d01df             	sta tpi2+pb
  2348  e952 20eae9             	jsr getkey		; get input from line 0
  2349  e955 48                 	pha			; save shift & control bits
  2350  e956 85e0               	sta modkey		; shift keys are down
  2351  e958 0930               	ora #$30		; mask them by setting bits
  2352  e95a d003               	bne line01
  2353                          
  2354  e95c 20eae9             linelp: jsr getkey		; get line inputs
  2355  e95f a205               line01: ldx #5			; loop for 6 input lines
  2356  e961 4a                 kyloop: lsr			; check line
  2357  e962 9010               	bcc havkey		; skip ahead if have input
  2358  e964 c8                 	iny			; inc keyd code count
  2359  e965 ca                 	dex
  2360  e966 10f9               	bpl kyloop
  2361                          
  2362  e968 38                 	sec
  2363  e969 2e01df             	rol tpi2+pb		; rotate to activate next
  2364  e96c 2e00df             	rol tpi2+pa		; - output line
  2365  e96f b0eb               	bcs linelp		; loop until all lines done
  2366                          
  2367  e971 68                 	pla			; clear shift/control byte
  2368  e972 904b               	bcc nulxit		; exit if no key
  2369                          ; get pet-ascii using keyboard index and shift and control inputs
  2370  e974 beb1ea             havkey: ldx normtb,y
  2371  e977 84e1               	sty norkey		; have a normal keypress
  2372  e979 68                 	pla			; get shift/control byte
  2373  e97a 0a                 	asl
  2374  e97b 0a                 	asl			; move bits left
  2375  e97c 0a                 	asl
  2376  e97d 900e               	bcc doctl		; skip ahead if control depressed
  2377  e97f 300f               	bmi havasc		; skip ahead if not shifted - have ascii
  2378  e981 be11eb             	ldx shfttb,y		; assume shited textual
  2379  e984 a5cc               	lda grmode		; test text or graphic mode
  2380  e986 d008               	bne havasc		; have key if text mode
  2381  e988 be71eb             	ldx shftgr,y		; get shifted graphic
  2382  e98b d003               	bne havasc		; go process ascii key
  2383                          
  2384  e98d bed1eb             doctl:	ldx ctltbl,y		; get pet-ascii char for this key
  2385                          ; y-reg has keyboard index value
  2386                          ; x-reg has pet-ascii value
  2387  e990 e0ff               havasc: cpx #$FF
  2388  e992 f02d               	beq keyxit		; exit if null pet-ascii
  2389  e994 8a                 	txa
  2390  e995 c9e0               	cmp #$E0		; check if function key
  2391  e997 9009               	bcc notfun		; skip - not a function key
  2392  e999 98                 	tya
  2393  e99a 48                 	pha
  2394  e99b 20f3e9             	jsr funjmp		; do function key indirect
  2395  e99e 68                 	pla
  2396  e99f a8                 	tay
  2397  e9a0 b01f               	bcs keyxit		; done if carry flag set
  2398                          ; E9A2 Not a function key
  2399  e9a2 8a                 notfun: txa			; get pet-ascii code
  2400  e9a3 c4cd               	cpy lstx		; check if same key as last
  2401                          ; Time through
  2402  e9a5 f027               	beq dorpt		; skip ahead if so
  2403                          ; A new key input - check queue availability
  2404  e9a7 a213               	ldx #19
  2405  e9a9 86d8               	stx delay		; reset initial delay count
  2406  e9ab a6d1               	ldx ndx			; get key-in queue size
  2407  e9ad e009               	cpx #keymax		; check if queue full
  2408  e9af f00e               	beq nulxit		; exit if yes
  2409  e9b1 c059               	cpy #dblzer		; check if keypad - 00
  2410  e9b3 d029               	bne savkey		; go save key-in if not
  2411  e9b5 e008               	cpx #keymax-1		; check if room for two
  2412  e9b7 f006               	beq nulxit		; exit if not
  2413  e9b9 9dab03             	sta keyd,x		; save first zero
  2414  e9bc e8                 	inx			; update queue size
  2415  e9bd d01f               	bne savkey		; always
  2416                          
  2417  e9bf a0ff               nulxit: ldy #$FF
  2418  e9c1 84cd               keyxit: sty lstx		; save last key number
  2419  e9c3 a27f               keyxt2: ldx #$7F
  2420  e9c5 8e00df             	stx tpi2+pa		; reset output lines to allow
  2421  e9c8 a2ff               	ldx #$FF		; - stop key input
  2422  e9ca 8e01df             	stx tpi2+pb
  2423  e9cd 60                 	rts
  2424                          
  2425                          ; E9CE Check repeat delays
  2426  e9ce c6d8               dorpt:  dec delay		; dec initial delay count
  2427  e9d0 10f1               	bpl keyxt2		; exit if was not zero - still on 1st delay
  2428  e9d2 e6d8               	inc delay		; - else reset count to zero
  2429                          
  2430                          ; Check if secondary count down to zero
  2431  e9d4 c6d7               	dec rptcnt		; dec repeat btwn keys
  2432  e9d6 10eb               	bpl keyxt2		; exit if was not zero - still on delay
  2433  e9d8 e6d7               	inc rptcnt		; reset back to zero
  2434                          
  2435                          ; Time to repeat - check if key queue empty
  2436  e9da a6d1               	ldx ndx			; get kybd queue size
  2437  e9dc d0e5               	bne keyxt2		; exit if kybd queue not empty
  2438                          
  2439                          ; E9DE Save pet-ascii into key buffer
  2440  e9de 9dab03             savkey: sta keyd,x		; store pet-ascii in kybd buffer
  2441  e9e1 e8                 	inx
  2442  e9e2 86d1               	stx ndx
  2443  e9e4 a203               	ldx #3
  2444  e9e6 86d7               	stx rptcnt		; reset delay btwn keys
  2445  e9e8 d0d7               	bne keyxit
  2446                          ; E9EA Read keyboard matrix and debounce
  2447  e9ea ad02df             getkey: lda tpi2+pc		; debounce keyboard input
  2448  e9ed cd02df             	cmp tpi2+pc
  2449  e9f0 d0f8               	bne getkey
  2450  e9f2 60                 	rts
  2451                          ; -------------------------------------------------------------------------------------------------
  2452                          ; E9F3 Jump vector: Function key indirect
  2453  e9f3 6cb503             funjmp: jmp (funvec)
  2454                          ; -------------------------------------------------------------------------------------------------
  2455                          ; E9F6 Default function key handler
  2456  e9f6 c4cd               dokeyf: cpy lstx
  2457  e9f8 f019               	beq funrts		; exit not allowed to repeat
  2458  e9fa a5d1               	lda ndx
  2459  e9fc 05d6               	ora kyndx
  2460  e9fe d013               	bne funrts		; exit - function queue not empty
  2461  ea00 8d8903             	sta keyidx		; init pointer index into function area
  2462  ea03 8a                 	txa
  2463  ea04 291f               	and #$1F		; mask out to get function key number
  2464  ea06 a8                 	tay
  2465  ea07 b98d03             	lda keysiz,y		; get function key size
  2466  ea0a 85d6               	sta kyndx		; - and store it for key scan
  2467  ea0c 2015ea             	jsr findky
  2468  ea0f 85c2               	sta keypnt		; get function start addr
  2469  ea11 86c3               	stx keypnt+1		; - and save in keypnt
  2470                          
  2471  ea13 38                 funrts: sec
  2472  ea14 60                 	rts
  2473                          ; -------------------------------------------------------------------------------------------------
  2474                          ; EA15 Find address of function key given in y-reg
  2475  ea15 a5c0               findky: lda pkybuf
  2476  ea17 a6c1               	ldx pkybuf+1
  2477                          
  2478  ea19 18                 findlp: clc
  2479  ea1a 88                 	dey			; found key yet?
  2480  ea1b 3008               	bmi fndout		; yes - done
  2481  ea1d 798d03             	adc keysiz,y		; add function key size
  2482  ea20 90f7               	bcc findlp		; loop if no high byte carry-over
  2483  ea22 e8                 	inx
  2484  ea23 d0f4               	bne findlp		; loop - always
  2485                          
  2486  ea25 60                 fndout: rts
  2487                          ; -------------------------------------------------------------------------------------------------
  2488                          ; EA26 Tab set-up (tab positioner)
  2489                          ;   y=column in question
  2490  ea26 98                 gettab: tya			; get bit in question
  2491  ea27 2907               	and #$07
  2492  ea29 aa                 	tax
  2493  ea2a bdefec             	lda bits,x
  2494  ea2d 8d8803             	sta bitmsk
  2495  ea30 98                 	tya			; get 8 bit block
  2496  ea31 4a                 	lsr
  2497  ea32 4a                 	lsr
  2498  ea33 4a                 	lsr
  2499  ea34 aa                 	tax
  2500  ea35 bda103             	lda tab,x
  2501  ea38 2c8803             	bit bitmsk		; set equal flag
  2502  ea3b 60                 	rts
  2503                          ; -------------------------------------------------------------------------------------------------
  2504                          ;************************************************************
  2505                          ;*  routines involved in executing escape functions
  2506                          ;************************************************************
  2507                          ; EA3C Main escape sequence handler
  2508                          ;   entry: character following escape character in acc.
  2509  ea3c 297f               escape: and #$7F
  2510  ea3e 38                 	sec
  2511  ea3f e941               	sbc #'a'		; table begins at ascii a
  2512  ea41 c91a               	cmp #$1A		; 'z'-'a'+1
  2513  ea43 9001               	bcc escgo		; valid char, go get address
  2514  ea45 60                 escrts:	rts			; failed to find entry...ignore it!
  2515                          ; -------------------------------------------------------------------------------------------------
  2516                          ; EA46 Get address of escape routine, and go to it.
  2517  ea46 0a                 escgo:  asl			; multiply index by 2
  2518  ea47 aa                 	tax
  2519  ea48 bd52ea             	lda escvct+1,x		; get high byte
  2520  ea4b 48                 	pha
  2521  ea4c bd51ea             	lda escvct,x		; and low
  2522  ea4f 48                 	pha
  2523  ea50 60                 	rts			; and go to that address
  2524                          ; -------------------------------------------------------------------------------------------------
  2525                          ; EA51 Escape sequence table
  2526  ea51 aaea               escvct:	!word auton-1		; a Auto insert
  2527  ea53 86ea               	!word sethtb-1		; b set bottom
  2528  ea55 a7ea               	!word autoff-1		; c cancel auto insert
  2529  ea57 f7e6               	!word dline-1		; d Delete line
  2530  ea59 a6ea               	!word notimp-1		; e
  2531  ea5b a6ea               	!word notimp-1		; f
  2532  ea5d a1ea               	!word bellon-1		; g enable bell
  2533  ea5f a3ea               	!word bellof-1		; h disable bell
  2534  ea61 e0e6               	!word iline-1		; i Insert line
  2535  ea63 e4e4               	!word fndfst-1		; j Move to start of line
  2536  ea65 f6e4               	!word fndend-1		; k Move to end of line
  2537  ea67 7ee7               	!word scrsw0-1		; l enable scrolling
  2538  ea69 81e7               	!word scrsw1-1		; m disable scrolling
  2539  ea6b a6ea               	!word notimp-1		; n
  2540  ea6d 71e7               	!word toqm-1		; o cancel insert, quote and reverse
  2541  ea6f 20e7               	!word etosol-1		; p Erase to start of line
  2542  ea71 1ee7               	!word etoeol-1		; q Erase to end of line
  2543  ea73 a6ea               	!word notimp-1		; r
  2544  ea75 a6ea               	!word notimp-1		; s
  2545  ea77 84ea               	!word sethtt-1		; t Set top left of page
  2546  ea79 a6ea               	!word notimp-1		; u
  2547  ea7b 49e7               	!word esuup-1		; v Scroll up
  2548  ea7d 4be7               	!word esddn-1		; w Scroll down
  2549  ea7f 44ea               	!word escrts-1		; x cancel esacpe sequence
  2550  ea81 a6ea               	!word notimp-1		; y
  2551  ea83 a6ea               	!word notimp-1		; z
  2552                          ; -------------------------------------------------------------------------------------------------
  2553                          ; EA85 Set top left window corner (esc-t)
  2554  ea85 18                 sethtt: clc			; set upper left corner with C=0
  2555  ea86 24                 	!byte $24		; skip next instruction with bit $xx
  2556                          ; EA87 Set bottom right window corner (esc-b)
  2557  ea87 38                 sethtb: sec			; set lower right corner with C=1
  2558  ea88 a6cb               window: ldx pntr		; load cursor column
  2559  ea8a a5ca               	lda tblx		; load cursour row
  2560  ea8c 900f               	bcc settps		; set upper left corner if C=0
  2561  ea8e 85dd               setbts: sta scbot		; store last row
  2562  ea90 86df               	stx scrt		; store last column
  2563  ea92 60                 	rts
  2564                          ; -------------------------------------------------------------------------------------------------
  2565                          ; EA93 Set full screen window
  2566  ea93 a918               sreset: lda #scymax		; load last row, column of screen
  2567  ea95 a227               	ldx #scxmax
  2568  ea97 208eea             	jsr setbts		; set lower right corner
  2569  ea9a a900               	lda #0			; clear A, X to first row, column
  2570  ea9c aa                 	tax
  2571  ea9d 85dc               settps: sta sctop		; set first row
  2572  ea9f 86de               	stx sclf		; set first column
  2573  eaa1 60                 	rts
  2574                          ; -------------------------------------------------------------------------------------------------
  2575                          ; EAA2 Bell on (esc-g)
  2576  eaa2 a900               bellon: lda #0			; $00 = bell on
  2577                          ; EAA4 Bell off (esc-h)
  2578  eaa4 8d8b03             bellof:sta bellmd		; store bell flag - any value = bell off
  2579                          ; EAA7 Not implemented escape sequences jump here
  2580  eaa7 60                 notimp: rts
  2581                          ; -------------------------------------------------------------------------------------------------
  2582                          ; EAA8 Auto insert mode off (esc-c)
  2583  eaa8 a900               autoff: lda #$00
  2584  eaaa 2c                 	!byte $2C		; skips next instruction
  2585                          ; EAAB Auto insert mode on (esc-a)
  2586  eaab a9ff               auton:  lda #$FF
  2587  eaad 8d8603             	sta insflg
  2588  eab0 60                 	rts
  2589                          ; -------------------------------------------------------------------------------------------------
  2590                          ; EAB1 Keyboard tables
  2591                          normtb:					; keyboard table - no control/no shift
  2592                          	;line 0: f1, escape, tab, null, shift, control
  2593  eab1 e01b09ff0001       	 !byte $e0,$1b,$09,$ff,$00,$01
  2594                          	;line 1: f2, 1, q, a, z, null
  2595  eab7 e13151415aff       	 !byte $e1,$31,$51,$41,$5a,$ff
  2596                          	;line 2: f3, 2, w, s, x, c
  2597  eabd e23257535843       	 !byte $e2,$32,$57,$53,$58,$43
  2598                          	;line 3: f4, 3, e, d, f, v
  2599  eac3 e33345444656       	 !byte $e3,$33,$45,$44,$46,$56
  2600                          	;line 4: f5, 4, r, t, g, b
  2601  eac9 e43452544742       	 !byte $e4,$34,$52,$54,$47,$42
  2602                          	;line 5: f6, 5, 6, y, h, n
  2603  eacf e5353659484e       	 !byte $e5,$35,$36,$59,$48,$4e
  2604                          	;line 6: f7, 7, u, j, m, space
  2605  ead5 e637554a4d20       	 !byte $e6,$37,$55,$4a,$4d,$20
  2606                          	;line 7: f8, 8, i, k, "," , .
  2607  eadb e738494b2c2e       	 !byte $e7,$38,$49,$4b,$2c,$2e
  2608                          	;line 8: f9, 9, o, l, ;, /
  2609  eae1 e8394f4c3b2f       	 !byte $e8,$39,$4f,$4c,$3b,$2f
  2610                          	;line 9: f10, 0, -, p, [, '
  2611  eae7 e9302d505b27       	 !byte $e9,$30,$2d,$50,$5b,$27
  2612                          	;line 10: down cursor, =, _, ], return, pi
  2613  eaed 113d5f5d0dde       	 !byte $11,$3d,$5f,$5d,$0d,$de
  2614                          	;line 11: up cur, lt cur, rt cur, del, cmdr, null
  2615  eaf3 919d1d1402ff       	 !byte $91,$9d,$1d,$14,$02,$ff
  2616                          	;line 12: home, ?, 7, 4, 1, 0
  2617  eaf9 133f37343130       	 !byte $13,$3f,$37,$34,$31,$30
  2618                          	;line 13: rvs on, cancel, 8, 5, 2, decimal point
  2619  eaff 12043835322e       	 !byte $12,$04,$38,$35,$32,$2e
  2620                          	;line 14: graphic, mult, 9, 6, 3, 00
  2621  eb05 8e2a39363330       	 !byte $8e,$2a,$39,$36,$33,$30
  2622                          	;line 15: stop, div, subtr, add, enter, null
  2623  eb0b 032f2d2b0dff       	 !byte $03,$2f,$2d,$2b,$0d,$ff
  2624                          
  2625                          shfttb:					; keyboard table - shift only & text mode
  2626                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2627  eb11 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2628                          	;line 1: f12, !, q, a, z, null
  2629  eb17 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2630                          	;line 2: f13, @, w, s, x, c
  2631  eb1d ec40d7d3d8c3       	 !byte $ec,$40,$d7,$d3,$d8,$c3
  2632                          	;line 3: f14, #, e, d, f, v
  2633  eb23 ed23c5c4c6d6       	 !byte $ed,$23,$c5,$c4,$c6,$d6
  2634                          	;line 4: f15, $, r, t, g, b
  2635  eb29 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2636                          	;line 5: f16, %, ^, y, h, n
  2637  eb2f ef255ed9c8ce       	 !byte $ef,$25,$5e,$d9,$c8,$ce
  2638                          	;line 6: f17, &, u, j, m, shifted space
  2639  eb35 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2640                          	;line 7: f18, *, i, k, <, >
  2641  eb3b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2642                          	;line 8: f19, (, o, l, :, ?
  2643  eb41 f228cfcc3a3f       	 !byte $f2,$28,$cf,$cc,$3a,$3f
  2644                          	;line 9: f20, ), -, p, [, "
  2645  eb47 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2646                          	;line 10: down cursor, +, pound sign, ], sht return, pi
  2647  eb4d 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2648                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2649  eb53 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2650                          	;line 12: clear/home, ?, 7, 4, 1, 0
  2651  eb59 933f37343130       	 !byte $93,$3f,$37,$34,$31,$30
  2652                          	;line 13: rvs off, shft cancel, 8, 5, 2, decimal point
  2653  eb5f 92843835322e       	 !byte $92,$84,$38,$35,$32,$2e
  2654                          	;line 14: text, mult, 9, 6, 3, 00
  2655  eb65 0e2a39363330       	 !byte $0e,$2a,$39,$36,$33,$30
  2656                          	;line 15: run, div, subtr, add, enter, null
  2657  eb6b 832f2d2b8dff       	 !byte $83,$2f,$2d,$2b,$8d,$ff
  2658                          
  2659                          shftgr:					; keyboard table - shift only & graphic mode
  2660                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2661  eb71 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2662                          	;line 1: f12, !, gr, gr, gr, null
  2663  eb77 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2664                          	;line 2: f13, @, gr, gr, gr, gr
  2665  eb7d ec40d7d3d8c0       	 !byte $ec,$40,$d7,$d3,$d8,$c0
  2666                          	;line 3: f14, #, gr, gr, gr, gr
  2667  eb83 ed23c5c4c6c3       	 !byte $ed,$23,$c5,$c4,$c6,$c3
  2668                          	;line 4: f15, $, gr, gr, gr, gr
  2669  eb89 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2670                          	;line 5: f16, %, ^, gr, gr, gr
  2671  eb8f ef255ed9c8dd       	 !byte $ef,$25,$5e,$d9,$c8,$dd
  2672                          	;line 6: f17, &, gr, gr, gr, shifted space
  2673  eb95 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2674                          	;line 7: f18, *, gr, gr, <, >
  2675  eb9b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2676                          	;line 8: f19, (, gr, gr, :, ?
  2677  eba1 f228cfd63a3f       	 !byte $f2,$28,$cf,$d6,$3a,$3f
  2678                          	;line 9: f20, ), -, gr, [, "
  2679  eba7 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2680                          	;line 10: down cursor, +, pound, ], shifted return, pi
  2681  ebad 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2682                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2683  ebb3 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2684                          	;line 12: clear/home,gr,gr,gr,gr,gr
  2685  ebb9 93b7b4b1b0ad       	 !byte $93,$b7,$b4,$b1,$b0,$ad
  2686                          	;line 13: rvs off,gr,gr,gr,gr,gr
  2687  ebbf 92b8b5b2aebd       	 !byte $92,$b8,$b5,$b2,$ae,$bd
  2688                          	;line 14: text,gr,gr,gr,gr,00
  2689  ebc5 0eb9b6b3db30       	 !byte $0e,$b9,$b6,$b3,$db,$30
  2690                          	;line 15: run,gr,gr,gr,gr,null
  2691  ebcb 83afaaab8dff       	 !byte $83,$af,$aa,$ab,$8d,$ff
  2692                          
  2693                          ctltbl:					; keyboard table... control characters, any mode
  2694                          	;line 0: null,null,null,null,null
  2695  ebd1 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2696                          	;line 1: null,gr,q,a,z,null
  2697  ebd7 ffa111011aff       	 !byte $ff,$a1,$11,$01,$1a,$ff
  2698                          	;line 2: null,gr,w,s,x,c
  2699  ebdd ffa217131803       	 !byte $ff,$a2,$17,$13,$18,$03
  2700                          	;line 3: null,gr,e,d,f,v
  2701  ebe3 ffa305040616       	 !byte $ff,$a3,$05,$04,$06,$16
  2702                          	;line 4: null,gr,r,t,g,b
  2703  ebe9 ffa412140702       	 !byte $ff,$a4,$12,$14,$07,$02
  2704                          	;line 5: null,gr,gr,y,h,n
  2705  ebef ffa5a719080e       	 !byte $ff,$a5,$a7,$19,$08,$0e
  2706                          	;line 6: null,gr,u,j,m,null
  2707  ebf5 ffbe150a0dff       	 !byte $ff,$be,$15,$0a,$0d,$ff
  2708                          	;line 7: null,gr,i,k,gr,null
  2709  ebfb ffbb090bceff       	 !byte $ff,$bb,$09,$0b,$ce,$ff
  2710                          	;line 8: null,gr,o,l,gr,null
  2711  ec01 ffbf0f0cdcff       	 !byte $ff,$bf,$0f,$0c,$dc,$ff
  2712                          	;line 9: null,gr,gr,p,gr,gr
  2713  ec07 ffacbc10cca8       	 !byte $ff,$ac,$bc,$10,$cc,$a8
  2714                          	;line 10: null,gr,gr,gr,null,gr
  2715  ec0d ffa9dfbaffa6       	 !byte $ff,$a9,$df,$ba,$ff,$a6
  2716                          	;line 11: null,null,null,null,null,null
  2717  ec13 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2718                          	;line 12: null,lred,yell,mag,wht,blk
  2719  ec19 ff969e9c0590       	 !byte $ff,$96,$9e,$9c,$05,$90
  2720                          	;line 13: null,lblue,org,grn,red,null
  2721  ec1f ff99811e1cff       	 !byte $ff,$99,$81,$1e,$1c,$ff
  2722                          	;line 14: null,gray3,brown,blue,cyan,null
  2723  ec25 ff9a951f9fff       	 !byte $ff,$9a,$95,$1f,$9f,$ff
  2724                          	;line 15: null,gray1,gray2,purple,null,null
  2725  ec2b ff97989bffff       	 !byte $ff,$97,$98,$9b,$ff,$ff
  2726                          ; -------------------------------------------------------------------------------------------------
  2727                          ; EC31 <SHIFT> <RUN/STOP> String: DLOAD "*" + RUN
  2728  ec31 44cc222a0d         runtb:  !pet "d",$CC,$22,"*",$0D	; dL"* <RETURN>
  2729  ec36 52554e0d           	!pet "run",$0D          	; run <RETURN>
  2730                          ; -------------------------------------------------------------------------------------------------
  2731                          ;****** address of screen lines ******
  2732                          linz0	= scnram
  2733                          linz1	= linz0+llen
  2734                          linz2	= linz1+llen
  2735                          linz3	= linz2+llen
  2736                          linz4	= linz3+llen
  2737                          linz5	= linz4+llen
  2738                          linz6	= linz5+llen
  2739                          linz7	= linz6+llen
  2740                          linz8	= linz7+llen
  2741                          linz9	= linz8+llen
  2742                          linz10	= linz9+llen
  2743                          linz11	= linz10+llen
  2744                          linz12	= linz11+llen
  2745                          linz13	= linz12+llen
  2746                          linz14	= linz13+llen
  2747                          linz15	= linz14+llen
  2748                          linz16	= linz15+llen
  2749                          linz17	= linz16+llen
  2750                          linz18	= linz17+llen
  2751                          linz19	= linz18+llen
  2752                          linz20	= linz19+llen
  2753                          linz21	= linz20+llen
  2754                          linz22	= linz21+llen
  2755                          linz23	= linz22+llen
  2756                          linz24	= linz23+llen
  2757                          
  2758                          ;****** screen lines lo byte table ******
  2759  ec3a 00                 ldtb2:	!byte <linz0
  2760  ec3b 28                 	!byte <linz1
  2761  ec3c 50                 	!byte <linz2
  2762  ec3d 78                 	!byte <linz3
  2763  ec3e a0                 	!byte <linz4
  2764  ec3f c8                 	!byte <linz5
  2765  ec40 f0                 	!byte <linz6
  2766  ec41 18                 	!byte <linz7
  2767  ec42 40                 	!byte <linz8
  2768  ec43 68                 	!byte <linz9
  2769  ec44 90                 	!byte <linz10
  2770  ec45 b8                 	!byte <linz11
  2771  ec46 e0                 	!byte <linz12
  2772  ec47 08                 	!byte <linz13
  2773  ec48 30                 	!byte <linz14
  2774  ec49 58                 	!byte <linz15
  2775  ec4a 80                 	!byte <linz16
  2776  ec4b a8                 	!byte <linz17
  2777  ec4c d0                 	!byte <linz18
  2778  ec4d f8                 	!byte <linz19
  2779  ec4e 20                 	!byte <linz20
  2780  ec4f 48                 	!byte <linz21
  2781  ec50 70                 	!byte <linz22
  2782  ec51 98                 	!byte <linz23
  2783  ec52 c0                 	!byte <linz24
  2784                          
  2785                          ;****** screen lines hi byte table ******
  2786  ec53 d0                 ldtb1:	!byte >linz0
  2787  ec54 d0                 	!byte >linz1
  2788  ec55 d0                 	!byte >linz2
  2789  ec56 d0                 	!byte >linz3
  2790  ec57 d0                 	!byte >linz4
  2791  ec58 d0                 	!byte >linz5
  2792  ec59 d0                 	!byte >linz6
  2793  ec5a d1                 	!byte >linz7
  2794  ec5b d1                 	!byte >linz8
  2795  ec5c d1                 	!byte >linz9
  2796  ec5d d1                 	!byte >linz10
  2797  ec5e d1                 	!byte >linz11
  2798  ec5f d1                 	!byte >linz12
  2799  ec60 d2                 	!byte >linz13
  2800  ec61 d2                 	!byte >linz14
  2801  ec62 d2                 	!byte >linz15
  2802  ec63 d2                 	!byte >linz16
  2803  ec64 d2                 	!byte >linz17
  2804  ec65 d2                 	!byte >linz18
  2805  ec66 d2                 	!byte >linz19
  2806  ec67 d3                 	!byte >linz20
  2807  ec68 d3                 	!byte >linz21
  2808  ec69 d3                 	!byte >linz22
  2809  ec6a d3                 	!byte >linz23
  2810  ec6b d3                 	!byte >linz24
  2811                          ; -------------------------------------------------------------------------------------------------
  2812                          ; EC6C Dispatch table (control codes $00-$1F, $80-$9F)
  2813  ec6c 21e3               ctable:	!word cuser-1
  2814  ec6e 01e6               	!word chkcol-1		; -/orange
  2815  ec70 21e3               	!word cuser-1
  2816  ec72 c8e5               	!word stprun-1		; stop/run
  2817  ec74 a2e6               	!word ce-1		; cancel
  2818  ec76 01e6               	!word chkcol-1		; white/-
  2819  ec78 9fe7               	!word unused-1		; unused - from rev.01/02 editor (uses $03BF)
  2820  ec7a 74e6               	!word bell-1		; bell/-
  2821  ec7c 21e3               	!word cuser-1
  2822  ec7e 6ae3               	!word tabit-1		; tab/tab toggle
  2823  ec80 21e3               	!word cuser-1
  2824  ec82 21e3               	!word cuser-1
  2825  ec84 21e3               	!word cuser-1
  2826  ec86 a4e3               	!word nxt1-1		; return or shifted return
  2827  ec88 50e2               	!word ctext-1		; text/graphic mode
  2828  ec8a 87ea               	!word window-1		; set top/bottom
  2829  ec8c 01e6               	!word chkcol-1		; -/black
  2830  ec8e 24e3               	!word cdnup-1		; cursor down/up
  2831  ec90 54e3               	!word rvsf-1		; rvs on/off
  2832  ec92 5ae3               	!word homclr-1		; home/clr
  2833  ec94 5ae5               	!word delins-1		; delete/insert character
  2834  ec96 01e6               	!word chkcol-1		; -/brown
  2835  ec98 01e6               	!word chkcol-1		; -/lightred
  2836  ec9a 01e6               	!word chkcol-1		; -/gray1
  2837  ec9c 01e6               	!word chkcol-1		; -/gray2
  2838  ec9e 01e6               	!word chkcol-1		; -/lightgreen
  2839  eca0 01e6               	!word chkcol-1		; -/lightblue
  2840  eca2 01e6               	!word chkcol-1		; -/gray3
  2841  eca4 01e6               	!word chkcol-1		; red/purple
  2842  eca6 41e3               	!word crtlf-1		; cursor right/left
  2843  eca8 01e6               	!word chkcol-1		; green/yellow
  2844  ecaa 01e6               	!word chkcol-1		; blue/cyan
  2845                          ; -------------------------------------------------------------------------------------------------
  2846                          ; ECAC Length of function key texts
  2847  ecac 03                 keylen: !byte key2-key1
  2848  ecad 03                 	!byte key3-key2
  2849  ecae 03                 	!byte key4-key3
  2850  ecaf 03                 	!byte key5-key4
  2851  ecb0 0d                 	!byte key6-key5
  2852  ecb1 0d                 	!byte key7-key6
  2853  ecb2 04                 	!byte key8-key7
  2854  ecb3 09                 	!byte key9-key8
  2855  ecb4 03                 	!byte key10-key9
  2856  ecb5 03                 	!byte keyend-key10                   ; 57 bytes keydef-text
  2857                          
  2858                          !ifdef STANDARD_FKEYS{          ; ********** Standard F-keys **********
  2859                          ; ECB6 Function key definitions
  2860                          keydef:
  2861                          key1:	!pet "print"                    ; F1
  2862                          key2:	!pet "list"                     ; F2
  2863                          key3:	!pet "dload",$22                ; F3
  2864                          key4:	!pet "dsave",$22                ; F4
  2865                          key5:	!pet "dopen"                    ; F5
  2866                          key6:	!pet "dclose"                   ; F6
  2867                          key7:	!pet "copy"                     ; F7
  2868                          key8:	!pet "directory"                ; F8
  2869                          key9:	!pet "scratch"                  ; F9
  2870                          key10:	!pet "chr$("                    ; F10
  2871                          ; -------------------------------------------------------------------------------------------------
  2872                          } else{                         ; ********** F-keys PATCH **********
  2873                          ; ECB6 Function key definitions
  2874                          keydef:
  2875  ecb6 52d50d             key1:	!pet "rU",$0d                   ; F1
  2876  ecb9 4cc90d             key2:	!pet "lI",$0d                   ; F2
  2877  ecbc 44cc22             key3:	!pet "dL",$22                   ; F3
  2878  ecbf 44d322             key4:	!pet "dS",$22                   ; F4
  2879  ecc2 4fd0382c382c3135...key5:	!pet "oP8,8,15,",$22,"cd:"      ; F5
  2880  eccf 4fd0392c392c3135...key6:	!pet "oP9,9,15,",$22,"cd:"      ; F6
  2881  ecdc 4443cc0d           key7:	!pet "dcL",$0d                  ; F7
  2882  ece0 4449d244304f4e55...key8:	!pet "diRd0onu8"                ; F8
  2883  ece9 53c322             key9:	!pet "sC",$22                   ; F9
  2884  ecec 48c522             key10:	!pet "hE",$22                   ; F10
  2885                          }
  2886                          ; Function key definitions
  2887                          ;keydef:
  2888                          ;key1:	!pet "run"                      ; F1
  2889                          ;key2:	!pet "list"                     ; F2
  2890                          ;key3:	!pet "dload",$22                ; F3
  2891                          ;key4:	!pet "dsave",$22                ; F4
  2892                          ;key5:	!pet "print"                    ; F5
  2893                          ;key6:	!pet "chr$("                    ; F6
  2894                          ;key7:	!pet "bank"                     ; F7
  2895                          ;key8:	!pet "directory"                ; F8
  2896                          ;key9:	!pet "scratch",$22              ; F9
  2897                          ;key10:	!pet "header",$22               ; F10
  2898                          ;}
  2899                          keyend:
  2900                          ; -------------------------------------------------------------------------------------------------
  2901                          ; ECEF bits  -  bit position table
  2902  ecef 8040201008040201   bits:	!byte $80,$40,$20,$10,$08,$04,$02,$01
  2903                          ; -------------------------------------------------------------------------------------------------
  2904                          ; ECF7 VIC initialization table regs $11-$21 
  2905  ecf7 1b00000000080040   tvic:	!byte $1B,$00,$00,$00,$00,$08,$00,$40
  2906  ecff 8f00000000000003   	!byte $8F,$00,$00,$00,$00,$00,$00,EXTCOL
  2907  ed07 01                 	!byte BGRCOL
  2908                          ; -------------------------------------------------------------------------------------------------
  2909                          ; ED08 Extended editor vector table (copied to $3B5)
  2910  ed08 f6e9               edvect:	!word dokeyf
  2911  ed0a 41e6               	!word wrvram
  2912  ed0c 50e6               	!word wrcram
  2913  ed0e 36e0               	!word nofunc
  2914  ed10 36e0               	!word nofunc
  2915                          ; -------------------------------------------------------------------------------------------------
  2916                          ; ED12 Color control code table
  2917                          ; blk,wht,red,cyan,magenta,grn,blue,yellow
  2918  ed12 90051c9f9c1e1f9e   coltab:	!byte $90,$05,$1C,$9F,$9C,$1E,$1F,$9E
  2919                          ; org,brown,lred,gray1,gray2,lgreen,lblue,gray3
  2920  ed1a 8195969798999a9b   	!byte $81,$95,$96,$97,$98,$99,$9A,$9B
  2921                          ; rsr modify for vic-40 system			*** Just for fun from rev.1 c64-kernal rev.1 ;) ***
  2922                          ; rsr 12/31/81 add 8 more colors
  2923                          ; -------------------------------------------------------------------------------------------------
  2924                          ; ED22 checksum byte
  2925  ed22 28                 cksume	!byte CHECKSUM		; e-page checksum
  2926                          ; -------------------------------------------------------------------------------------------------
  2927                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  2928                          ;**************************************************
  2929                          ; patch1 - checks for a single line window
  2930                          ;          aborts if so...
  2931                          ;**************************************************
  2932  ed23 a6dd               patch1:	ldx scbot		; check
  2933  ed25 e4dc               	cpx sctop
  2934  ed27 d002               	bne patcha		; no...pass through old code
  2935  ed29 68                 	pla			; abort
  2936  ed2a 68                 	pla
  2937  ed2b 2c8703             patcha:	bit scrdis		; restore patched area (test for scrolling mode)
  2938  ed2e 60                 	rts
  2939                          }
  2940                          ; -------------------------------------------------------------------------------------------------
  2941                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  2942                          ; patch 4a-2 - make space for clear insert flag
  2943                          patch4a2:
  2944  ed2f 20e9e4             	jsr fistrt		; find begining of line
  2945  ed32 a900               	lda #0
  2946  ed34 60                 	rts
  2947                          ; -------------------------------------------------------------------------------------------------
  2948                          ; patch 4a-4 - remember bootom line no
  2949                          patch4a4:
  2950  ed35 05d0               	ora crsw		; NO SENSE - a already 3
  2951  ed37 85d0               	sta crsw		; fake a carriage return
  2952  ed39 a5dd               	lda scbot
  2953  ed3b 8d8403             	sta lintmp		; remember bootom line no
  2954  ed3e a5df               	lda scrt		; moved to patch to make space
  2955  ed40 60                 	rts
  2956                          ; -------------------------------------------------------------------------------------------------
  2957                          ; patch 4a-3 - RS232 output
  2958                          patch4a3:
  2959  ed41 9003               	bcc p4a3		; -> check output ?
  2960  ed43 4c5af9             	jmp errorx		; moved to patch to make space
  2961  ed46 08                 p4a3:	php
  2962  ed47 48                 	pha
  2963  ed48 a5a0               	lda sa
  2964  ed4a 2901               	and #$01
  2965  ed4c f00a               	beq p4a3x		; no output
  2966  ed4e a69e               	ldx la
  2967  ed50 20c9ff             	jsr ckout		; open channel
  2968  ed53 20ccff             	jsr clrch		; close channel
  2969  ed56 a6a6               	ldx ribuf
  2970  ed58 68                 p4a3x:	pla
  2971  ed59 28                 	plp
  2972  ed5a 60                 	rts
  2973                          }
  2974                          ; -------------------------------------------------------------------------------------------------
  2975                          !ifdef SYSPATCH{
  2976                          poker	= $1B
  2977                          dfbank	= $0257
  2978                          getpin	= $B4B9
  2979                          *= $EDDC
  2980  eddc 20b9b4             csys:	jsr getpin      ; get positive integer
  2981  eddf a501               	lda i6509
  2982  ede1 48                 	pha
  2983  ede2 ad5702             	lda dfbank 	; current bank
  2984  ede5 c90f               	cmp #$F
  2985  ede7 f00b               	beq fligm
  2986  ede9 a61b               	ldx poker
  2987  edeb a41c               	ldy poker+1
  2988  eded 206cff             	jsr newsys
  2989                          csysrz	=*-1
  2990  edf0 68                 	pla
  2991  edf1 8501               	sta $1
  2992  edf3 60                 	rts
  2993                          fligm:
  2994  edf4 a9ed               	lda #>csysrz    ;push return address
  2995  edf6 48                 	pha
  2996  edf7 a9ef               	lda #<csysrz
  2997  edf9 48                 	pha
  2998  edfa 6c1b00             	jmp (poker)
  2999  edfd 60                 	rts	
  3000                          }
  3001                          ; ****************************************** KERNAL ***********************************************
  3002                          ; ##### monitor #####
  3003                          !zone kernal
  3004                          ;************************************************
  3005                          ;* kernal monitor                               *
  3006                          ;*                                              *
  3007                          ;* entry via call (jmp) or breakpoint (brk)     *
  3008                          ;* ---functions---                              *
  3009                          ;* <:>      alter memory                        *
  3010                          ;* <;>      alter registers                     *
  3011                          ;* <r>      display registers                   *
  3012                          ;* <m>      display memory                      *
  3013                          ;* <g>      start execution of code             *
  3014                          ;* <l>      load memory                         *
  3015                          ;* <s>      save memory                         *
  3016                          ;* <v>      view segment                        *
  3017                          ;* <@>      disk command                        *
  3018                          ;* <x>      warm start basic                    *
  3019                          ;* <u>      set default disk unit               *
  3020                          ;* <other>  load and execute from disk          *
  3021                          ;*                                              *
  3022                          ;* for syntax & semantics see cbm kernal manual *
  3023                          ;* copyright (c) 1981 by cbm                    *
  3024                          ;************************************************
  3025                          ; EE00 Reset Entry
  3026                          *= kernal+$E00
  3027                          
  3028                          ; ***** Warm start entry *******
  3029  ee00 20fef9             monon:	jsr ioinit		; get i/o
  3030  ee03 20b1fb             	jsr restor		; vectors
  3031  ee06 2004e0             	jsr jcint		; screen editor
  3032                          
  3033                          ; ***** Cold start entry ******
  3034  ee09 20ccff             monoff:	jsr clrch		; clear channels
  3035  ee0c a95a               	lda #winit		; waste two bytes so timc=60950
  3036  ee0e a200               	ldx #<monon		; point reset vectors at monitor on
  3037  ee10 a0ee               	ldy #>monon
  3038  ee12 20d9fb             	jsr vreset
  3039  ee15 58                 	cli			; release irq's
  3040                          
  3041                          ; ***** Call entry *****
  3042  ee16 a9c0               timc:	lda #$40+$80
  3043  ee18 8d6103             	sta msgflg		; error+messages on
  3044  ee1b a940               	lda #ms34-ms1		; call entry
  3045  ee1d 85bd               	sta tmpc
  3046  ee1f d010               	bne b3			; branch always
  3047                          
  3048                          ; ***** Break entry *****
  3049  ee21 20ccff             timb:	jsr clrch		; clr channels
  3050  ee24 a953               	lda #ms36-ms1		; break entry
  3051  ee26 85bd               	sta tmpc
  3052  ee28 d8                 	cld 
  3053                          
  3054                          ; Save .y,.x,.a,flags, and pc
  3055  ee29 a205               	ldx #5
  3056                          ; EE2B Pop registers from stack and save them
  3057  ee2b 68                 b1:	pla
  3058  ee2c 95ae               	sta pch,x
  3059  ee2e ca                 	dex
  3060  ee2f 10fa               	bpl b1
  3061                          
  3062  ee31 a501               b3:	lda i6509		; save indirection segment
  3063  ee33 85b5               	sta xi6509
  3064  ee35 ad0003             	lda cinv
  3065  ee38 85b8               	sta invl		; save irq low
  3066  ee3a ad0103             	lda cinv+1
  3067  ee3d 85b7               	sta invh		; save irq high
  3068                          
  3069  ee3f ba                 	tsx
  3070  ee40 86b4               	stx sp			; save original sp
  3071  ee42 58                 	cli			; clear ints
  3072  ee43 a908               	lda #8			; set disk default to 8
  3073  ee45 85bf               	sta ddisk
  3074                          
  3075  ee47 a4bd               b5:	ldy tmpc		; message code
  3076  ee49 2023f2             	jsr spmsg		; print break/call
  3077                          
  3078  ee4c a952               	lda #'r'		; display regs on entry
  3079  ee4e d023               	bne s0			; branch always
  3080                          ; EE50 ***** Error entry *****
  3081                          
  3082  ee50 201eef             erropr:	jsr outqst
  3083  ee53 68                 	pla
  3084  ee54 68                 	pla
  3085                          
  3086                          ; ***** Command interpreter entry *****
  3087                          strtm1=*-1
  3088  ee55 a9c0               	lda #$40+$80
  3089  ee57 8d6103             	sta msgflg		; i/o messages to screen
  3090  ee5a a900               	lda #<buf		; put filename at bottom of basic buffer
  3091  ee5c 8590               	sta fnadr
  3092  ee5e a902               	lda #>buf
  3093  ee60 8591               	sta fnadr+1
  3094  ee62 a90f               	lda #irom
  3095  ee64 8592               	sta fnadr+2
  3096  ee66 2021ef             	jsr crlf
  3097                          
  3098  ee69 20cfff             st1:	jsr basin		; read command
  3099                          
  3100  ee6c c920               	cmp #' '
  3101  ee6e f0f9               	beq st1			; span blanks
  3102  ee70 6c1e03             	jmp (usrcmd)		; user indirect for monitor
  3103                          ; -------------------------------------------------------------------------------------------------
  3104                          ; EE73 Command interpreter
  3105  ee73 a200               s0:	ldx #0
  3106  ee75 869d               	stx fnlen
  3107  ee77 a8                 	tay			; save current command
  3108                          
  3109                          ; Put return address for commands on stack
  3110  ee78 a9ee               	lda #>strtm1
  3111  ee7a 48                 	pha
  3112  ee7b a954               	lda #<strtm1
  3113  ee7d 48                 	pha
  3114                          
  3115  ee7e 98                 	tya			; current command in .a
  3116                          
  3117  ee7f ddd1ee             s1:	cmp cmds,x		; is it this one?
  3118  ee82 d010               	bne s2			; notit
  3119                          
  3120  ee84 8d6603             	sta savx		; save current command
  3121                          
  3122                          ; Indirect jmp from table
  3123  ee87 bdd2ee             	lda cmds+1,x
  3124  ee8a 85b9               	sta tmp0
  3125  ee8c bdd3ee             	lda cmds+2,x
  3126  ee8f 85ba               	sta tmp0+1
  3127  ee91 6cb900             	jmp (tmp0)
  3128                          ; -------------------------------------------------------------------------------------------------
  3129                          ; EE94 Each table entry is 3 long---skip to next
  3130  ee94 e8                 s2:	inx
  3131  ee95 e8                 	inx
  3132  ee96 e8                 	inx
  3133  ee97 e024               	cpx #cmdend-cmds
  3134  ee99 90e4               	bcc s1			; loop for all commands
  3135                          
  3136                          ; Command not in table...look on disk.
  3137                          ; Command name can be any length and have parameters.
  3138  ee9b a200               	ldx #0			; length to zero
  3139  ee9d c90d               s3:	cmp #$D			; end of name?
  3140  ee9f f00d               	beq s4			; yes...
  3141  eea1 c920               	cmp #' '		; blank?
  3142  eea3 f009               	beq s4			; yes
  3143  eea5 9d0002             	sta buf,x
  3144  eea8 20cfff             	jsr basin		; get next
  3145  eeab e8                 	inx			; count char
  3146  eeac d0ef               	bne s3			; and continue
  3147                          
  3148  eeae 85bd               s4:	sta tmpc
  3149  eeb0 8a                 	txa			; count
  3150  eeb1 f01d               	beq s6			; is zero
  3151                          
  3152  eeb3 859d               	sta fnlen
  3153  eeb5 a940               	lda #$40
  3154  eeb7 8d6103             	sta msgflg		; messages off
  3155  eeba a5bf               	lda ddisk
  3156  eebc 859f               	sta fa			; will use default disk
  3157  eebe a90f               	lda #irom		; commands only load to rom segment !!!***
  3158  eec0 8501               	sta i6509		; turn indirect to rom segment
  3159  eec2 a2ff               	ldx #$FF
  3160  eec4 a0ff               	ldy #$FF
  3161  eec6 20d5ff             	jsr load		; try to load command
  3162  eec9 b005               	bcs s6			; bad load...
  3163                          
  3164  eecb a5bd               	lda tmpc		; pass last character
  3165  eecd 6c9900             	jmp (stal)		; go do it
  3166                          
  3167  eed0 60                 s6:	rts
  3168                          ; -------------------------------------------------------------------------------------------------
  3169                          ; EED1 Command table
  3170  eed1 3a                 cmds:	!pet ':'		; alter memory
  3171  eed2 f7ef               	!word altm
  3172  eed4 3b                 	!pet ';'		; alter registers
  3173  eed5 c5ef               	!word altr
  3174  eed7 52                 	!pet 'r'		; display registers
  3175  eed8 41ef               	!word dsplyr
  3176  eeda 4d                 	!pet 'm'		; display memory
  3177  eedb 84ef               	!word dsplym
  3178  eedd 47                 	!pet 'g'		; start execution
  3179  eede 14f0               	!word go
  3180  eee0 4c                 	!pet 'l'		; load memory
  3181  eee1 43f0               	!word ld
  3182  eee3 53                 	!pet 's'		; save memory
  3183  eee4 43f0               	!word ld
  3184  eee6 56                 	!pet 'v'		; view segment
  3185  eee7 dfef               	!word view
  3186  eee9 40                 	!pet '@'		; disk command (alternate)
  3187  eeea 68f1               	!word disk
  3188  eeec 5a                 	!pet 'z'		; transfer to 2nd microprocessor
  3189  eeed 72ff               	!word ipcgov		; ipcgo vector
  3190  eeef 58                 	!pet 'x'		; warm start basic
  3191  eef0 f5ee               	!word xeit
  3192  eef2 55                 	!pet 'u'		; default disk unit set
  3193  eef3 ebef               	!word unitd
  3194                          cmdend:
  3195                          ; -------------------------------------------------------------------------------------------------
  3196                          ; EEF5 Exit 'x'
  3197  eef5 68                 xeit:	pla			; remove command return from stack
  3198  eef6 68                 	pla
  3199  eef7 78                 	sei			; disable interrupts...all warm start code expects
  3200  eef8 6cf803             	jmp (evect)		; go warmstart language
  3201                          ; -------------------------------------------------------------------------------------------------
  3202                          ; EEFB Move tmp0/tmp0+1 to PC memory location
  3203  eefb a5b9               putp:	lda tmp0		; move tmp0 to pch,pcl
  3204  eefd 85af               	sta pcl
  3205  eeff a5ba               	lda tmp0+1
  3206  ef01 85ae               	sta pch
  3207  ef03 60                 	rts
  3208                          ; -------------------------------------------------------------------------------------------------
  3209                          ; EF04 Set tmp0 to point to the saved regs in zero page
  3210  ef04 a9b0               setr:	lda #<flgs		; set to access regs
  3211  ef06 85b9               	sta tmp0
  3212  ef08 a900               	lda #>flgs
  3213  ef0a 85ba               	sta tmp0+1
  3214  ef0c a90f               	lda #irom		; point indirect at roms
  3215  ef0e 8501               	sta i6509
  3216  ef10 a905               	lda #5
  3217  ef12 60                 	rts
  3218                          ; -------------------------------------------------------------------------------------------------
  3219                          ; EF13 Prints '.:' or '.;' before data to permit alter after 'm' or 'r' command
  3220                          
  3221  ef13 48                 altrit: pha			; preserve alter character
  3222  ef14 2021ef             	jsr crlf
  3223  ef17 68                 	pla
  3224  ef18 20d2ff             	jsr bsout
  3225                          
  3226  ef1b a920               space:  lda #' '		; output a space
  3227  ef1d 2c                 	!byte $2C		; skip two bytes
  3228                          
  3229  ef1e a93f               outqst: lda #'?'		; output question
  3230  ef20 2c                 	!byte $2C		; skip two bytes
  3231                          
  3232  ef21 a90d               crlf:   lda #$D		; do carriage return
  3233  ef23 4cd2ff             	jmp bsout
  3234                          ; -------------------------------------------------------------------------------------------------
  3235                          ; EF26 Data for register display heading
  3236  ef26 0d2020             regk:	!pet cr,"  "		; 3 spaces
  3237  ef29 2050432020495251...	!pet " pc "," irq "," sr ac xr yr sp"
  3238                          ; -------------------------------------------------------------------------------------------------
  3239                          ; EF41 Display register function 'r'
  3240  ef41 a200               dsplyr:	ldx #0
  3241  ef43 bd26ef             d2:	lda regk,x
  3242  ef46 20d2ff             	jsr bsout		; print heading
  3243  ef49 e8                 	inx
  3244  ef4a e01b               	cpx #dsplyr-regk	; max length
  3245  ef4c d0f5               	bne d2
  3246  ef4e a93b               	lda #';'
  3247  ef50 2013ef             	jsr altrit		; allow alter after display
  3248  ef53 a6ae               	ldx pch
  3249  ef55 a4af               	ldy pcl
  3250  ef57 20f9f0             	jsr wroa		; print program counter
  3251  ef5a 201bef             	jsr space
  3252  ef5d a6b7               	ldx invh
  3253  ef5f a4b8               	ldy invl
  3254  ef61 20f9f0             	jsr wroa		; print irq vector
  3255  ef64 2004ef             	jsr setr		; set to print .p,.a,.x,.y,.s
  3256                          
  3257                          ; display memory subroutine
  3258  ef67 85bd               dm:	sta tmpc		; byte count
  3259  ef69 a000               	ldy #0			; indirect index
  3260  ef6b 849d               	sty fnlen		; fnlen is zero-page crossing flag...
  3261  ef6d 201bef             dm1:	jsr space		; space tween bytes
  3262  ef70 b1b9               	lda (tmp0),y
  3263  ef72 20fef0             	jsr wrob		; write byte of memory
  3264                          
  3265                          ; increment indirect
  3266  ef75 e6b9               	inc tmp0
  3267  ef77 d006               	bne dm2
  3268  ef79 e6ba               	inc tmp0+1
  3269  ef7b d002               	bne dm2			; no zero page crossing
  3270  ef7d c69d               	dec fnlen		; fnlen<>0 is flag
  3271                          
  3272  ef7f c6bd               dm2:	dec tmpc		; count bytes
  3273  ef81 d0ea               	bne dm1			; until zero
  3274  ef83 60                 	rts
  3275                          ; -------------------------------------------------------------------------------------------------
  3276                          ; EF84 Display memory function 'm'
  3277  ef84 2026f1             dsplym:	jsr rdoa		; read start adr
  3278  ef87 b039               	bcs arrn		; ...err if no sa
  3279  ef89 2016f1             	jsr t2t2		; sa to tmp2
  3280                          
  3281                          ; allow user to type just one address
  3282  ef8c 2026f1             	jsr rdoa		; read end adr
  3283  ef8f 9008               	bcc dsp123		; good...no default
  3284                          
  3285  ef91 a5bb               	lda tmp2
  3286  ef93 85b9               	sta tmp0		; default low byte
  3287  ef95 a5bc               	lda tmp2+1
  3288  ef97 85ba               	sta tmp0+1		; default hi byte
  3289                          
  3290  ef99 2016f1             dsp123:	jsr t2t2		; sa to tmp0, ea to tmp2
  3291  ef9c 20e1ff             dsp1:	jsr stop		; stop key?
  3292  ef9f f020               	beq beqs1		; yes...break list
  3293                          
  3294  efa1 a93a               	lda #':'
  3295  efa3 2013ef             	jsr altrit		; allow alter
  3296  efa6 a6ba               	ldx tmp0+1
  3297  efa8 a4b9               	ldy tmp0
  3298  efaa 20f9f0             	jsr wroa		; write start address
  3299                          
  3300  efad a908               	lda #8			; count of bytes
  3301  efaf 2067ef             	jsr dm			; display bytes
  3302                          
  3303  efb2 a59d               	lda fnlen		; check for zero-crossing
  3304  efb4 d00b               	bne beqs1		; yup....
  3305  efb6 38                 	sec
  3306  efb7 a5bb               	lda tmp2
  3307  efb9 e5b9               	sbc tmp0
  3308  efbb a5bc               	lda tmp2+1
  3309  efbd e5ba               	sbc tmp0+1
  3310  efbf b0db               	bcs dsp1		; end >= start
  3311                          
  3312  efc1 60                 beqs1:	rts			; a.o.k. exit
  3313                          
  3314  efc2 4c50ee             arrn:	jmp erropr		; syntax error jump
  3315                          ; -------------------------------------------------------------------------------------------------
  3316                          ; EFC5 Alter register function ';'
  3317  efc5 2026f1             altr:	jsr rdoa		; read new pc
  3318  efc8 b0f8               	bcs arrn		; ...no address=error
  3319                          
  3320  efca 20fbee             	jsr putp		; alter pc
  3321                          
  3322  efcd 2026f1             	jsr rdoa		; read new irq
  3323  efd0 b0f0               	bcs arrn		; ...no address=error
  3324                          
  3325  efd2 a5b9               	lda tmp0
  3326  efd4 85b8               	sta invl		; alter irq vector
  3327  efd6 a5ba               	lda tmp0+1
  3328  efd8 85b7               	sta invh
  3329                          
  3330  efda 2004ef             	jsr setr		; set to alter r's
  3331  efdd d01f               	bne a4			; branch always
  3332                          ; -------------------------------------------------------------------------------------------------
  3333                          ; EFDF View a segment (point indirect) 'v'
  3334  efdf 2033f1             view:	jsr rdob		; get a byte
  3335  efe2 b0de               	bcs arrn		; ...if none...error
  3336  efe4 c910               	cmp #16			; range 0-15
  3337  efe6 b0da               	bcs arrn		; to large no modulo
  3338  efe8 8501               	sta i6509
  3339  efea 60                 	rts
  3340                          ; -------------------------------------------------------------------------------------------------
  3341                          ; EFEB Unit default for disk 'u'
  3342  efeb 2033f1             unitd:	jsr rdob		; get a byte
  3343  efee b0d2               	bcs arrn		; ...if none...error
  3344  eff0 c920               	cmp #32			; range 0-31
  3345  eff2 b0ce               	bcs arrn		; to large no modulo
  3346  eff4 85bf               	sta ddisk
  3347  eff6 60                 	rts
  3348                          ; -------------------------------------------------------------------------------------------------
  3349                          ; EFF7 Alter memory - read adr and data ':'
  3350  eff7 2026f1             altm:	jsr rdoa		; read alter adr
  3351  effa b0c6               	bcs arrn		; ...if none...error
  3352                          
  3353  effc a908               	lda #8			; allow 8 bytes change
  3354                          
  3355                          ; common code for ':' and ';'
  3356  effe 85bd               a4:	sta tmpc		; number of bytes to change
  3357                          
  3358  f000 2033f1             a5:	jsr rdob		; read byte
  3359  f003 b00e               	bcs a9
  3360                          
  3361  f005 a000               	ldy #0
  3362  f007 91b9               	sta (tmp0),y		; store it away
  3363                          
  3364                          ; increment store address
  3365  f009 e6b9               	inc tmp0
  3366  f00b d002               	bne a6
  3367  f00d e6ba               	inc tmp0+1
  3368                          
  3369  f00f c6bd               a6:	dec tmpc		; count byte
  3370  f011 d0ed               	bne a5			; until zero
  3371  f013 60                 a9:	rts
  3372                          ; -------------------------------------------------------------------------------------------------
  3373                          ; F014 Start execution function 'g'
  3374  f014 2062f1             go:	jsr rdoc		; see if default
  3375  f017 f008               	beq g1			; yes...pc is address
  3376  f019 2026f1             	jsr rdoa		; no...get new addr
  3377  f01c b022               	bcs errl		; ...none=error
  3378  f01e 20fbee             	jsr putp		; move addr to p.c.
  3379                          
  3380  f021 a6b4               g1:	ldx sp
  3381  f023 9a                 	txs			; orig or new sp value to sp
  3382                          
  3383  f024 78                 	sei			; prevent disaster
  3384                          
  3385  f025 a5b7               	lda invh
  3386  f027 8d0103             	sta cinv+1		; set up irq vector
  3387  f02a a5b8               	lda invl
  3388  f02c 8d0003             	sta cinv
  3389  f02f a5b5               	lda xi6509		; and indirection register
  3390  f031 8501               	sta i6509
  3391                          
  3392                          ; get flags,pch,pcl,.a,.x,.y
  3393  f033 a200               	ldx #0
  3394  f035 b5ae               g2:	lda pch,x
  3395  f037 48                 	pha			; everybody on stack
  3396  f038 e8                 	inx
  3397  f039 e006               	cpx #6
  3398  f03b d0f8               	bne g2
  3399                          
  3400                          ; interrupt return sets everybody up from data on stack
  3401  f03d 4cb3fc             	jmp prend
  3402                          
  3403  f040 4c50ee             errl:	jmp erropr
  3404                          ; -------------------------------------------------------------------------------------------------
  3405                          ; F043 Load ram function 'l' and 's'
  3406                          ;  *note - load/save reset indirect to rom
  3407  f043 a001               ld:	ldy #1
  3408  f045 849f               	sty fa			; default device #1
  3409  f047 88                 	dey			; .y=0 to count name length
  3410  f048 a9ff               	lda #$FF		; default no move load
  3411  f04a 85b9               	sta tmp0
  3412  f04c 85ba               	sta tmp0+1
  3413  f04e a501               	lda i6509		; save indirect for seg address
  3414  f050 85be               	sta t6509
  3415  f052 a90f               	lda #irom		; indirect to rom for filename
  3416  f054 8501               	sta i6509
  3417                          
  3418  f056 2062f1             l1:	jsr rdoc		; default?
  3419  f059 f01c               	beq l5			; yes...try load
  3420                          
  3421  f05b c920               	cmp #' '
  3422  f05d f0f7               	beq l1			; span blanks
  3423                          
  3424  f05f c922               	cmp #$22		; string next?
  3425  f061 d0dd               l2:	bne errl		; no file name...
  3426                          
  3427  f063 2062f1             l3:	jsr rdoc		; get character of name
  3428  f066 f00f               	beq l5			; end...asssume load
  3429                          
  3430  f068 c922               	cmp #$22		; end of string?
  3431  f06a f01d               	beq l8			; yes...could still be 'l' or 's'
  3432                          
  3433  f06c 9190               	sta (fnadr),y		; store name
  3434  f06e e69d               	inc fnlen
  3435  f070 c8                 	iny
  3436  f071 c010               	cpy #16			; max file name length
  3437                          
  3438  f073 f0cb               l4:	beq errl		; file name too long
  3439  f075 d0ec               	bne l3			; branch always
  3440                          ; see if we got a load
  3441  f077 ad6603             l5:	lda savx		; get last command
  3442  f07a c94c               	cmp #'l'
  3443  f07c d0e3               	bne l2			; no..not a load..error
  3444                          
  3445  f07e a5be               	lda t6509		; get segment to load to
  3446  f080 290f               	and #irom		; mask off verify bit
  3447  f082 a6b9               	ldx tmp0
  3448  f084 a4ba               	ldy tmp0+1
  3449  f086 4cd5ff             	jmp load		; yes...do load
  3450                          
  3451  f089 2062f1             l8:	jsr rdoc		; more stuff?
  3452  f08c f0e9               	beq l5			; no...defualt load
  3453                          
  3454  f08e c92c               	cmp #','		; delimeter?
  3455  f090 d0cf               l9:	bne l2			; no...bad syntax
  3456                          
  3457  f092 2033f1             	jsr rdob		; yes...get next parm
  3458  f095 b05f               	bcs l15			; ...error if none
  3459                          
  3460  f097 859f               	sta fa
  3461                          
  3462  f099 2062f1             	jsr rdoc		; more parms?
  3463  f09c f0d9               	beq l5			; no...default load
  3464                          
  3465  f09e c92c               	cmp #','		; delimeter?
  3466  f0a0 d0ee               l12:	bne l9			; no...bad syntax
  3467                          
  3468  f0a2 2033f1             	jsr rdob		; segment byte ?
  3469  f0a5 b04f               	bcs l15			; ...must have
  3470  f0a7 c910               	cmp #16			; 00-0f allowed
  3471  f0a9 b04b               	bcs l15			; too big...
  3472  f0ab 85be               	sta t6509
  3473  f0ad 859b               	sta stas		; prep segment
  3474  f0af 2026f1             	jsr rdoa
  3475  f0b2 b042               	bcs l15
  3476                          ; set up start save address
  3477  f0b4 a5b9               	lda tmp0
  3478  f0b6 8599               	sta stal
  3479  f0b8 a5ba               	lda tmp0+1
  3480  f0ba 859a               	sta stah
  3481                          
  3482  f0bc 2062f1             	jsr rdoc		; delimeter?
  3483  f0bf f0b6               	beq l5			; cr, do load
  3484  f0c1 c92c               	cmp #','
  3485  f0c3 d031               	bne l15			; no delim
  3486                          
  3487  f0c5 2033f1             	jsr rdob		; get segment byte
  3488  f0c8 b02c               	bcs l15			; ...must have
  3489  f0ca c910               	cmp #16			; allow only 00-0f
  3490  f0cc b028               	bcs l15			; too big...
  3491  f0ce 8598               	sta eas			; prep segment
  3492  f0d0 2026f1             	jsr rdoa		; try to read end address
  3493  f0d3 b021               	bcs l15			; ...must have
  3494                          
  3495                          ; set up end save address
  3496  f0d5 a5b9               	lda tmp0
  3497  f0d7 8596               	sta eal
  3498  f0d9 a5ba               	lda tmp0+1
  3499  f0db 8597               	sta eah
  3500                          
  3501  f0dd 20cfff             l20:	jsr basin
  3502  f0e0 c920               	cmp #' '
  3503  f0e2 f0f9               	beq l20			; span blanks
  3504                          
  3505  f0e4 c90d               	cmp #cr
  3506  f0e6 d0b8               l14:	bne l12			; missing cr at end
  3507  f0e8 ad6603             	lda savx 		; was command save?
  3508  f0eb c953               	cmp #'s'
  3509  f0ed d0f7               	bne l14			; no...load can't have parms
  3510                          
  3511  f0ef a299               	ldx #<stal		; get addresses of params for save
  3512  f0f1 a096               	ldy #<eal
  3513  f0f3 4cd8ff             	jmp save
  3514                          
  3515  f0f6 4c50ee             l15:	jmp erropr
  3516                          ; -------------------------------------------------------------------------------------------------
  3517                          ; F0F9 Write adr from tmp0 stores
  3518  f0f9 8a                 wroa:   txa			; hi-byte
  3519  f0fa 20fef0             	jsr wrob
  3520  f0fd 98                 	tya			; low-byte
  3521                          ; F0FE Write byte --- a = byte
  3522                          ; unpack byte data into two ascii characters. a=byte; x,a=chars
  3523  f0fe 48                 wrob:   pha
  3524  f0ff 4a                 	lsr
  3525  f100 4a                 	lsr
  3526  f101 4a                 	lsr
  3527  f102 4a                 	lsr
  3528  f103 200af1             	jsr ascii		; convert to ascii
  3529  f106 aa                 	tax
  3530  f107 68                 	pla
  3531  f108 290f               	and #$0F
  3532                          ; F10A Convert nybble in a to ascii and print it
  3533  f10a 18                 ascii:	clc
  3534  f10b 69f6               	adc #$F6
  3535  f10d 9002               	bcc asc1
  3536  f10f 6906               	adc #$06
  3537  f111 693a               asc1:	adc #$3A
  3538  f113 4cd2ff             	jmp bsout
  3539                          ; -------------------------------------------------------------------------------------------------
  3540                          ; F116 Exchange temporaries
  3541  f116 a202               t2t2:	ldx #2
  3542  f118 b5b8               t2t21:	lda tmp0-1,x
  3543  f11a 48                 	pha
  3544  f11b b5ba               	lda tmp2-1,x
  3545  f11d 95b8               	sta tmp0-1,x 
  3546  f11f 68                 	pla
  3547  f120 95ba               	sta tmp2-1,x
  3548  f122 ca                 	dex
  3549  f123 d0f3               	bne t2t21
  3550  f125 60                 	rts
  3551                          ; -------------------------------------------------------------------------------------------------
  3552                          ; F126 Read hex adr,return hi in tmp0, lo in tmp0+1,and cy=1, if sp cy=0
  3553  f126 2033f1             rdoa:	jsr rdob		; read 2-char byte
  3554  f129 b007               	bcs rdoa2		; space
  3555  f12b 85ba               	sta tmp0+1
  3556  f12d 2033f1             	jsr rdob
  3557  f130 85b9               	sta tmp0
  3558  f132 60                 rdoa2:	rts
  3559                          ; -------------------------------------------------------------------------------------------------
  3560                          ; F133 Read hex byte and return in a and cy=0 if sp cy=1
  3561  f133 a900               rdob:	lda #0			; space
  3562  f135 8d0001             	sta bad			; read next char
  3563  f138 2062f1             	jsr rdoc
  3564  f13b f019               	beq rdob4		; fail on cr
  3565  f13d c920               	cmp #' '		; blank?
  3566  f13f f0f2               	beq rdob		; span blanks...
  3567                          
  3568  f141 2057f1             	jsr hexit		; convert to hex nybble
  3569  f144 0a                 	asl
  3570  f145 0a                 	asl
  3571  f146 0a                 	asl
  3572  f147 0a                 	asl
  3573  f148 8d0001             	sta bad
  3574  f14b 2062f1             	jsr rdoc		; 2nd char assumed hex
  3575  f14e f006               	beq rdob4		; fail on cr
  3576  f150 2057f1             	jsr hexit
  3577  f153 0d0001             	ora bad
  3578                          
  3579  f156 60                 rdob4:	rts
  3580                          ; -------------------------------------------------------------------------------------------------
  3581                          ; F157 Convert char in A into hex value
  3582  f157 c93a               hexit:  cmp #$3A
  3583  f159 08                 	php			; save flags
  3584  f15a 290f               	and #$0F
  3585  f15c 28                 	plp
  3586  f15d 9002               	bcc hex09		; 0-9
  3587  f15f 6908               	adc #8			; alpha add 8+cy=9
  3588  f161 60                 hex09:	rts
  3589                          ; -------------------------------------------------------------------------------------------------
  3590                          ; F162 Get character and test for cr
  3591  f162 20cfff             rdoc:	jsr basin
  3592  f165 c90d               	cmp #$D			; is it a cr
  3593  f167 60                 	rts			; return with flags
  3594                          ; -------------------------------------------------------------------------------------------------
  3595                          ; F168 Send disk command or read status '@'
  3596  f168 a900               disk:	lda #0			; clear status @ i/o begin
  3597  f16a 859c               	sta status
  3598  f16c 859d               	sta fnlen		; filename length of zero...
  3599                          
  3600  f16e a6bf               	ldx ddisk		; get default disk
  3601  f170 a00f               	ldy #$0F		; open command channel
  3602  f172 204ffb             	jsr setlfs		; .a-0 temporary channel #
  3603  f175 18                 	clc
  3604  f176 20c0ff             	jsr open		; open a real channel
  3605  f179 b044               	bcs disk30		; exit if bad return
  3606                          
  3607  f17b 2062f1             	jsr rdoc		; see if status check
  3608  f17e f01d               	beq disk20		; yes
  3609                          
  3610  f180 48                 	pha
  3611  f181 a200               	ldx #0
  3612  f183 20c9ff             	jsr ckout		; set up as output
  3613  f186 68                 	pla
  3614  f187 b036               	bcs disk30		; bad status return
  3615  f189 9003               	bcc disk15		; no...ok
  3616                          
  3617  f18b 20cfff             disk10:	jsr basin		; get a character
  3618  f18e c90d               disk15:	cmp #$D			; see if end
  3619  f190 08                 	php			; save for later
  3620  f191 20d2ff             	jsr bsout		; out to floppy
  3621  f194 a59c               	lda status
  3622  f196 d023               	bne disk28		; bad status returned
  3623  f198 28                 	plp			; end?
  3624  f199 d0f0               	bne disk10		; no...continue
  3625  f19b f022               	beq disk30		; yes...floppy done
  3626                          
  3627  f19d 2021ef             disk20:	jsr crlf
  3628  f1a0 a200               	ldx #0
  3629  f1a2 20c6ff             	jsr chkin		; tell floppy to speak
  3630  f1a5 b018               	bcs disk30		; bad device
  3631                          
  3632  f1a7 20cfff             disk25:  jsr basin		; get a character
  3633  f1aa c90d               	cmp #$0D
  3634  f1ac 08                 	php			; save test for later
  3635  f1ad 20d2ff             	jsr bsout		; out to screen
  3636  f1b0 a59c               	lda status		; check for bad basin
  3637  f1b2 29bf               	and #$FF-$40		; remove eoi bit
  3638  f1b4 d005               	bne disk28		; report bad status
  3639  f1b6 28                 	plp			; end?
  3640  f1b7 d0ee               	bne disk25		; no...
  3641  f1b9 f004               	beq disk30		; yes...floppy done
  3642                          
  3643  f1bb 68                 disk28:	pla			; clean up...
  3644  f1bc 204cf9             disk29:	jsr error5		; report error #5 for bad device
  3645  f1bf 20ccff             disk30:	jsr clrch		; clean up
  3646  f1c2 a900               	lda #0
  3647  f1c4 18                 	clc			; just remove from table
  3648  f1c5 4cc3ff             	jmp close
  3649                          ; -------------------------------------------------------------------------------------------------
  3650                          ; F1C8 Unused
  3651  f1c8 ea                 	nop
  3652  f1c9 ea                 	nop
  3653                          ; -------------------------------------------------------------------------------------------------
  3654                          ; F1CA ##### messages #####
  3655  f1ca 0d492f4f20455252...ms1:	!pet $0D,"i/o error ",$A3
  3656  f1d6 0d53454152434849...ms5:	!pet $0D,"searching",$A0
  3657  f1e1 464f52a0           ms6:	!pet "for",$A0
  3658                          ;ms7:	!pet $0D,"press play on tap",$C5
  3659                          ;ms8:	!pet "press record & play on tap",$C5
  3660  f1e5 0d4c4f4144494ec7   ms10:	!pet $0D,"loadin",$C7
  3661  f1ed 0d534156494e47a0   ms11:	!pet $0D,"saving",$A0
  3662  f1f5 0d56455249465949...ms21:	!pet $0D,"verifyin",$C7
  3663  f1ff 0d464f554e44a0     ms17:	!pet $0D,"found",$A0
  3664  f206 0d4f4b8d           ms18:	!pet $0D,"ok",$8D
  3665  f20a 0d2a2a204d4f4e49...ms34:	!pet $0D,"** monitor 1.0 **",$8D
  3666  f21d 0d42524541cb       ms36:	!pet $0D,"brea",$CB
  3667                          ; -------------------------------------------------------------------------------------------------
  3668                          ; F223 Print message to screen only if output enabled
  3669  f223 2c6103             spmsg:	bit msgflg		; printing messages?
  3670  f226 100d               	bpl msg10		; no...
  3671  f228 b9caf1             msg:	lda ms1,y
  3672  f22b 08                 	php
  3673  f22c 297f               	and #$7F
  3674  f22e 20d2ff             	jsr bsout
  3675  f231 c8                 	iny
  3676  f232 28                 	plp
  3677  f233 10f3               	bpl msg
  3678  f235 18                 msg10:	clc
  3679  f236 60                 	rts
  3680                          ; -------------------------------------------------------------------------------------------------
  3681                          ; ##### ieee #####
  3682                          ; F237 Command ieee-488 device to talk
  3683  f237 0940               ntalk:	ora #tlkr		; make a talk adr
  3684  f239 d002               	bne list1		; always go to list1
  3685                          ; command ieee-488 device to listen
  3686  f23b 0920               nlistn:	ora #lstnr		; make a listen adr
  3687                          
  3688  f23d 48                 list1:	pha			; save device and talk/listen
  3689                          
  3690  f23e a93f               	lda #tddb		; set control for atn/data out
  3691  f240 8d03de             	sta tpi1+ddpa
  3692                          
  3693  f243 a9ff               	lda #$FF		; set direction for transmitt *
  3694  f245 8d00dc             	sta cia+pra		; set data   *
  3695  f248 8d02dc             	sta cia+ddra		; set data direction out   *
  3696  f24b a9fa               	lda #$FF-dc-ren		; enable transmitt
  3697  f24d 8d00de             	sta tpi1+pa
  3698  f250 a5aa               	lda c3po		; get ieee flags
  3699  f252 101b               	bpl list2		; if data in buffer
  3700                          
  3701  f254 ad00de             	lda tpi1+pa		; send eoi
  3702  f257 29df               	and #$FF-eoi
  3703  f259 8d00de             	sta tpi1+pa
  3704                          
  3705  f25c a5ab               	lda bsour		; get byte to send
  3706  f25e 20c0f2             	jsr tbyte		; send last character
  3707                          
  3708  f261 a5aa               	lda c3po		; clear byte in buffer flag
  3709  f263 297f               	and #$FF-dibf
  3710  f265 85aa               	sta c3po
  3711                          
  3712  f267 ad00de             	lda tpi1+pa		; clear eoi
  3713  f26a 0920               	ora #eoi
  3714  f26c 8d00de             	sta tpi1+pa
  3715                          
  3716  f26f ad00de             list2:	lda tpi1+pa		; assert atn
  3717  f272 29f7               	and #$FF-atn
  3718  f274 8d00de             	sta tpi1+pa
  3719                          
  3720  f277 68                 	pla			; get talk/listen address
  3721  f278 4cc0f2             	jmp tbyte
  3722                          ; -------------------------------------------------------------------------------------------------
  3723                          ; F27B Send secondary address after listen
  3724  f27b 20c0f2             nsecnd:	jsr tbyte		; send it      
  3725                          ; release attention after listen       
  3726                          scat1:
  3727  f27e ad00de             scatn:	lda tpi1+pa		; de-assert atn
  3728  f281 0908               	ora #atn
  3729  f283 8d00de             	sta tpi1+pa
  3730  f286 60                 	rts
  3731                          ; -------------------------------------------------------------------------------------------------
  3732                          ; F287 Talk second address
  3733  f287 20c0f2             ntksa:	jsr tbyte		; send secondary address
  3734                          
  3735  f28a a939               tkatn:	lda #$FF-nrfd-ndac-te-ren ; pull nrfd and ndac low
  3736  f28c 2d00de             	and tpi1+pa
  3737                          ; exit entry for untalk/unlisten
  3738  f28f 8d00de             setlns:	sta tpi1+pa
  3739  f292 a9c7               	lda #rddb		; set control lines for input
  3740  f294 8d03de             	sta tpi1+ddpa
  3741  f297 a900               	lda #$00		; set data lines for recieve
  3742  f299 8d02dc             	sta cia+ddra
  3743  f29c f0e0               	beq scatn
  3744                          ; -------------------------------------------------------------------------------------------------
  3745                          ; F29E Buffered output to ieee-488
  3746  f29e 48                 nciout:	pha			; save data
  3747  f29f a5aa               	lda c3po		; get ieee flags
  3748  f2a1 1007               	bpl ci1			; if no data in buffer
  3749  f2a3 a5ab               	lda bsour		; get data in buffer
  3750  f2a5 20c0f2             	jsr tbyte		; transmit byte
  3751  f2a8 a5aa               	lda c3po		; get ieee flags
  3752                          
  3753  f2aa 0980               ci1:	ora #dibf		; set data in buffer flag
  3754  f2ac 85aa               	sta c3po
  3755                          
  3756  f2ae 68                 	pla			; get new data
  3757  f2af 85ab               	sta bsour
  3758  f2b1 60                 	rts
  3759                          ; -------------------------------------------------------------------------------------------------
  3760                          ; F2B2 Send untalk command on ie
  3761  f2b2 a95f               nuntlk:	lda #utlkr		; untalk command
  3762  f2b4 d002               	bne unls1		; always
  3763                          
  3764                          ; send unlisten command on ieee-488
  3765  f2b6 a93f               nunlsn:	lda #ulstn		; unlisten command
  3766  f2b8 203df2             unls1:	jsr list1		; send it
  3767  f2bb a9f9               	lda #$FF-te-ren		; set for recieve all lines high
  3768  f2bd 4c8ff2             	jmp setlns		; go setup proper exit state
  3769                          ; -------------------------------------------------------------------------------------------------
  3770                          ; tbyte -- output byte onto ieee bus.
  3771                          ;   entry a = data byte to be output.
  3772                          ;   uses a register. 1 byte of stack space.
  3773                          ; F2C0
  3774  f2c0 49ff               tbyte:	eor #$FF	; compliment data
  3775  f2c2 8d00dc             	sta cia+pra
  3776                          
  3777  f2c5 ad00de             	lda tpi1+pa
  3778  f2c8 0912               	ora #dav+te		; say data not valid, te=data out
  3779  f2ca 8d00de             	sta tpi1+pa
  3780                          
  3781  f2cd 2c00de             	bit tpi1+pa		; test nrfd & ndac in high state
  3782  f2d0 5009               	bvc tby2		; either nrfd or ndac low => ok
  3783  f2d2 1007               	bpl tby2
  3784                          
  3785  f2d4 a980               tby1:	lda #nodev		; set no-device bit in status
  3786  f2d6 206efb             	jsr udst
  3787  f2d9 d030               	bne tby7		; always exit
  3788                          
  3789  f2db ad00de             tby2:	lda tpi1+pa
  3790  f2de 10fb               	bpl tby2		; if nrfd is high
  3791                          
  3792  f2e0 29ef               	and #$FF-dav
  3793  f2e2 8d00de             	sta tpi1+pa
  3794                          
  3795  f2e5 2076f3             tby3:	jsr timero		; set timeout
  3796  f2e8 9001               	bcc tby4		; c-clear means first time through
  3797  f2ea 38                 tby3t:	sec			; c-set is second time
  3798                          
  3799  f2eb 2c00de             tby4:	bit tpi1+pa
  3800  f2ee 7013               	bvs tby6		; if ndac hi
  3801  f2f0 ad0ddc             	lda cia+icr
  3802  f2f3 2902               	and #$02		; timer b posistion (cia)
  3803  f2f5 f0f4               	beq tby4		; if no timeout
  3804  f2f7 ad5e03             	lda timout		; timeout selection flag
  3805  f2fa 30e9               	bmi tby3		; no - loop
  3806  f2fc 90ec               	bcc tby3t		; wait full 64us
  3807                          
  3808  f2fe a901               tby5:	lda #toout		; set timeout on output in status
  3809  f300 206efb             	jsr udst		; update status
  3810                          
  3811  f303 ad00de             tby6:	lda tpi1+pa		; release dav
  3812  f306 0910               	ora #dav
  3813  f308 8d00de             	sta tpi1+pa
  3814                          
  3815  f30b a9ff               tby7:	lda #$FF		; release data bus
  3816  f30d 8d00dc             	sta cia+pra		; bus failure exit
  3817  f310 60                 	rts
  3818                          ; -------------------------------------------------------------------------------------------------
  3819                          ; rbyte -- input byte from ieee bus.
  3820                          ;   uses a register. 1 byte of stack space.
  3821                          ;   exit a = input data byte.
  3822                          ; F311
  3823                          nacptr:	; ********************************
  3824                          nrbyte:
  3825  f311 ad00de             	lda tpi1+pa		; set control lines
  3826  f314 29b9               	and #$FF-te-ndac-ren	; pull ndac low, te=data in
  3827  f316 0981               	ora #nrfd+dc		; say read for data
  3828  f318 8d00de             	sta tpi1+pa
  3829                          
  3830  f31b 2076f3             rby1:	jsr timero		; return c-clear for cbmii
  3831  f31e 9001               	bcc rby2		; c-clear is first time through
  3832  f320 38                 rby1t:	sec			; c-set is second time through
  3833                          
  3834  f321 ad00de             rby2:	lda tpi1+pa		; get ieee control lines
  3835  f324 2910               	and #dav
  3836  f326 f01e               	beq rby4		; if data available
  3837  f328 ad0ddc             	lda cia+icr
  3838  f32b 2902               	and #$02		; timer b (cia)
  3839  f32d f0f2               	beq rby2		; if not timed out
  3840  f32f ad5e03             	lda timout		; get timeout flag
  3841  f332 30e7               	bmi rby1		; loop
  3842  f334 90ea               	bcc rby1t		; go through twice
  3843                          
  3844  f336 a902               rby3:	lda #toin		; set timeout on input in status
  3845  f338 206efb             	jsr udst
  3846  f33b ad00de             	lda tpi1+pa
  3847  f33e 293d               	and #$FF-nrfd-ndac-te	; nrfd & ndac lo on error
  3848  f340 8d00de             	sta tpi1+pa
  3849  f343 a90d               	lda #cr			; return null input
  3850  f345 60                 	rts
  3851                          ; F346
  3852  f346 ad00de             rby4:	lda tpi1+pa		; say not read for data
  3853  f349 297f               	and #$FF-nrfd
  3854  f34b 8d00de             	sta tpi1+pa
  3855  f34e 2920               	and #eoi
  3856  f350 d005               	bne rby5		; if not eoi
  3857  f352 a940               	lda #eoist		; set eoi in status
  3858  f354 206efb             	jsr udst
  3859                          
  3860  f357 ad00dc             rby5:	lda cia+pra		; get data
  3861  f35a 49ff               	eor #$FF
  3862                          
  3863  f35c 48                 rby6:	pha			; save data
  3864  f35d ad00de             	lda tpi1+pa		; say data accepted
  3865  f360 0940               	ora #ndac
  3866  f362 8d00de             	sta tpi1+pa
  3867                          
  3868  f365 ad00de             rby7:	lda tpi1+pa		; get ieee control lines
  3869  f368 2910               	and #dav
  3870  f36a f0f9               	beq rby7		; if dav high
  3871                          
  3872  f36c ad00de             	lda tpi1+pa		; say dat not accpted
  3873  f36f 29bf               	and #$FF-ndac
  3874  f371 8d00de             	sta tpi1+pa
  3875  f374 68                 	pla			; return data in a
  3876  f375 60                 	rts
  3877                          ; -------------------------------------------------------------------------------------------------
  3878                          ; F376 Set up for timeout (6526)
  3879  f376 a980               timero:	lda #$80		; set time for at least 32us (cbmii $FF)
  3880                          
  3881  f378 8d07dc             	sta cia+tbhi
  3882  f37b a911               	lda #$11		; turn on timer continous in case of other irq's
  3883  f37d 8d0fdc             	sta cia+crb
  3884  f380 ad0ddc             	lda cia+icr		; clear interrupt
  3885  f383 18                 	clc
  3886  f384 60                 	rts
  3887                          ; -------------------------------------------------------------------------------------------------
  3888                          ; F385 ##### rs232 #####
  3889  f385 4c58f9             rs232:	jmp error9		; bad device number
  3890                          ; -------------------------------------------------------------------------------------------------
  3891                          ; opn232 - open an rs-232 channel
  3892                          ;   if sa=1 then output channel
  3893                          ;   if sa=2 then input  channel
  3894                          ;   if sa=3 then bidirectional channel
  3895                          ;   if sa>128 then ascii conversion enabled
  3896                          ;
  3897                          ;   filename consists of 0-4 bytes
  3898                          ;  byte #1- control register 6551
  3899                          ;  byte #2- command register 6551
  3900                          ;  byte #3- c/r lf delay...60ths of sec   (unimplemented)
  3901                          ;  byte #4- auto c/r insert afer xx chars (unimplemented)
  3902                          ;
  3903                          ;    actions:
  3904                          ;  1. clear  rs232 status:  rsstat
  3905                          ;  2. set 6551 contrl (ctr) register
  3906                          ;  3. set 6551 command (cdr) register
  3907                          ;       cdr bits (7-4) = filename byte 2 bits (7-4)
  3908                          ;                (3-2) = 00  (xmitter off)
  3909                          ;                (1)   = 1   (receiver off)
  3910                          ;                (0)   = 0   (dtr off)
  3911                          ;  4. do buffer alocatation, if needed
  3912                          ;---------------------------------------------
  3913                          ; F388
  3914  f388 2035f4             opn232:	jsr rst232		; reset rs232 status
  3915  f38b a000               	ldy #0
  3916                          
  3917  f38d c49d               opn020:	cpy fnlen		; filename all out ?
  3918  f38f f00b               	beq opn030		; yes...
  3919                          
  3920  f391 208dfe             	jsr fnadry
  3921  f394 997603             	sta m51ctr,y
  3922  f397 c8                 	iny
  3923  f398 c004               	cpy #4			; only four bytes in all
  3924  f39a d0f1               	bne opn020
  3925                          
  3926  f39c ad7603             opn030:	lda m51ctr		; set the register
  3927  f39f 8d03dd             	sta acia+ctr
  3928  f3a2 ad7703             	lda m51cdr		; clear up conflicts
  3929  f3a5 29f2               	and #$F2
  3930  f3a7 0902               	ora #$02
  3931  f3a9 8d02dd             	sta acia+cdr		; everything off
  3932  f3ac 18                 	clc
  3933  f3ad a5a0               	lda sa			; check for buffers needed
  3934  f3af 2902               	and #$02
  3935  f3b1 f015               	beq opn045		; no input
  3936                          
  3937  f3b3 ad7d03             	lda ridbe		; set up pointers
  3938  f3b6 8d7c03             	sta ridbs
  3939  f3b9 a5a8               	lda ribuf+2		; check for allocation
  3940  f3bb 29f0               	and #$F0		; $ff not allocated flag (see alloc error codes, too)
  3941  f3bd f009               	beq opn045		; already allocated
  3942  f3bf 2003f4             	jsr req256		; request 256 bytes for storage
  3943  f3c2 85a8               	sta ribuf+2		; save starting
  3944  f3c4 86a6               	stx ribuf
  3945  f3c6 84a7               	sty ribuf+1
  3946                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  3947  f3c8 4c41ed             opn045:	jmp patch4a3		; ***** patch 4a-3 - RS232 output *****
  3948  f3cb ea                 	nop
  3949  f3cc ea                 	nop
  3950                          } else{
  3951                          opn045:	bcc opn050
  3952                          	jmp errorx
  3953                          }
  3954                          
  3955  f3cd 60                 opn050:	rts			; c-clr already allocated
  3956                          ; -------------------------------------------------------------------------------------------------
  3957                          ; toasci - convert cbm text code to
  3958                          ;  ascii for valid ascii ranges.
  3959                          ; entry: .a - cbm text code
  3960                          ; exit : .a - ascii code
  3961                          ;----------------------------------------
  3962                          ; F3CE
  3963  f3ce c941               toasci:	cmp #'a'		; convert $41 to $5a
  3964  f3d0 9010               	bcc toa020
  3965  f3d2 c95b               	cmp #$5B
  3966  f3d4 b002               	bcs toa010
  3967  f3d6 0920               	ora #$20		; to lower case ascii
  3968  f3d8 c9c1               toa010:	cmp #$C1		; convert $c1 to $da
  3969  f3da 9006               	bcc toa020
  3970  f3dc c9db               	cmp #$DB
  3971  f3de b002               	bcs toa020
  3972  f3e0 297f               	and #$7F		; to upper case ascii
  3973  f3e2 60                 toa020:	rts
  3974                          ; -------------------------------------------------------------------------------------------------
  3975                          ; tocbm - convert ascii code to cbm
  3976                          ;  text code for valid ascii ranges.
  3977                          ; entry: .a - ascii code
  3978                          ; exit : .a - cbm text code
  3979                          ;----------------------------------------
  3980                          ; F3E3
  3981  f3e3 c941               tocbm:	cmp #'a'		; convert upper case ascii
  3982  f3e5 9010               	bcc toc020
  3983  f3e7 c95b               	cmp #$5B
  3984  f3e9 b002               	bcs toc010
  3985  f3eb 0980               	ora #$80		; to $c1 to $da
  3986  f3ed c961               toc010:	cmp #$61		; convert lower case ascii
  3987  f3ef 9006               	bcc toc020
  3988  f3f1 c97b               	cmp #$7B
  3989  f3f3 b002               	bcs toc020
  3990  f3f5 29df               	and #$FF-$20		; to $41 - $5a
  3991  f3f7 60                 toc020:	rts
  3992                          ; -------------------------------------------------------------------------------------------------
  3993                          ; xon232 - turn 6551 transmitter on, no transmit interrupts
  3994                          ;        cdr bits(3-2) = 10
  3995                          ;            bit(1)    = 1
  3996                          ;---------------------------------------------------------------
  3997                          ; F3F8
  3998  f3f8 ad02dd             xon232:	lda acia+cdr
  3999  f3fb 0909               	ora #$09
  4000  f3fd 29fb               	and #$FB
  4001  f3ff 8d02dd             	sta acia+cdr
  4002  f402 60                 	rts
  4003                          ; -------------------------------------------------------------------------------------------------
  4004                          ; F403 req256 - request 256 bytes of space
  4005                          ;  (don't care where we get it...)
  4006  f403 a200               req256:	ldx #00
  4007  f405 a001               	ldy #01		; one page = 256 bytes
  4008                          ; -------------------------------------------------------------------------------------------------
  4009                          ; alocat - alocatate space
  4010                          ;  entry:
  4011                          ; *  .a- if .a=$ff then don't care what segment
  4012                          ; *  .a- if .a=$80 then we want bottom of memory
  4013                          ; *  .a- if .a=$40 then we want top of memory
  4014                          ; *  .a- if .a=$0x then we need segment x
  4015                          ;    .x- low # of bytes needed
  4016                          ;    .y- high # of bytes needed
  4017                          ;
  4018                          ;  exit :
  4019                          ;    c-clr  no problem alocatating space
  4020                          ;     .a,.x,.y is start address of alocatated space
  4021                          ;    c-set  problem with alocatation
  4022                          ;     if .a =$ff then alocatation refused (cannot cross segment boundrys)
  4023                          ; *   if .a =$8x then bottom of memory needs to be changed
  4024                          ;     if .a =$4x then top of memory needs to be changed
  4025                          ; *   if .a =$c0 then bottom>top  !! fatal error !!
  4026                          ;     return to language
  4027                          ;
  4028                          ; *=> not implemented yet  10/30/81 rsr (only top alocatation)
  4029                          ;-----------------------------------------------------------------------
  4030                          ; F407
  4031                          alocat:
  4032  f407 8a                 tttop:	txa			; calc new hiadr
  4033  f408 38                 	sec
  4034  f409 49ff               	eor #$FF
  4035  f40b 6d5503             	adc hiadr		; sub low from end of system RAM
  4036  f40e aa                 	tax
  4037  f40f 98                 	tya
  4038  f410 49ff               	eor #$FF
  4039  f412 6d5603             	adc hiadr+1		; sub high
  4040  f415 a8                 	tay
  4041  f416 ad5703             	lda hiadr+2		; load highest system RAM bank
  4042  f419 b006               	bcs top010
  4043  f41b a9ff               refuse:	lda #$FF		; allocation refused...crossed boundry
  4044  f41d 0940               topbad:	ora #$40		; want top of memory changed
  4045  f41f 38                 	sec			; C=1 Not enough memory available 
  4046  f420 60                 	rts			; return unsuccessful
  4047                          
  4048  f421 cc5c03             top010:	cpy memsiz+1		; compare new high address with user memory high
  4049  f424 90f7               	bcc topbad		; branch if new high lower = not enough memory alocatatable
  4050  f426 d005               	bne topxit		; branch to memoryok if new high > 
  4051  f428 ec5b03             	cpx memsiz		; if higbyte equal compare low
  4052  f42b 90f0               	bcc topbad		; branch if lower = not enough memory alocatatable
  4053  f42d 8e5503             topxit:	stx hiadr		; store new end of system memory ($)
  4054  f430 8c5603             	sty hiadr+1
  4055  f433 18                 	clc
  4056  f434 60                 	rts
  4057                          ; -------------------------------------------------------------------------------------------------
  4058                          ; rst232 - reset rs232 and dcd/dsr status
  4059                          ;          note, the dcd and dsr bits of rsstat reflect whether a
  4060                          ;          dsr or dcd error occured since the last time the user
  4061                          ;          examined rsstat.
  4062                          ;          dcdsr has the dcd/dsr states prior to their last state
  4063                          ;          changes.
  4064                          ;-----------------------------------------------------------------
  4065                          ; F435
  4066  f435 08                 rst232:	php
  4067  f436 78                 	sei			; disable ints
  4068  f437 ad01dd             	lda acia+srsn
  4069  f43a 2960               	and #$60
  4070  f43c 8d7a03             	sta rsstat
  4071  f43f 8d7b03             	sta dcdsr
  4072  f442 28                 	plp
  4073  f443 60                 	rts
  4074                          ; -------------------------------------------------------------------------------------------------
  4075                          ; ##### channelio #####
  4076                          ;*****************************************
  4077                          ;* getin -- get character from channel   *
  4078                          ;*      channel is determined by dfltn.  *
  4079                          ;* if device is 0, keyboard queue is     *
  4080                          ;* examined and a character removed if   *
  4081                          ;* available.  devices 1,3-31 advance to *
  4082                          ;* basin.                                *
  4083                          ;*                                       *
  4084                          ;* exit:  .a = character                 *
  4085                          ;*        cy = 1, stop key error for cas-*
  4086                          ;*                cassetes and rs232     *
  4087                          ;*           = 0, otherwise.             *
  4088                          ;*        z  = 1, if kbd and queue empty.*
  4089                          ;*****************************************
  4090                          ; F444
  4091  f444 a5a1               ngetin:	lda dfltn		; check device
  4092  f446 d00c               	bne gn10		; not keyboard
  4093                          
  4094  f448 a5d1               	lda ndx			; queue index
  4095  f44a 05d6               	ora kyndx		; check function key que
  4096  f44c f053               	beq gn20		; nobody there...exit
  4097                          
  4098  f44e 78                 	sei
  4099  f44f 2007e0             	jsr jlp2		; go remove a character
  4100  f452 18                 	clc
  4101  f453 60                 	rts
  4102                          
  4103                          ; Check for input from device 2 = RS232
  4104  f454 c902               gn10:	cmp #2			; is it rs-232
  4105  f456 f003               	beq gn232
  4106  f458 4ccfff             	jmp basin		; no...use basin
  4107                          
  4108                          ; getin RS232
  4109  f45b 8c6503             gn232:	sty xsav		; save .y...
  4110  f45e 8e6603             	stx savx		; ..and .x
  4111  f461 ac7c03             	ldy ridbs		; get last byte address
  4112  f464 cc7d03             	cpy ridbe		; see if buffer emptyy
  4113  f467 d016               	bne gn15		; rs232 buffer not empty...
  4114                          
  4115  f469 ad02dd             	lda acia+cdr		; make sure receiver is on
  4116  f46c 29fd               	and #$FD
  4117  f46e 0901               	ora #$01		; bits(10) = 01 now
  4118  f470 8d02dd             	sta acia+cdr
  4119  f473 ad7a03             	lda rsstat		; set empty input buffer condition
  4120  f476 0910               	ora #$10
  4121  f478 8d7a03             	sta rsstat
  4122  f47b a900               	lda #0			; return a null byte
  4123  f47d f01c               	beq gnexit		; always
  4124                          
  4125                          ; Get one byte from RS232 input buffer
  4126  f47f ad7a03             gn15:	lda rsstat		; clear empty buffer status
  4127  f482 29ef               	and #$ef
  4128  f484 8d7a03             	sta rsstat
  4129  f487 a601               	ldx i6509
  4130  f489 a5a8               	lda ribuf+2
  4131  f48b 8501               	sta i6509		; point at buffer
  4132  f48d b1a6               	lda (ribuf),y		; get last char
  4133  f48f 8601               	stx i6509		; restore
  4134  f491 ee7c03             	inc ridbs		; inc to next posistion
  4135  f494 24a0               	bit sa			; check for ascii flag
  4136  f496 1003               	bpl gnexit		; not on...
  4137  f498 20e3f3             	jsr tocbm		; convert to cbm code
  4138  f49b ac6503             gnexit:	ldy xsav		; restore .y
  4139  f49e ae6603             	ldx savx
  4140  f4a1 18                 gn20:	clc			; good return
  4141  f4a2 60                 	rts
  4142                          ; -------------------------------------------------------------------------------------------------
  4143                          ;***************************************
  4144                          ;* basin-- input character from channel*
  4145                          ;*     input differs from get on device*
  4146                          ;* #0 function which is keyboard. the  *
  4147                          ;* screen editor makes ready an entire *
  4148                          ;* line which is passed char by char   *
  4149                          ;* up to the carriage return.  note,   *
  4150                          ;* rs232 uses getin to get each char.  *
  4151                          ;* other devices are:                  *
  4152                          ;*      0 -- keyboard                  *
  4153                          ;*      1 -- cassette #1               *
  4154                          ;*      2 -- rs232                     *
  4155                          ;*      3 -- screen                    *
  4156                          ;*   4-31 -- ieee   bus                *
  4157                          ;*                                     *
  4158                          ;* exit: cy=1, stop key error for cas- *
  4159                          ;*             settes and rs232.       *
  4160                          ;*       cy=0, otherwise.              *
  4161                          ;*                                     *
  4162                          ;*       all other errors must be de-  *
  4163                          ;*       tected by checking status !   *
  4164                          ;***************************************
  4165                          ; F4A3
  4166  f4a3 a5a1               nbasin:	lda dfltn		; check device
  4167  f4a5 d00b               	bne bn10		; is not keyboard...
  4168                          
  4169                          ; input from keyboard
  4170  f4a7 a5cb               	lda pntr		; save current...
  4171  f4a9 85ce               	sta lstp		; ... cursor column
  4172  f4ab a5ca               	lda tblx		; save current...
  4173  f4ad 85cf               	sta lsxp		; ... line number
  4174  f4af 4cbcf4             	jmp bn15		; blink cursor until return
  4175                          
  4176  f4b2 c903               bn10:	cmp #3			; is input from screen?
  4177  f4b4 d00b               	bne bn20		; no...
  4178                          
  4179                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  4180  f4b6 2035ed             	jsr patch4a4		; ***** patch 4a-4 - remember bootom line no *****
  4181  f4b9 ea                 	nop
  4182                          } else{
  4183                          	sta crsw		; fake a carriage return
  4184                          	lda scrt		; say we ended...
  4185                          }
  4186  f4ba 85d5               	sta indx		; ...up on this line
  4187  f4bc 200ae0             bn15:	jsr jloop5		; pick up characters
  4188  f4bf 18                 	clc
  4189  f4c0 60                 	rts
  4190                          
  4191  f4c1 b007               bn20:	bcs bn30		; devices >3
  4192  f4c3 c902               	cmp #2			; rs232?
  4193  f4c5 f010               	beq bn50
  4194                          
  4195  f4c7 2068fe             	jsr xtape		; go to tape indirect
  4196                          
  4197                          ; input from ieee bus
  4198  f4ca a59c               bn30:	lda status		; status from last
  4199  f4cc f004               	beq bn35		; was good
  4200  f4ce a90d               bn31:	lda #$D			; bad...all done
  4201  f4d0 18                 bn32:	clc			; valid data
  4202  f4d1 60                 bn33:	rts
  4203                          
  4204  f4d2 20a5ff             bn35:	jsr acptr		; good...handshake
  4205  f4d5 18                 	clc
  4206  f4d6 60                 	rts
  4207                          
  4208                          ; input from rs232
  4209  f4d7 20e4ff             bn50:	jsr getin		; get data
  4210  f4da b0f5               	bcs bn33		; error return
  4211  f4dc c900               	cmp #00			; non-null means good data always
  4212  f4de d0f0               	bne bn32		; have valid data
  4213  f4e0 ad7a03             	lda rsstat		; check for valid null byte
  4214  f4e3 2910               	and #$10
  4215  f4e5 f0e9               	beq bn32		; ok
  4216  f4e7 ad7a03             	lda rsstat		; buffer empty, check for errors in dsr, dcd
  4217  f4ea 2960               	and #dsrerr+dcderr
  4218  f4ec d0e0               	bne bn31		; have error...send c/r's
  4219  f4ee 20e1ff             	jsr stop		; check for stop key depressed
  4220  f4f1 d0e4               	bne bn50		; no, stay in loop 'til we get something
  4221  f4f3 38                 	sec			; .a=0, stop key error
  4222  f4f4 60                 	rts
  4223                          ; -------------------------------------------------------------------------------------------------
  4224                          ;***************************************
  4225                          ;* bsout -- out character to channel   *
  4226                          ;*     determined by variable dflto:   *
  4227                          ;*     0 -- invalid                    *
  4228                          ;*     1 -- cassette #1                *
  4229                          ;*     2 -- rs232                      *
  4230                          ;*     3 -- screen                     *
  4231                          ;*  4-31 -- ieee   bus                 *
  4232                          ;*                                     *
  4233                          ;* exit:  cy=1, stop key error for cas-*
  4234                          ;*              settes and rs232.      *
  4235                          ;*        cy=0, otherwise.             *
  4236                          ;*                                     *
  4237                          ;*       note, other errors must be de-*
  4238                          ;*       tected by checking status !   *
  4239                          ;***************************************
  4240                          ; F4F5
  4241  f4f5 48                 nbsout:	pha			; preserve .a
  4242  f4f6 a5a2               	lda dflto		; check device
  4243  f4f8 c903               	cmp #3			; is it the screen?
  4244  f4fa d006               	bne bo10		; no...
  4245                          
  4246                          ; print to crt
  4247  f4fc 68                 	pla			; restore data
  4248  f4fd 200de0             	jsr jprt		; print on crt
  4249  f500 18                 	clc
  4250  f501 60                 	rts
  4251                          
  4252  f502 9006               bo10:	bcc bo20		; device 1 or 2
  4253                          
  4254                          ; print to ieee   bus
  4255  f504 68                 	pla
  4256  f505 20a8ff             	jsr ciout
  4257  f508 18                 	clc
  4258  f509 60                 	rts
  4259                          
  4260                          ; print to cassette devices
  4261  f50a c902               bo20:	cmp #2			; rs232?
  4262  f50c f00a               	beq bo50
  4263                          
  4264  f50e 68                 	pla
  4265  f50f 2068fe             	jsr xtape		; go to tape indirect
  4266                          
  4267  f512 68                 rstbo:	pla			; restore .a (error exit for 232)
  4268  f513 9002               	bcc rstor1		; no error
  4269  f515 a900               	lda #00			; stop error if c-set
  4270  f517 60                 rstor1:	rts
  4271                          
  4272                          ; output to rs232
  4273  f518 8e6303             bo50:	stx t1			; put in a temp
  4274  f51b 8c6403             	sty t2
  4275                          
  4276  f51e ad7a03             bo55:	lda rsstat		; check for dsr,dcd errors
  4277  f521 2960               	and #$60
  4278  f523 d022               	bne bo90		; bad....
  4279                          
  4280  f525 68                 bo70:	pla			; restore data
  4281  f526 24a0               	bit sa			; check for cbm to ascii conversion
  4282  f528 1003               	bpl bo80		; none
  4283  f52a 20cef3             	jsr toasci		; convert cbm to ascii
  4284  f52d 8d00dd             bo80:	sta acia+drsn		; sending data
  4285  f530 48                 	pha
  4286                          
  4287  f531 ad7a03             bo60:	lda rsstat
  4288  f534 2960               	and #$60		; dcd,dsr errors?
  4289  f536 d00f               	bne bo90		; yes...
  4290  f538 ad01dd             bo64:	lda acia+srsn
  4291  f53b 2910               	and #$10		; transmit buffer empty?
  4292  f53d d008               	bne bo90		; yes, transmit done!
  4293  f53f 20e1ff             	jsr stop		; check for stop key
  4294  f542 d0ed               	bne bo60		; try again
  4295  f544 38                 bo66:	sec			; stop key/error return
  4296  f545 b0cb               	bcs rstbo		; exit....
  4297                          
  4298  f547 68                 bo90:	pla
  4299  f548 ae6303             	ldx t1          ;go restore
  4300  f54b ac6403             	ldy t2
  4301  f54e 18                 	clc
  4302  f54f 60                 	rts
  4303                          ; -------------------------------------------------------------------------------------------------
  4304                          ; ##### openchannel #####
  4305                          ;***************************************
  4306                          ;* nchkin -- open channel for input    *
  4307                          ;*                                     *
  4308                          ;* the number of the logical file to be*
  4309                          ;* opened for input is passed in .x.   *
  4310                          ;* chkin searches the logical file     *
  4311                          ;* to look up device and command info. *
  4312                          ;* errors are reported if the device   *
  4313                          ;* was not opened for input ,(e.g.     *
  4314                          ;* cassette write file), or the logical*
  4315                          ;* file has no reference in the tables.*
  4316                          ;* device 0, (keyboard), and device 3  *
  4317                          ;* (screen), require no table entries  *
  4318                          ;* and are handled separate.           *
  4319                          ;***************************************
  4320                          ; F550
  4321  f550 2045f6             nchkin:	jsr lookup		; see if file known
  4322  f553 f003               	beq jx310		; yup...
  4323                          
  4324  f555 4c46f9             	jmp error3		; no...file not open
  4325                          
  4326  f558 2057f6             jx310:	jsr jz100		; extract file info
  4327  f55b a59f               	lda fa
  4328  f55d f02e               	beq jx320		; is keyboard...done.
  4329                          
  4330                          ; could be screen, keyboard, or serial
  4331  f55f c903               	cmp #3
  4332  f561 f02a               	beq jx320		; is screen...done.
  4333  f563 b02c               	bcs jx330		; is serial...address it
  4334  f565 c902               	cmp #2			; rs232?
  4335  f567 d01e               	bne jx315		; no...
  4336                          
  4337                          ; rs232 channel
  4338  f569 a5a0               	lda sa
  4339  f56b 2902               	and #02			; check for input
  4340  f56d f01b               	beq jx316		; not input file
  4341  f56f 2d02dd             	and acia+cdr		; check if running
  4342  f572 f00f               	beq jx312		; is...done ?? (rceiver on => yes)
  4343  f574 49ff               	eor #$FF		; flip all bits
  4344  f576 2d02dd             	and acia+cdr		; turn on...
  4345  f579 0901               	ora #$01		; turn on dtr ;bits(10)=01
  4346  f57b 48                 	pha
  4347  f57c 2035f4             	jsr rst232		; reset rs232 status
  4348  f57f 68                 	pla
  4349  f580 8d02dd             	sta acia+cdr		; set command
  4350  f583 a902               jx312:	lda #2			; device
  4351  f585 d006               	bne jx320		; bra...done
  4352                          
  4353                          ; some extra checks for tape
  4354  f587 2068fe             jx315:	jsr xtape		; goto tape indirect
  4355                          
  4356  f58a 4c4ff9             jx316:	jmp error6		; not input file
  4357                          
  4358  f58d 85a1               jx320:	sta dfltn		; all input come from here
  4359                          
  4360  f58f 18                 	clc			; good exit
  4361  f590 60                 	rts
  4362                          
  4363                          ; an serial device has to be a talker
  4364  f591 aa                 jx330:	tax			; device # for dflto
  4365  f592 20b4ff             	jsr talk		; tell him to talk
  4366                          
  4367  f595 a5a0               	lda sa			; a second?
  4368  f597 1006               	bpl jx340		; yes...send it
  4369  f599 208af2             	jsr tkatn		; no...let go
  4370  f59c 4ca2f5             	jmp jx350
  4371                          
  4372  f59f 2096ff             jx340:	jsr tksa		; send second
  4373                          
  4374  f5a2 8a                 jx350:	txa
  4375  f5a3 249c               	bit status		; did he listen?
  4376  f5a5 10e6               	bpl jx320		; yes
  4377                          
  4378  f5a7 4c4cf9             	jmp error5		; device not present
  4379                          ; -------------------------------------------------------------------------------------------------
  4380                          ;***************************************
  4381                          ;* chkout -- open channel for output   *
  4382                          ;*                                     *
  4383                          ;* the number of the logical file to be*
  4384                          ;* opened for output is passed in .x.  *
  4385                          ;* chkout searches the logical file    *
  4386                          ;* to look up device and command info. *
  4387                          ;* errors are reported if the device   *
  4388                          ;* was not opened for input ,(e.g.     *
  4389                          ;* keyboard), or the logical file has  *
  4390                          ;* reference in the tables.            *
  4391                          ;* device 0, (keyboard), and device 3  *
  4392                          ;* (screen), require no table entries  *
  4393                          ;* and are handled separate.           *
  4394                          ;***************************************
  4395                          ; F5AA
  4396  f5aa 2045f6             nckout:	jsr lookup		; is file in table?
  4397  f5ad f003               	beq ck5			; yes...
  4398                          
  4399  f5af 4c46f9             	jmp error3		; no...file not open
  4400                          
  4401  f5b2 2057f6             ck5:	jsr jz100		; extract table info
  4402  f5b5 a59f               	lda fa			; is it keyboard?
  4403  f5b7 d003               	bne ck10		; no...something else.
  4404                          
  4405  f5b9 4c52f9             ck20:	jmp error7		; yes...not output file
  4406                          
  4407                          ;could be screen,serial,or tapes
  4408  f5bc c903               ck10:	cmp #3
  4409  f5be f018               	beq ck30		; is screen...done
  4410  f5c0 b01a               	bcs ck40		; is serial...address it
  4411  f5c2 c902               	cmp #2			; rs232?
  4412  f5c4 d00f               	bne ck15
  4413                          
  4414                          ; rs232 output
  4415  f5c6 a5a0               	lda sa			; check if output file
  4416  f5c8 4a                 	lsr
  4417  f5c9 90ee               	bcc ck20		; not so...
  4418  f5cb 2035f4             	jsr rst232		; reset rs232 status
  4419  f5ce 20f8f3             	jsr xon232		; make sure transmit is on
  4420  f5d1 a902               	lda #2			; device#
  4421  f5d3 d003               	bne ck30		; bra...done
  4422                          
  4423                          ; special tape channel handling
  4424  f5d5 2068fe             ck15:	jsr xtape		; goto system tape indirect
  4425                          
  4426  f5d8 85a2               ck30:	sta dflto		; all output goes here
  4427                          
  4428  f5da 18                 	clc			; good exit
  4429  f5db 60                 	rts
  4430                          
  4431  f5dc aa                 ck40:	tax			; save device for dflto
  4432  f5dd 20b1ff             	jsr listn		; tell him to listen
  4433                          
  4434  f5e0 a5a0               	lda sa			; is there a second?
  4435  f5e2 1005               	bpl ck50		; yes...
  4436                          
  4437  f5e4 207ef2             	jsr scatn		; no...release lines
  4438  f5e7 d003               	bne ck60		; branch always
  4439                          
  4440  f5e9 2093ff             ck50:	jsr secnd		; send second...
  4441                          
  4442  f5ec 8a                 ck60:	txa
  4443  f5ed 249c               	bit status		; did he listen?
  4444  f5ef 10e7               	bpl ck30		; yes...finish up
  4445                          
  4446  f5f1 4c4cf9             	jmp error5		; no...device not present
  4447                          ; -------------------------------------------------------------------------------------------------
  4448                          ; ##### close #####
  4449                          ;*************************************
  4450                          ;* nclose -- close logical file      *
  4451                          ;*                                   *
  4452                          ;* enter:                            *
  4453                          ;*     cy =1 ,transmit close to dev- *
  4454                          ;*            ice.                   *
  4455                          ;*     cy =0 ,only remove from kernal*
  4456                          ;*            tables.                *
  4457                          ;*                                   *
  4458                          ;*     the logical file number of the*
  4459                          ;* file to be closed is passed in .a.*
  4460                          ;* keyboard, screen, and files not   *
  4461                          ;* open pass straight through. tape  *
  4462                          ;* files open for write are closed by*
  4463                          ;* dumping the last buffer and       *
  4464                          ;* conditionally writing an end of   *
  4465                          ;* tape block.serial files are closed*
  4466                          ;* by sending a close file command if*
  4467                          ;* a secondary address was specified *
  4468                          ;* in its open command.              *
  4469                          ;*************************************
  4470                          ; F5F4
  4471  f5f4 08                 nclose:	php			; save cy flag
  4472  f5f5 204af6             	jsr jltlk		; look file up
  4473  f5f8 f003               	beq jx110		; was open...continue
  4474  f5fa 28                 	plp
  4475  f5fb 18                 	clc			; was never open...no error
  4476  f5fc 60                 	rts
  4477                          
  4478  f5fd 2057f6             jx110:	jsr jz100		; extract table data
  4479  f600 28                 	plp			; retrieve cy flag
  4480  f601 8a                 	txa			; save table index
  4481  f602 48                 	pha
  4482  f603 901f               	bcc jx150		; close out table entries only
  4483                          
  4484  f605 a59f               	lda fa			; check device number
  4485  f607 f01b               	beq jx150		; is keyboard...done
  4486  f609 c903               	cmp #3
  4487  f60b f017               	beq jx150		; is screen...done
  4488  f60d b012               	bcs jx120		; is ieee...process
  4489  f60f c902               	cmp #2			; rs232?
  4490  f611 d007               	bne jx115		; no...
  4491                          
  4492                          ; close rs-232 file
  4493  f613 a900               cls232:	lda #0
  4494  f615 8d02dd             	sta acia+cdr		; do a soft reset
  4495  f618 f00a               	beq jx150		; jmp...remove file
  4496                          
  4497                          ; close cassette file
  4498  f61a 68                 jx115:	pla			; cassette now closes the channel...
  4499  f61b 2025f6             	jsr jx151		; before transmitting out the final data
  4500  f61e 2068fe             	jsr xtape		; goto tape indirect
  4501                          
  4502                          ; close an ieee file
  4503  f621 20c6f8             jx120:	jsr clsei
  4504                          
  4505                          ; entry to remove a give logical file from table of logical, primary, and secondary addresses
  4506  f624 68                 jx150:	pla			; get table index off stack
  4507  f625 aa                 jx151:	tax			; entry for cassette special
  4508  f626 ce6003             	dec ldtnd
  4509  f629 ec6003             	cpx ldtnd		; is deleted file at end?
  4510  f62c f015               	beq jx160		; yes...done
  4511                          
  4512                          ; delete entry in middle by moving last entry to that position.
  4513  f62e ac6003             	ldy ldtnd
  4514  f631 b93403             	lda lat,y
  4515  f634 9d3403             	sta lat,x
  4516  f637 b93e03             	lda fat,y
  4517  f63a 9d3e03             	sta fat,x
  4518  f63d b94803             	lda sat,y
  4519  f640 9d4803             	sta sat,x
  4520  f643 18                 jx160:	clc
  4521  f644 60                 jx170:	rts			; close exit
  4522                          
  4523                          ; lookup tablized logical file data
  4524  f645 a900               lookup:	lda #0
  4525  f647 859c               	sta status
  4526  f649 8a                 	txa
  4527  f64a ae6003             jltlk:	ldx ldtnd
  4528  f64d ca                 jx600:	dex
  4529  f64e 302d               	bmi lkups4
  4530  f650 dd3403             	cmp lat,x
  4531  f653 d0f8               	bne jx600
  4532  f655 18                 	clc
  4533  f656 60                 	rts
  4534                          
  4535                          ; routine to fetch table entries
  4536  f657 bd3403             jz100:	lda lat,x
  4537  f65a 859e               	sta la
  4538  f65c bd3e03             	lda fat,x
  4539  f65f 859f               	sta fa
  4540  f661 bd4803             	lda sat,x
  4541  f664 85a0               	sta sa
  4542  f666 60                 jz101:	rts
  4543                          
  4544                          ; sa is passed in .y
  4545                          ; routine looks for match in tables
  4546                          ; carry set if not present
  4547                          ; carry clear:
  4548                          ; .a=la,.x=fa,.y=sa
  4549  f667 98                 lkupsa:	tya
  4550  f668 ae6003             	ldx ldtnd
  4551  f66b ca                 lkups2:	dex
  4552  f66c 300f               	bmi lkups4
  4553  f66e dd4803             	cmp sat,x
  4554  f671 d0f8               	bne lkups2
  4555  f673 18                 	clc
  4556  f674 2057f6             lkups3:	jsr jz100		; get table data
  4557  f677 a8                 	tay
  4558  f678 a59e               	lda la
  4559  f67a a69f               	ldx fa
  4560  f67c 60                 	rts
  4561  f67d 38                 lkups4:	sec
  4562  f67e 60                 	rts			; not found exit
  4563                          
  4564                          ; la is passed in .a
  4565                          ; routine looks for match in tables
  4566                          ; carry set if not found
  4567                          ; carry clear:
  4568                          ; .a=la,.x=fa,.y=sa
  4569  f67f aa                 lkupla:	tax
  4570  f680 2045f6             	jsr lookup
  4571  f683 90ef               	bcc lkups3
  4572  f685 60                 	rts
  4573                          ; -------------------------------------------------------------------------------------------------
  4574                          ; ##### clall #####
  4575                          ;******************************************
  4576                          ;* nclall -- close all logical files      *
  4577                          ;*      deletes all table entries and     *
  4578                          ;* restores default i/o channels          *
  4579                          ;* and clears ieee port devices           *
  4580                          ;******************************************
  4581                          ;------------------------------------------
  4582                          ; new ncall
  4583                          ;  closes all files untill done or an
  4584                          ;  error occurs.
  4585                          ;  entry:
  4586                          ;    c-clr => close all files
  4587                          ;    c-set => .a = fa (device to be closed)
  4588                          ;------------------------------------------
  4589                          ; F686 Close all logical files
  4590  f686 6e6503             nclall:	ror xsav		; save carry
  4591  f689 8d6603             	sta savx		; save .a
  4592  f68c ae6003             ncl010:	ldx ldtnd		; scan index
  4593  f68f ca                 ncl020:	dex
  4594                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  4595  f690 301b               	bmi nclrch		; all done...clear channels (dclose patch 5/31/83)
  4596                          } else{
  4597                          	bmi ncl040		; all done
  4598                          }
  4599  f692 2c6503             	bit xsav		; check for fixed fa
  4600  f695 1008               	bpl ncl030		; none...
  4601  f697 ad6603             	lda savx
  4602  f69a dd3e03             	cmp fat,x
  4603  f69d d0f0               	bne ncl020		; no match...
  4604  f69f bd3403             ncl030:	lda lat,x		; close this la
  4605  f6a2 38                 	sec			; c-set required to close
  4606  f6a3 20c3ff             	jsr close
  4607  f6a6 90e4               	bcc ncl010
  4608                          
  4609  f6a8 a900               ncl040:	lda #0			; original entry for nclall
  4610  f6aa 8d6003             	sta ldtnd		; forget all files
  4611                          ; -------------------------------------------------------------------------------------------------
  4612                          ;********************************************
  4613                          ;* nclrch -- clear channels                 *
  4614                          ;*   unlisten or untalk ieee devices, but   *
  4615                          ;* leave others alone.  default channels    *
  4616                          ;* are restored.                            *
  4617                          ;********************************************
  4618                          ; F6AD
  4619  f6ad a203               nclrch:	ldx #3
  4620  f6af e4a2               	cpx dflto		; is output channel ieee?
  4621  f6b1 b003               	bcs jx750		; no...
  4622                          
  4623  f6b3 20aeff             	jsr unlsn		; yes...unlisten it
  4624                          
  4625  f6b6 e4a1               jx750:	cpx dfltn		; is input channel ieee?
  4626  f6b8 b003               	bcs clall2		; no...
  4627                          
  4628  f6ba 20abff             	jsr untlk		; yes...untalk it
  4629                          
  4630                          ; restore default values
  4631  f6bd a203               clall2:	ldx #3
  4632  f6bf 86a2               	stx dflto		; output chan=3=screen
  4633  f6c1 a900               	lda #0
  4634  f6c3 85a1               	sta dfltn		; input chan=0=keyboard
  4635  f6c5 60                 	rts
  4636                          ; -------------------------------------------------------------------------------------------------
  4637                          ; ##### open #####
  4638                          ;***********************************
  4639                          ;*                                 *
  4640                          ;* open function                   *
  4641                          ;*                                 *
  4642                          ;* enter: cy=1, transmit command to*
  4643                          ;*              device.            *
  4644                          ;*        cy=0, perform open opera-*
  4645                          ;*              tion.              *
  4646                          ;*                                 *
  4647                          ;* la, fa, sa must be set up prior *
  4648                          ;* to the call to this routine, as *
  4649                          ;* well as the file name descript- *
  4650                          ;* tor.                            *
  4651                          ;*                                 *
  4652                          ;***********************************
  4653                          ; F6C6
  4654  f6c6 9003               nopen:	bcc     op000		; do open
  4655  f6c8 4c41f7             	jmp     tranr		; do transmit
  4656                          
  4657                          ;***********************************
  4658                          ;*                                 *
  4659                          ;* create an entry in the logical  *
  4660                          ;* files tables consisting of      *
  4661                          ;* logical file number--la, device *
  4662                          ;* number--fa, and secondary cmd-- *
  4663                          ;* sa.                             *
  4664                          ;*                                 *
  4665                          ;* a file name descriptor, fnadr & *
  4666                          ;* fnlen, is passed to this routine*
  4667                          ;*                                 *
  4668                          ;***********************************
  4669                          ; F6CB
  4670  f6cb a69e               op000:	ldx la			; check file #
  4671                          
  4672                          ; bne op98 ;is not the keyboard
  4673                          ; jmp error6 ;not input file...
  4674                          
  4675  f6cd 2045f6             op98:	jsr lookup		; see if in table
  4676  f6d0 d003               	bne op100		; not found...o.k.
  4677                          
  4678  f6d2 4c43f9             	jmp error2		; file open
  4679                          
  4680  f6d5 ae6003             op100:	ldx ldtnd		; logical device table end
  4681  f6d8 e00a               	cpx #10			; maximum # of open files
  4682  f6da 9003               	bcc op110		; less than 10...o.k.
  4683                          
  4684  f6dc 4c40f9             	jmp error1		; too many files
  4685                          
  4686  f6df ee6003             op110:	inc ldtnd		; new file
  4687  f6e2 a59e               	lda la
  4688  f6e4 9d3403             	sta lat,x		; store logical file #
  4689  f6e7 a5a0               	lda sa
  4690  f6e9 0960               	ora #$60		; make sa an ieee command
  4691  f6eb 85a0               	sta sa
  4692  f6ed 9d4803             	sta sat,x		; store command #
  4693  f6f0 a59f               	lda fa
  4694  f6f2 9d3e03             	sta fat,x		; store device #
  4695                          
  4696                          ; perform device specific open tasks
  4697  f6f5 f015               	beq op175		; is keyboard...done.
  4698  f6f7 c903               	cmp #3
  4699  f6f9 f011               	beq op175		; is screen...done.
  4700  f6fb 9005               	bcc op150		; are cassettes 1 & 2
  4701                          
  4702  f6fd 200ef7             	jsr openi		; is on ieee...open it
  4703  f700 900a               	bcc op175		; branch always...done
  4704                          
  4705                          ; perform tape open stuff
  4706  f702 c902               op150:	cmp #2
  4707  f704 d003               	bne op152
  4708                          
  4709  f706 4c88f3             	jmp opn232
  4710                          
  4711  f709 2068fe             op152:	jsr xtape		; goto tape device indirect
  4712                          
  4713  f70c 18                 op175:	clc			; flag good open
  4714  f70d 60                 op180:	rts			; exit in peace
  4715                          
  4716  f70e a5a0               openi:	lda sa
  4717  f710 302d               	bmi op50		; no sa...done
  4718                          
  4719  f712 a49d               	ldy fnlen
  4720  f714 f029               	beq op50		; no file name...done
  4721                          
  4722  f716 a59f               	lda fa
  4723  f718 20b1ff             	jsr listn		; device la to listen
  4724                          
  4725  f71b a5a0               	lda sa
  4726  f71d 09f0               	ora #$f0
  4727  f71f 2093ff             openib:	jsr secnd
  4728                          
  4729  f722 a59c               	lda status		; anybody home?
  4730  f724 1005               	bpl op35		; yes...continue
  4731                          
  4732                          ; this routine is called by other kernal routines which are called directly by os.
  4733                          ; kill return address to return to os.
  4734  f726 68                 	pla
  4735  f727 68                 	pla
  4736  f728 4c4cf9             	jmp error5		; device not present
  4737                          
  4738  f72b a59d               op35:	lda fnlen
  4739  f72d f00d               	beq op45		; no name...done sequence
  4740                          
  4741                          ; send file name over ieee
  4742  f72f a000               	ldy #0
  4743  f731 208dfe             op40:	jsr fnadry
  4744  f734 20a8ff             	jsr ciout
  4745  f737 c8                 	iny
  4746  f738 c49d               	cpy fnlen
  4747  f73a d0f5               	bne op40
  4748                          
  4749  f73c 20aeff             op45:	jsr unlsn
  4750                          
  4751  f73f 18                 op50:	clc			; no  error
  4752  f740 60                 	rts
  4753                          ; -------------------------------------------------------------------------------------------------
  4754                          ;*****************************************
  4755                          ;*  transmit command to device           *
  4756                          ;*                                       *
  4757                          ;*   fnlen,fnadr must be set up already  *
  4758                          ;*   to contain the command string.      *
  4759                          ;*   fa must be set for the device.      *
  4760                          ;*****************************************
  4761                          ; F741
  4762  f741 a59f               tranr:  lda fa
  4763  f743 20b1ff             	jsr listn
  4764  f746 a96f               	lda #$6F
  4765  f748 85a0               	sta sa
  4766  f74a 4c1ff7             	jmp openib
  4767                          ; -------------------------------------------------------------------------------------------------
  4768                          ; ##### load #####
  4769                          ;**************************************
  4770                          ;* load ram function     10/30/81     *
  4771                          ;*                                    *
  4772                          ;*  loads from cassette 1 or 2, or    *
  4773                          ;*  ieee bus devices >=4 to 31 as     *
  4774                          ;*  determined by contents of         *
  4775                          ;*  variable fa.                      *
  4776                          ;* entry:                             *
  4777                          ;*   .a(bit 7)=0 performs load        *
  4778                          ;*   .a(bit 7)=1 performs verify      *
  4779                          ;*   .a(bits 0123)=start segment      *
  4780                          ;*   .x=start address low             *
  4781                          ;*   .y=start address high            *
  4782                          ;*   if .x=$ff & .y=$ff => fixed load *
  4783                          ;* exit:                              *
  4784                          ;*   .a(bits 0123)=end segment        *
  4785                          ;*   .x=end address low               *
  4786                          ;*   .y=end address high              *
  4787                          ;*                                    *
  4788                          ;**************************************
  4789                          ; F74D
  4790  f74d 8e6f03             nload:	stx relsal		; save alt address
  4791  f750 8c7003             	sty relsah
  4792  f753 8d5f03             	sta verck		; set verify flag (n)
  4793  f756 8d7103             	sta relsas		; save start address
  4794  f759 a900               	lda #0			; clear status
  4795  f75b 859c               	sta status
  4796                          
  4797  f75d a59f               	lda fa			; check device number
  4798  f75f d003               	bne ld20
  4799                          
  4800  f761 4c58f9             ld10:	jmp error9		; bad device #-keyboard
  4801                          
  4802  f764 c903               ld20:	cmp #3
  4803  f766 f0f9               	beq ld10		; disallow screen load
  4804  f768 b003               	bcs *+5
  4805  f76a 4c17f8             	jmp ld100		; handle tapes different
  4806                          
  4807                          ; load from cbm ieee device
  4808  f76d a960               	lda #$60		; special load command
  4809  f76f 85a0               	sta sa
  4810                          
  4811  f771 a49d               	ldy fnlen		; must have file name
  4812  f773 d003               	bne ld25		; yes...ok
  4813                          
  4814  f775 4c55f9             	jmp error8		; missing file name
  4815                          
  4816  f778 2022f8             ld25:	jsr luking		; tell user looking
  4817  f77b 200ef7             	jsr openi		; open the file
  4818                          
  4819  f77e a59f               	lda fa
  4820  f780 20b4ff             	jsr talk		; establish the channel
  4821  f783 a5a0               	lda sa
  4822  f785 2096ff             	jsr tksa		; tell it to load
  4823                          
  4824  f788 20a5ff             	jsr acptr		; get first byte
  4825  f78b 8596               	sta eal
  4826  f78d 8599               	sta stal
  4827                          
  4828  f78f a59c               	lda status		; test status for error
  4829  f791 4a                 	lsr
  4830  f792 4a                 	lsr
  4831  f793 9003               	bcc *+5			; file  found...
  4832                          
  4833  f795 4c49f9             	jmp error4		; file not found error
  4834                          
  4835  f798 20a5ff             	jsr acptr
  4836  f79b 8597               	sta eah
  4837  f79d 859a               	sta stah
  4838                          
  4839  f79f 2047f8             	jsr loding		; tell user loading
  4840                          
  4841                          ; test for fixed or moveable load
  4842  f7a2 ad7103             	lda relsas		; no segment byte in storage ***
  4843  f7a5 8598               	sta eas
  4844  f7a7 859b               	sta stas
  4845  f7a9 ad6f03             	lda relsal
  4846  f7ac 2d7003             	and relsah
  4847  f7af c9ff               	cmp #$FF
  4848  f7b1 f00e               	beq ld40		; fixed load
  4849                          
  4850  f7b3 ad6f03             	lda relsal
  4851  f7b6 8596               	sta eal
  4852  f7b8 8599               	sta stal
  4853  f7ba ad7003             	lda relsah
  4854  f7bd 8597               	sta eah
  4855  f7bf 859a               	sta stah
  4856                          ;
  4857  f7c1 a9fd               ld40:	lda #$FD		; mask off timeout
  4858  f7c3 259c               	and status
  4859  f7c5 859c               	sta status
  4860                          
  4861  f7c7 20e1ff             	jsr stop		; stop key?
  4862  f7ca d003               	bne ld45		; no...
  4863                          
  4864  f7cc 4cbaf8             	jmp break		; stop key pressed
  4865                          
  4866  f7cf 20a5ff             ld45:	jsr acptr		; get byte off ieee
  4867  f7d2 aa                 	tax
  4868  f7d3 a59c               	lda status		; was there a timeout?
  4869  f7d5 4a                 	lsr
  4870  f7d6 4a                 	lsr
  4871  f7d7 b0e8               	bcs ld40		; yes...try again
  4872  f7d9 8a                 	txa
  4873                          ; change indirect pages
  4874  f7da a601               	ldx i6509
  4875  f7dc a498               	ldy eas
  4876  f7de 8401               	sty i6509
  4877  f7e0 a000               	ldy #0
  4878  f7e2 2c5f03             	bit verck		; performing verify?
  4879  f7e5 100e               	bpl ld50		; no...load
  4880  f7e7 8593               	sta sal			; use as a temp
  4881  f7e9 b196               	lda (eal),y
  4882  f7eb c593               	cmp sal
  4883  f7ed f008               	beq ld60		; okay
  4884  f7ef a910               	lda #sperr		; no good...verify error
  4885  f7f1 206efb             	jsr udst		; update status
  4886  f7f4 ad                 	!byte $AD		; skip next store
  4887                          
  4888  f7f5 9196               ld50:	sta (eal),y
  4889  f7f7 8601               ld60:	stx i6509		; restore indirect
  4890  f7f9 e696               	inc eal			; increment store addr
  4891  f7fb d00a               	bne ld64
  4892  f7fd e697               	inc eah
  4893  f7ff d006               	bne ld64
  4894  f801 e698               	inc eas
  4895  f803 a902               	lda #2			; skip $0000 $0001
  4896  f805 8596               	sta eal
  4897  f807 249c               ld64:	bit status		; eoi?
  4898  f809 50b6               	bvc ld40		; no...continue load
  4899                          
  4900  f80b 20abff             	jsr untlk		; close channel
  4901  f80e 20c6f8             	jsr clsei		; close the file
  4902  f811 4c1af8             	jmp ld180		; exit ieee load
  4903                          
  4904  f814 4c49f9             ld90:	jmp error4		; file not found
  4905                          
  4906                          ; load from tape
  4907  f817 2068fe             ld100:	jsr xtape		; goto tape indirect
  4908                          
  4909  f81a 18                 ld180:	clc			; good exit
  4910                          
  4911                          ; set up end load address
  4912  f81b a598               	lda eas
  4913  f81d a696               	ldx eal
  4914  f81f a497               	ldy eah
  4915                          
  4916  f821 60                 ld190:	rts
  4917                          
  4918                          ; subroutine to print to console: searching [for name]
  4919  f822 2c6103             luking:	bit msgflg		; supposed to print?
  4920  f825 101f               	bpl ld115
  4921  f827 a00c               	ldy #ms5-ms1		; "searching"
  4922  f829 2023f2             	jsr spmsg
  4923  f82c a59d               	lda fnlen
  4924  f82e f016               	beq ld115
  4925  f830 a017               	ldy #ms6-ms1		; "for"
  4926  f832 2023f2             	jsr spmsg
  4927                          
  4928                          ; subroutine to output file name
  4929  f835 a49d               outfn:	ldy fnlen		; is there a name?
  4930  f837 f00d               	beq ld115		; no...done
  4931  f839 a000               	ldy #0
  4932  f83b 208dfe             ld110:	jsr fnadry
  4933  f83e 20d2ff             	jsr bsout
  4934  f841 c8                 	iny
  4935  f842 c49d               	cpy fnlen
  4936  f844 d0f5               	bne ld110
  4937                          
  4938  f846 60                 ld115:	rts
  4939                          
  4940                          ; subroutine to print: loading/verifing
  4941  f847 a01b               loding:	ldy #ms10-ms1		; assume 'loading'
  4942  f849 ad5f03             	lda verck		; check flag
  4943  f84c 1002               	bpl ld410		; are doing load
  4944  f84e a02b               	ldy #ms21-ms1		; are 'verifying'
  4945  f850 4c23f2             ld410:	jmp spmsg
  4946                          
  4947                          ; rsr  fix segmentation 10/15/81
  4948                          ; rsr  6509 changes  10/15/81
  4949                          ; -------------------------------------------------------------------------------------------------
  4950                          ; ##### save #####
  4951                          ;***************************************
  4952                          ;* nsave              10/30/81         *
  4953                          ;*                                     *
  4954                          ;* saves to cassette 1 or 2, or        *
  4955                          ;* ieee devices 4>=n>=31 as selected   *
  4956                          ;* by variable fa.                     *
  4957                          ;*                                     *
  4958                          ;* .x => zpage address of start vector *
  4959                          ;* .y => zpage address of end vector   *
  4960                          ;***************************************
  4961                          ; F853
  4962  f853 b500               nsave:	lda 0,x			; get start vector
  4963  f855 8599               	sta stal
  4964  f857 b501               	lda 1,x
  4965  f859 859a               	sta stah
  4966  f85b b502               	lda 2,x
  4967  f85d 859b               	sta stas
  4968  f85f 98                 	tya
  4969  f860 aa                 	tax
  4970  f861 b500               	lda 0,x			; get end vector
  4971  f863 8596               	sta eal
  4972  f865 b501               	lda 1,x
  4973  f867 8597               	sta eah
  4974  f869 b502               	lda 2,x
  4975  f86b 8598               	sta eas
  4976                          
  4977  f86d a59f               	lda fa
  4978  f86f d003               	bne sv20
  4979                          
  4980  f871 4c58f9             sv10:	jmp error9		; bad device #
  4981                          
  4982  f874 c903               sv20:	cmp #3
  4983  f876 f0f9               	beq sv10
  4984  f878 9063               	bcc sv100
  4985  f87a a961               	lda #$61
  4986  f87c 85a0               	sta sa
  4987  f87e a49d               	ldy fnlen
  4988  f880 d003               	bne sv25
  4989                          
  4990  f882 4c55f9             	jmp error8		; missing file name
  4991                          
  4992  f885 200ef7             sv25:	jsr openi
  4993  f888 20e0f8             	jsr saving
  4994  f88b a59f               	lda fa
  4995  f88d 20b1ff             	jsr listn
  4996  f890 a5a0               	lda sa
  4997  f892 2093ff             	jsr secnd
  4998  f895 a601               	ldx i6509		; indirects switched by rd300
  4999  f897 2070fe             	jsr rd300
  5000  f89a a593               	lda sal
  5001  f89c 20a8ff             	jsr ciout
  5002  f89f a594               	lda sah
  5003  f8a1 20a8ff             	jsr ciout
  5004                          
  5005  f8a4 a000               	ldy #0
  5006  f8a6 207ffe             sv30:	jsr cmpste		; compare start to end
  5007  f8a9 b016               	bcs sv50		; have reached end
  5008  f8ab b193               	lda (sal),y
  5009  f8ad 20a8ff             	jsr ciout
  5010  f8b0 203fff             	jsr incsal
  5011  f8b3 20e1ff             	jsr stop
  5012  f8b6 d0ee               	bne sv30
  5013                          
  5014  f8b8 8601               	stx i6509		; restore indirects
  5015  f8ba 20c6f8             break:	jsr clsei
  5016  f8bd a900               	lda #0
  5017  f8bf 38                 	sec
  5018  f8c0 60                 	rts
  5019                          
  5020  f8c1 8601               sv50:	stx i6509		; restore indirects
  5021  f8c3 20aeff             	jsr unlsn
  5022                          
  5023  f8c6 24a0               clsei:	bit sa
  5024  f8c8 3011               	bmi clsei2
  5025  f8ca a59f               	lda fa
  5026  f8cc 20b1ff             	jsr listn
  5027  f8cf a5a0               	lda sa
  5028  f8d1 29ef               	and #$EF
  5029  f8d3 09e0               	ora #$E0
  5030  f8d5 2093ff             	jsr secnd
  5031  f8d8 20aeff             	jsr unlsn
  5032                          
  5033                          clsei2:
  5034  f8db 18                 sv110:	clc
  5035  f8dc 60                 sv115:	rts
  5036                          
  5037  f8dd 2068fe             sv100:	jsr xtape		; goto tape device
  5038                          
  5039                          ; subroutine to output: 'saving <file name>'
  5040  f8e0 ad6103             saving:	lda msgflg
  5041  f8e3 10f7               	bpl sv115		; no print
  5042                          
  5043  f8e5 a023               	ldy #ms11-ms1		; 'saving'
  5044  f8e7 2023f2             	jsr spmsg
  5045  f8ea 4c35f8             	jmp outfn		; <file name>
  5046                          ; -------------------------------------------------------------------------------------------------
  5047                          ; ##### time #####
  5048                          ;----------------------------------------
  5049                          ; time and alarm routines for 6526
  5050                          ;      rsr 11/12/81
  5051                          ;
  5052                          ; rdtim - read the time
  5053                          ;  .y = (bit7=pm,bit6/5=t8/t4,bits4-0 hrs)
  5054                          ;  .x = (bit7=t2,bits6-0 minutes)
  5055                          ;  .a = (bit7=t1,bits6-0 seconds)
  5056                          ;----------------------------------------
  5057                          ; F8ED
  5058  f8ed ad08dc             rdtim:	lda cia+tod10
  5059  f8f0 48                 	pha			; save for later
  5060  f8f1 48                 	pha
  5061  f8f2 0a                 	asl			; shift to add to todhrs
  5062  f8f3 0a                 	asl
  5063  f8f4 0a                 	asl
  5064  f8f5 2960               	and #$60		; bit posistions 5,6
  5065  f8f7 0d0bdc             	ora cia+todhr
  5066  f8fa a8                 	tay			; return in .y
  5067  f8fb 68                 	pla
  5068  f8fc 6a                 	ror			; shift to add to todsec
  5069  f8fd 6a                 	ror
  5070  f8fe 2980               	and #$80
  5071  f900 0d09dc             	ora cia+todsec
  5072  f903 8593               	sta sal			; save for later
  5073  f905 6a                 	ror			; shit to add to todmin
  5074  f906 2980               	and #$80
  5075  f908 0d0adc             	ora cia+todmin
  5076  f90b aa                 	tax			; return in .x
  5077  f90c 68                 	pla
  5078  f90d cd08dc             	cmp cia+tod10		; watch out for rollover
  5079  f910 d0db               	bne rdtim		; ...it changed do again...
  5080  f912 a593               	lda sal
  5081  f914 60                 	rts
  5082                          ; -------------------------------------------------------------------------------------------------
  5083                          ; settim - set tod and alarm
  5084                          ;  c-set => set alarm
  5085                          ;  c-clr => set tod
  5086                          ;  registers same as rdtim
  5087                          ;----------------------------------------
  5088                          ; F915
  5089  f915 48                 settim:	pha			; save for later
  5090  f916 48                 	pha
  5091  f917 6a                 	ror			; set bit 8
  5092  f918 2980               	and #$80
  5093  f91a 0d0fdc             	ora cia+crb
  5094  f91d 8d0fdc             	sta cia+crb
  5095  f920 98                 	tya			; get bits from todhrs
  5096  f921 2a                 	rol
  5097  f922 2a                 	rol
  5098  f923 2693               	rol sal			; bit t8 (don't need to clear sal)
  5099  f925 2a                 	rol
  5100  f926 2693               	rol sal			; bit t4
  5101  f928 8a                 	txa			; get bit from todmin
  5102  f929 2a                 	rol
  5103  f92a 2693               	rol sal			; bit t2
  5104  f92c 68                 	pla			; get bit from todsec
  5105  f92d 2a                 	rol
  5106  f92e 2693               	rol sal			; bit t1
  5107  f930 8c0bdc             	sty cia+todhr
  5108  f933 8e0adc             	stx cia+todmin
  5109  f936 68                 	pla
  5110  f937 8d09dc             	sta cia+todsec
  5111  f93a a593               	lda sal
  5112  f93c 8d08dc             	sta cia+tod10
  5113  f93f 60                 	rts
  5114                          ; -------------------------------------------------------------------------------------------------
  5115                          ; ##### errorhandler #####
  5116                          ;************************************
  5117                          ;* error handler                    *
  5118                          ;*  restores i/o channels to default*
  5119                          ;*  prints kernal error message if  *
  5120                          ;*  bit 6 of msgflg set.  returns   *
  5121                          ;*  with error # in .a and carry.   *
  5122                          ;************************************
  5123                          ; F940 
  5124  f940 a901               error1:	lda #1			; too many files
  5125  f942 2c                 	!byte $2c
  5126  f943 a902               error2:	lda #2			; file open
  5127  f945 2c                 	!byte $2c
  5128  f946 a903               error3:	lda #3			; file not open
  5129  f948 2c                 	!byte $2c
  5130  f949 a904               error4:	lda #4			; file not found
  5131  f94b 2c                 	!byte $2c
  5132  f94c a905               error5:	lda #5			; device not present
  5133  f94e 2c                 	!byte $2c
  5134  f94f a906               error6:	lda #6			; not input file
  5135  f951 2c                 	!byte $2c
  5136  f952 a907               error7:	lda #7			; not output file
  5137  f954 2c                 	!byte $2c
  5138  f955 a908               error8:	lda #8			; missing file name
  5139  f957 2c                 	!byte $2c
  5140  f958 a909               error9:	lda #9			; bad device #
  5141                          
  5142  f95a 48                 errorx:	pha			; error number on stack
  5143  f95b 20ccff             	jsr clrch		; restore i/o channels
  5144                          
  5145  f95e a000               	ldy #ms1-ms1
  5146  f960 2c6103             	bit msgflg		; are we printing error?
  5147  f963 500a               	bvc erexit		; no...
  5148                          
  5149  f965 2028f2             	jsr msg			; print "cbm i/o error #"
  5150  f968 68                 	pla
  5151  f969 48                 	pha
  5152  f96a 0930               	ora #$30		; make error # ascii
  5153  f96c 20d2ff             	jsr bsout		; print it
  5154                          
  5155  f96f 68                 erexit:	pla
  5156  f970 38                 	sec
  5157  f971 60                 	rts
  5158                          ; -------------------------------------------------------------------------------------------------
  5159                          ;***************************************
  5160                          ;* stop -- check stop key flag and     *
  5161                          ;* return z flag set if flag true.     *
  5162                          ;* also closes active channels and     *
  5163                          ;* flushes keyboard queue.             *
  5164                          ;* also returns key downs from last    *
  5165                          ;* keyboard row in .a.                 *
  5166                          ;***************************************
  5167                          ; F972 Check the stop key
  5168  f972 a5a9               nstop:	lda stkey		; value of last row
  5169  f974 2901               	and #$01		; check stop key position
  5170  f976 d007               	bne stop2		; not down
  5171  f978 08                 	php
  5172  f979 20ccff             	jsr clrch		; clear channels
  5173  f97c 85d1               	sta ndx			; flush queue
  5174  f97e 28                 	plp
  5175  f97f 60                 stop2:	rts
  5176                          ; -------------------------------------------------------------------------------------------------
  5177                          ; udtim - update the stop key location
  5178                          ;   expects keyboard outputs set to
  5179                          ;   default value. bit 0 of stkey =0
  5180                          ;   for stop key down.
  5181                          ;---------------------------------------
  5182                          ; F980 
  5183  f980 ad02df             udtim:	lda tpi2+pc		; check keyboard
  5184  f983 4a                 	lsr
  5185  f984 b012               	bcs udexit		; no  stop key
  5186  f986 a9fe               	lda #$FE		; check for shift
  5187  f988 8d01df             	sta tpi2+pb
  5188  f98b a910               	lda #$10
  5189  f98d 2d02df             	and tpi2+pc
  5190  f990 d001               	bne udttt		; no shift key
  5191  f992 38                 	sec			; shift key mark
  5192  f993 a9ff               udttt:	lda #$FF		; clear
  5193  f995 8d01df             	sta tpi2+pb
  5194  f998 2a                 udexit:	rol			; move bit 0 back
  5195  f999 85a9               	sta stkey
  5196  f99b 60                 	rts
  5197                          ; -------------------------------------------------------------------------------------------------
  5198                          ; ##### init #####
  5199                          ;------------------------------------------------
  5200                          ; start - system reset routine
  5201                          ;  kernal checks on 4k boundries from $1000-$8000
  5202                          ;    first occurance has priority.
  5203                          ;    if no occurance then $e000 is used for vector
  5204                          ;    $e000 => monitor start
  5205                          ;  kernal expects:
  5206                          ;    $x000 - jmp init  (cold start)
  5207                          ;    $x003 - jmp winit (warm start)
  5208                          ;    $x006 - 'c'(+$80)=> kernal cold start first
  5209                          ;    $x007 - 'b'+$80
  5210                          ;    $x008 - 'm'+$80
  5211                          ;    $x009 - 'x'  x=4k bank (1-8)
  5212                          ;------------------------------------------------
  5213                          ; F99C Test bytes for ROMs
  5214  f99c c2cd               patall: !byte $C2,$CD		; $x004 rom pattern
  5215                          ; F99E
  5216  f99e a2fe               start:	ldx #$FE		; do all normal junk...
  5217  f9a0 78                 	sei
  5218  f9a1 9a                 	txs
  5219  f9a2 d8                 	cld
  5220                          
  5221                          ; check for warm start
  5222                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  5223  f9a3 a9a5               	lda #warm
  5224  f9a5 cdfa03             	cmp evect+2		; check warm flag ?
  5225  f9a8 d003               	bne scold		; no -> cold start
  5226  f9aa 4c58ff             	jmp chkwarm		; warm start patch
  5227                          } else{
  5228                          	lda #$FF
  5229                          	eor evect+2
  5230                          	eor evect+3		; compare warm start flags $A5, $5A
  5231                          	beq swarm		; if yes...do warm start
  5232                          	}
  5233                          
  5234                          ; F9AD Check for roms
  5235  f9ad a906               scold:	lda #6			; set up indirect to $0006 = position ROM ident bytes
  5236  f9af 8596               	sta eal
  5237  f9b1 a900               	lda #0			; clear upper
  5238  f9b3 8597               	sta eah
  5239  f9b5 8df803             	sta evect		; set low byte of vector warm start to $00
  5240  f9b8 a230               	ldx #$30		; existance flag 4. rom ident byte compare value to '0'
  5241  f9ba a003               sloop0: ldy #3			; set counter to 4th ROM ident byte
  5242  f9bc a597               	lda eah
  5243  f9be 3018               	bmi sloop2		; no roms but this one... -> monitor cold boot
  5244  f9c0 18                 	clc			; calc new test point
  5245  f9c1 6910               	adc #$10                ; 4k steps
  5246  f9c3 8597               	sta eah
  5247  f9c5 e8                 	inx			; next 4. byte compare value $31, $32, $33...
  5248  f9c6 8a                 	txa
  5249  f9c7 d196               	cmp (eal),y		; compare if 4. byte $31 at address $1006+3, $32 at $2006...
  5250  f9c9 d0ef               	bne sloop0		; 4. byte does not mach - > next ROM pos. $2000, $3000...
  5251  f9cb 88                 	dey			; check next byte backwards if 4th byte matches
  5252  f9cc b196               sloop1: lda (eal),y		; load 3., 2., 1. byte
  5253  f9ce 88                 	dey
  5254  f9cf 300a               	bmi sloop3		; all done...correctly - 2.+3. byte matches -> autostart ROM found!
  5255  f9d1 d99cf9             	cmp patall,y		; compare test bytes 'M', 'B'
  5256  f9d4 f0f6               	beq sloop1		; 3. byte OK -> check 2. byte
  5257  f9d6 d0e2               	bne sloop0		; no good... 2. or 3. ident byte does not mach
  5258                          
  5259                          ; monitor (could be test for keydown ***)
  5260  f9d8 a0e0               sloop2: ldy #$E0                ; monitor vector
  5261  f9da 2c                 	!byte $2C		; skip two bytes
  5262  f9db a497               sloop3: ldy eah
  5263  f9dd 8cf903             	sty evect+1             ; set high byte of vector
  5264                          
  5265  f9e0 aa                 	tax                     ; move 1. ident byte to x to set N-flag
  5266  f9e1 1018               	bpl swarm               ; don't use kernal initilization
  5267                          				;   jump to warm start if value is positive ('c'=$43)
  5268                          
  5269                          ; kernal cold start
  5270  f9e3 20fef9             	jsr ioinit              ; initilize i/o -> $F9FE (TPI1, TPI2, CIA, TOD)
  5271  f9e6 a9f0               	lda #$F0		; prevent damage to non-tested buffers
  5272  f9e8 85c1               	sta pkybuf+1            ; start F-keys
  5273  f9ea 2004e0             	jsr jcint               ; cinit call for non-cleared system $E004 -> cint $E044
  5274  f9ed 2094fa             	jsr ramtas              ; ram-test and set -> $FA94
  5275  f9f0 20b1fb             	jsr restor              ; operationg system vectors -> $FBB1 (copies $0300 Vector Table)
  5276  f9f3 2004e0             	jsr jcint               ; screen editor init $E004 -> cint $E044 (editor, F-Keys, VIC)
  5277  f9f6 a9a5               	lda #warm		; Kernal initilize done flag
  5278  f9f8 8dfa03             	sta evect+2             ; save first warm start flag $A5
  5279                          ; F9FB Warm start entry
  5280  f9fb 6cf803             swarm:  jmp (evect)             ; start exit -> basic warm start $BBA0
  5281                          ; -------------------------------------------------------------------------------------------------
  5282                          ; ioinit - initilize i/o system
  5283                          ;   6509/6525/6525/6526
  5284                          ;   must be entered with irq's disabled
  5285                          ;------------------------------------------
  5286                          ; F9FE I/O register init (TPI1, TPI2, CIA, TOD)
  5287                          
  5288                          ; 6525 tpi1 initilization code
  5289  f9fe a9f3               ioinit: lda #%11110011		; cb,ca=hi ie3,4=neg ip=1 mc=1
  5290  fa00 8d06de             	sta tpi1+creg		; interrupt mode = on, parity / VIC bank 15 selected for both
  5291  fa03 a9ff               	lda #$FF
  5292  fa05 8d05de             	sta tpi1+mir		; mask on all irq's
  5293                          ; pb4=output 1, to claim dbus
  5294  fa08 a95c               	lda #%01011100  	; wrt=lo unused netr=off
  5295  fa0a 8d01de             	sta tpi1+pb		; IEEE ifc=0, netw.=0, arb.sw.=1, cass. write=0,motor=1 
  5296  fa0d a97d               	lda #%01111101  	; set directions
  5297  fa0f 8d04de             	sta tpi1+ddpb		; input: cassette switch, IEEE srq
  5298                          				; output: IEEE ifc, network, arb.sw., cass. motor,write
  5299                          
  5300  fa12 a93d               	lda #%00111101		; IEEE controls off: dc=1, te=0, ren=1, atn=1, dav=1, eo=1
  5301  fa14 8d00de             	sta tpi1+pa
  5302  fa17 a93f               	lda #%00111111  	; IEEE control to transmitt, data to receive
  5303  fa19 8d03de             	sta tpi1+ddpa		; in: ndac, nfrd / out: dc, te, ren, atn, dav, eoi
  5304                          
  5305                          ; 6525 tpi2 initilization code
  5306  fa1c a9ff               	lda #$FF     		; set up keyboard outputs
  5307  fa1e 8d00df             	sta tpi2+pa             ; keyboard out 8-15=1
  5308  fa21 8d01de             	sta tpi1+pb             ; IEEE ifc=1, network=1, arb.sw.=1, cass. motor=1,write=1
  5309  fa24 8d03df             	sta tpi2+ddpa           ; dir keyboard 8-15 = output
  5310  fa27 8d04df             	sta tpi2+ddpb           ; dir keyboard 0-7 = output
  5311  fa2a 4e00df             	lsr tpi2+pa             ; clear keyboard 15 bit #7
  5312  fa2d a9c0               	lda #$C0		; set up vic selects=out for p-series
  5313  fa2f 8d02df             	sta tpi2+pc             ; VIC 16k bank select=11 $c000-$ffff
  5314  fa32 8d05df             	sta tpi2+ddpc           ; dir input: #0-5 keyboard 0-5 / output: #6-7 VIC 16k bank
  5315                          
  5316                          ; 6526 cia initilization code
  5317                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5318  fa35 a97f               	lda #$7f		; turn off all irq sources from 6526...
  5319                          	} else{
  5320                          	lda #$84		; set irq: #7=set, #2=ALRM enable TOD interrupt
  5321                          }
  5322  fa37 8d0ddc             	sta cia+icr
  5323  fa3a a000               	ldy #$00     		; all ieee in / same all game inputs
  5324  fa3c 8c02dc             	sty cia+ddra		; dir input: IEEE data, #6,7 also trigger 1,2
  5325  fa3f 8c03dc             	sty cia+ddrb		; dir input: game 1,2
  5326  fa42 8c0fdc             	sty cia+crb		; Timer B stop, PB7=off, cont, Phi2, activate TOD write
  5327                          ; activate tod
  5328  fa45 8d08dc             	sta cia+tod10		; clear TOD 1/10 seconds
  5329                          ; 60/50 hz test code for tod
  5330  fa48 8c02de             	sty tpi1+lir		; clear all interrupts
  5331  fa4b ad02de             io100:  lda tpi1+lir		; wait untill it happens again
  5332  fa4e 6a                 	ror			; shift bit #0 to carry
  5333  fa4f 90fa               	bcc io100		; pc0 = 1 -> 50/60hz irq
  5334  fa51 8c02de             	sty tpi1+lir		; clear it again
  5335                          ; start a timmer
  5336  fa54 a200               	ldx #0   
  5337  fa56 a000               	ldy #0
  5338  fa58 e8                 io110:  inx
  5339  fa59 d0fd               	bne io110		; delay 256x -> 1.28 ms @ 1MHz
  5340  fa5b c8                 	iny
  5341  fa5c ad02de             	lda tpi1+lir		; load interrrupt latch reg
  5342  fa5f 6a                 	ror
  5343  fa60 90f6               	bcc io110		; pc0 = 1 -> 50/60hz irq          
  5344  fa62 c00e               	cpy #id55hz   
  5345  fa64 9003               	bcc io120               ; it was 60 hz, signal appears again in 14 tries = <18ms
  5346  fa66 a988               	lda #%10001000		; set for 50hz
  5347  fa68 2c                 	!byte $2C		; skip two bytes
  5348  fa69 a908               io120:  lda #%00001000
  5349  fa6b 8d0edc             	sta cia+cra            ; set TOD=50/60Hz, run mode=continuous
  5350                          
  5351                          ; 6526  inter-process communication initialization
  5352                          ;   pra = data port
  5353                          ;   prb = ipc lines
  5354                          ;   irq's from 2nd processor via flag input
  5355  fa6e ad0ddb             	lda ipcia+icr		; clear icr
  5356  fa71 a990               	lda #$90    
  5357  fa73 8d0ddb             	sta ipcia+icr		; flag irqs on
  5358  fa76 a940               	lda #$40    
  5359  fa78 8d01db             	sta ipcia+prb		; no nmi to z80, sem6509 low
  5360  fa7b a900               	lda #$00    
  5361  fa7d 8d02db             	sta ipcia+ddra		; port a=input
  5362  fa80 8d0fdb             	sta ipcia+crb		; timer b off
  5363  fa83 8d0edb             	sta ipcia+cra		; timer a off
  5364  fa86 a948               	lda #%01001000		; port b lines sem65,ennmi are outs
  5365  fa88 8d03db             	sta ipcia+ddrb
  5366                          
  5367                          ; 6551 initilization code handled by reset  10/19/81 rsr
  5368                          
  5369                          ; turn off ifc
  5370  fa8b a901               	lda #ifc
  5371  fa8d 0d01de             	ora tpi1+pb		; TPI1 PB set bit #0 IEEE ifc=1
  5372  fa90 8d01de             	sta tpi1+pb 
  5373  fa93 60                 	rts         
  5374                          ; -------------------------------------------------------------------------------------------------
  5375                          ; ramtas - initilize lower ram with $00
  5376                          ;  and test all system dynamic ram
  5377                          ;  set ram limits (64k bank min size)
  5378                          ;  alocatate initial buffer space
  5379                          ;  turn off rs232 and cassette buffers
  5380                          ;  reset xtape vectors to non-cassette
  5381                          ;-----------------------------------------
  5382                          ; FA94 RAM-test / vector init
  5383  fa94 a900               ramtas: lda #0			; init value A = $00, counter X = 0
  5384  fa96 aa                 	tax
  5385  fa97 9d0200             px1:    sta $0002,x		; clear ZP above 6509 bank regs
  5386  fa9a 9d0002             	sta buf,x		; clear basic input buffer from $0200       
  5387  fa9d 9df802             	sta evect-$100,x	; clear kernal RAM till evct $03F8
  5388  faa0 e8                 	inx
  5389  faa1 d0f4               	bne px1			; clear next byte
  5390                          
  5391                          ; memory size check
  5392  faa3 a900               	lda #0			; bottom of memory always segment 0 (P500)
  5393  faa5 8501               	sta i6509
  5394  faa7 8d5a03             	sta memstr+2		; set bottom of user memory
  5395  faaa 8d5403             	sta lowadr+2		; ...and system memory
  5396  faad a902               	lda #2			; start at byte $0002
  5397  faaf 8d5803             	sta memstr
  5398  fab2 8d5203             	sta lowadr
  5399  fab5 c601               	dec i6509		; place back one segment for test
  5400                          
  5401                          ; memsiz,sal,lowadr are zeroed above
  5402  fab7 e601               sizlop: inc i6509		; claculate next ind bank
  5403  fab9 a501               	lda i6509
  5404  fabb c90f               	cmp #irom		; all slots full...exit
  5405  fabd f024               	beq size
  5406  fabf a002               	ldy #2			; always start at $0002, sal/sah already $0000
  5407  fac1 b193               siz100: lda (sal),y
  5408  fac3 aa                 	tax			; save memory value in X 
  5409  fac4 a955               	lda #$55		; test with $55
  5410  fac6 9193               	sta (sal),y
  5411  fac8 b193               	lda (sal),y
  5412  faca c955               	cmp #$55		; check if $55 
  5413  facc d015               	bne size		; end test if different
  5414  face 0a                 	asl			; test with $AA
  5415  facf 9193               	sta (sal),y
  5416  fad1 b193               	lda (sal),y
  5417  fad3 c9aa               	cmp #$AA		; check if $AA
  5418  fad5 d00c               	bne size		; end test if different
  5419  fad7 8a                 	txa
  5420  fad8 9193               	sta (sal),y		; restore old memory value from X
  5421                          !ifdef FULL_RAMTEST{		; ********** Full RAM-test **********
  5422                          	iny
  5423                          	bne siz100		; test next byte
  5424                          } else{				; ********** Fast RAM-test PATCH **********
  5425  fada ea                 	nop
  5426  fadb ea                 	nop
  5427  fadc ea                 	nop
  5428                          }
  5429  fadd e694               	inc sah
  5430  fadf d0e0               	bne siz100		; test next page
  5431  fae1 f0d4               	beq sizlop		; test next bank
  5432                          
  5433                          ; set top of memory
  5434  fae3 a601               size:   ldx i6509		; bank number of failure
  5435  fae5 ca                 	dex			; back up one segment
  5436  fae6 8a                 	txa			; .a= bank#
  5437  fae7 a2ff               	ldx #$FF
  5438                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5439  fae9 a0fd               	ldy #$FD		; reserve top two pages for swapping system
  5440  faeb 8d5703             	sta hiadr+2		; set system top of memory = $FDFF
  5441  faee 8c5603             	sty hiadr+1
  5442  faf1 8e5503             	stx hiadr
  5443                          
  5444                          ; allocate 3 pages (512funcs,256rs232)
  5445  faf4 a0fa               	ldy #$FD-3		; user memory top = $FAFF
  5446                          } else{
  5447                          	ldy #$FE		; reserve top page for swapping system
  5448                          	sta hiadr+2		; set system top of memory = $FEFF
  5449                          	sty hiadr+1
  5450                          	stx hiadr
  5451                          
  5452                          ; allocate 3 pages (512funcs,256rs232)
  5453                          	ldy #$FE-3		; user memory top = $FBFF
  5454                          }
  5455  faf6 18                 	clc
  5456  faf7 2087fb             	jsr memtop              ; set user top of memory
  5457                          
  5458                          ; flag buffers as not assigned =>$ff
  5459  fafa c6a8               	dec ribuf+2             ; init rs232 buffer bank to $FF
  5460  fafc c6a5               	dec tape1+2             ; init tape buffer bank to $FF
  5461  fafe a96b               	lda #<nocass		; set up cassette indirects to $FE6B
  5462  fb00 8d6a03             	sta itape
  5463  fb03 a9fe               	lda #>nocass
  5464  fb05 8d6b03             	sta itape+1
  5465  fb08 60                 	rts
  5466                          ; -------------------------------------------------------------------------------------------------
  5467                          ; FB09 standard vector table - initialized at boot from restor sub to cinv $0300
  5468  fb09 f8fb               jmptab: !word yirq		; FB09 -> FBF8 cinv	
  5469  fb0b 21ee               	!word timb		; FB0B -> EE21 cbinv....brk goes to monitor
  5470  fb0d b8fc               	!word panic		; FB0D -> FCB8 no.....nminv !!!!!
  5471  fb0f c6f6               	!word nopen		; FB0F -> F6C6 open file
  5472  fb11 f4f5               	!word nclose		; FB11 -> F5F4 close file
  5473  fb13 50f5               	!word nchkin		; FB13 -> F550 open channel in
  5474  fb15 aaf5               	!word nckout		; FB15 -> F5AA open channel out
  5475  fb17 adf6               	!word nclrch		; FB17 -> F6AD close channel
  5476  fb19 a3f4               	!word nbasin		; FB19 -> F4A3 input from channel
  5477  fb1b f5f4               	!word nbsout		; FB1B -> F4F5 output to channel
  5478  fb1d 72f9               	!word nstop		; FB1D -> F972 scan stop key
  5479  fb1f 44f4               	!word ngetin		; FB1F -> F444 scan keyboard
  5480  fb21 86f6               	!word nclall		; FB21 -> F686 close all files
  5481  fb23 4df7               	!word nload		; FB23 -> F74D load from file
  5482  fb25 53f8               	!word nsave		; FB25 -> F853 save to file
  5483  fb27 73ee               	!word s0		; FB27 -> EE73 monitor command parser
  5484  fb29 1fe0               	!word jescrt		; FB29 -> E01F esc key vector
  5485  fb2b 1fe0               	!word jescrt		; FB2B -> E01F user ctrl key vector
  5486  fb2d 7bf2               	!word nsecnd		; FB2D -> F27B IEEE listen secondary address
  5487  fb2f 87f2               	!word ntksa		; FB2F -> F287 IEEE talk secondary address
  5488  fb31 11f3               	!word nacptr		; FB31 -> F311 IEEE character in
  5489  fb33 9ef2               	!word nciout		; FB33 -> F29E IEEE character out
  5490  fb35 b2f2               	!word nuntlk		; FB35 -> F2B2 IEEE untalk bus
  5491  fb37 b6f2               	!word nunlsn		; FB37 -> F2B6 IEEE unlisten bus
  5492  fb39 3bf2               	!word nlistn		; FB39 -> F23B IEEE listen a device
  5493  fb3b 37f2               	!word ntalk		; FB3B -> F237 IEEE talk to a device
  5494                          tabend:
  5495                          ; -------------------------------------------------------------------------------------------------
  5496                          ; FB3D NMI entry, jumps indirect to NMI routine
  5497  fb3d 6c0403             nmi:    jmp (nminv)             ; ($0304) default -> panic = $FCB8
  5498                          ; -------------------------------------------------------------------------------------------------
  5499                          ; FB40 Set file name address
  5500                          ; .a = filename length
  5501                          ; .x = zero page location of 3 byte address
  5502  fb40 859d               setnam: sta fnlen		; store length
  5503  fb42 b500               	lda $00,x		; load and store address
  5504  fb44 8590               	sta fnadr
  5505  fb46 b501               	lda $01,x
  5506  fb48 8591               	sta fnadr+1
  5507  fb4a b502               	lda $02,x
  5508  fb4c 8592               	sta fnadr+2
  5509  fb4e 60                 	rts
  5510                          ; -------------------------------------------------------------------------------------------------
  5511                          ; FB4F Set file paramaters
  5512                          ; .a = logical address
  5513                          ; .x = first address
  5514                          ; .y = secundary address
  5515  fb4f 859e               setlfs: sta la
  5516  fb51 869f               	stx fa
  5517  fb53 84a0               	sty sa
  5518  fb55 60                 	rts
  5519                          ; -------------------------------------------------------------------------------------------------
  5520                          ; FB56 Read/write status
  5521                          ; carry set -- read device status into .a
  5522  fb56 901b               readst: bcc storst
  5523  fb58 a59f               	lda fa			; see which devices' to read
  5524  fb5a c902               	cmp #2
  5525  fb5c d00e               	bne readss		; not rs-232
  5526  fb5e ad7a03             	lda rsstat		; yes get it and remember it
  5527  fb61 48                 	pha
  5528  fb62 a900               	lda #00		; clear status when read
  5529  fb64 8d7a03             	sta rsstat
  5530  fb67 68                 	pla			; get status from stack
  5531  fb68 60                 	rts
  5532                          ; FB69 Set the system message flag
  5533  fb69 8d6103             setmsg: sta msgflg
  5534  fb6c a59c               readss: lda status		; read status
  5535                          ; set status bit
  5536  fb6e 059c               udst:   ora status		; set bit and store status
  5537  fb70 859c               	sta status
  5538  fb72 60                 	rts
  5539                          ; carry clear -- set device status with .a
  5540  fb73 48                 storst: pha
  5541  fb74 a59f               	lda fa
  5542  fb76 c902               	cmp #2
  5543  fb78 d005               	bne storss		; not rs-232
  5544  fb7a 68                 	pla
  5545  fb7b 8d7a03             	sta rsstat		; store rs-232 status
  5546  fb7e 60                 	rts
  5547                          
  5548  fb7f 68                 storss: pla
  5549  fb80 859c               	sta status		; store status
  5550  fb82 60                 	rts
  5551                          ; -------------------------------------------------------------------------------------------------
  5552                          ; FB83 IEC timeout on/off
  5553  fb83 8d5e03             settmo: sta timout
  5554  fb86 60                 	rts
  5555                          ; -------------------------------------------------------------------------------------------------
  5556                          ; FB87 Read/set top of memory
  5557  fb87 9009               memtop: bcc settop
  5558                          
  5559                          ; carry set--read top of memory
  5560  fb89 ad5d03             	lda memsiz+2		; load user memory top in .a.x.y
  5561  fb8c ae5b03             	ldx memsiz
  5562  fb8f ac5c03             	ldy memsiz+1
  5563                          
  5564                          ; carry clear--set top of memory
  5565  fb92 8e5b03             settop: stx memsiz		; set user memory top
  5566  fb95 8c5c03             	sty memsiz+1
  5567  fb98 8d5d03             	sta memsiz+2
  5568  fb9b 60                 	rts
  5569                          ; -------------------------------------------------------------------------------------------------
  5570                          ; FB9C Manage bottom of memory
  5571  fb9c 9009               membot: bcc setbot
  5572                          
  5573                          ; carry set--read bottom of memory
  5574  fb9e ad5a03             	lda memstr+2		; load bottom mem in .a.x.y
  5575  fba1 ae5803             	ldx memstr
  5576  fba4 ac5903             	ldy memstr+1
  5577                          
  5578                          ; carry clear--set bottom of memory
  5579  fba7 8e5803             setbot: stx memstr		; set bottom mem
  5580  fbaa 8c5903             	sty memstr+1
  5581  fbad 8d5a03             	sta memstr+2
  5582  fbb0 60                 	rts
  5583                          ; -------------------------------------------------------------------------------------------------
  5584                          ; FBB1 Restore ram i/o vectors at $0300
  5585  fbb1 a209               restor: ldx #<jmptab		; load vector table address in kernal
  5586  fbb3 a0fb               	ldy #>jmptab
  5587  fbb5 a90f               	lda #irom
  5588  fbb7 18                 	clc
  5589                          
  5590                          ; FBB8 Manage ram i/o vectors
  5591  fbb8 8693               vector: stx sal			; store address
  5592  fbba 8494               	sty sah
  5593  fbbc a601               	ldx i6509		; save indirect
  5594  fbbe 8501               	sta i6509		; set ibank .a 
  5595  fbc0 900a               	bcc vect50		; carry=0 -> set/restore table
  5596                          
  5597                          ; carry set--read vectors
  5598  fbc2 a033               	ldy #tabend-jmptab-1
  5599  fbc4 b90003             vect20: lda cinv,y		; from ram table $F0300
  5600  fbc7 9193               	sta (sal),y		; into user area
  5601  fbc9 88                 	dey
  5602  fbca 10f8               	bpl vect20
  5603                          
  5604                          ; carry clear--set vectors
  5605  fbcc a033               vect50: ldy #tabend-jmptab-1
  5606  fbce b193               vect60: lda (sal),y		; from user area
  5607  fbd0 990003             	sta cinv,y		; into ram table $F0300
  5608  fbd3 88                 	dey
  5609  fbd4 10f8               	bpl vect60
  5610                          
  5611  fbd6 8601               	stx i6509		; restore indirect
  5612  fbd8 60                 	rts
  5613                          ; -------------------------------------------------------------------------------------------------
  5614                          ; FBD9 vreset - reset vector flags and control
  5615                          ;   .x - low vector address  .y - high vector address
  5616  fbd9 8ef803             vreset: stx evect
  5617  fbdc 8cf903             	sty evect+1
  5618  fbdf a95a               	lda #winit
  5619  fbe1 8dfb03             	sta evect+3
  5620  fbe4 60                 	rts
  5621                          ; -------------------------------------------------------------------------------------------------
  5622                          ; ##### irq #####
  5623                          ;**********************************************
  5624                          ;* nirq - handler for:       10/30/81 rsr     *
  5625                          ;* 6525 irq's:::::::::::::::::::::::::::::::::*
  5626                          ;* 6551 irq's                                 *
  5627                          ;*   (receiver,transmitter,dcd & dsr changes) *
  5628                          ;* 6526 irq's                                 *
  5629                          ;*   (alarm, timera, timerb)                  *
  5630                          ;* 6526 irq's                                 *
  5631                          ;*   (2nd processor)                          *
  5632                          ;* ieee srq                                   *
  5633                          ;* keyboard scan (50/60hz irq)                *
  5634                          ;*                                            *
  5635                          ;* also at present does not handle any of the *
  5636                          ;* 6566 (vic) interrupts.                     *
  5637                          ;**********************************************
  5638                          ; FBE5 IRQ handler
  5639  fbe5 48                 nirq:	pha			; save registers
  5640  fbe6 8a                 	txa
  5641  fbe7 48                 	pha
  5642  fbe8 98                 	tya
  5643  fbe9 48                 	pha
  5644  fbea ba                 	tsx			; check for brk...
  5645  fbeb bd0401             	lda stack+4,x
  5646  fbee 2910               	and #$10
  5647  fbf0 d003               	bne brkirq		; yes...
  5648  fbf2 6c0003             	jmp (cinv)		; via vector -> yirq $FBF8
  5649  fbf5 6c0203             brkirq: jmp (cbinv)		; yes...
  5650                          
  5651                          ; FBF8 entry via indirect vector cinv
  5652  fbf8 a501               yirq:   lda i6509		; save indirect bank #
  5653  fbfa 48                 	pha
  5654                          	;lda pass	; external break handler
  5655                          	;pha
  5656                          	;lda #0 	; clear for normal return
  5657                          	;sta pass
  5658  fbfb d8                 	cld			; clear dec to prevent future problems
  5659  fbfc ad07de             	lda tpi1+air
  5660  fbff d003               	bne irq000		; handle priority irq's
  5661                          
  5662                          ; external irq (vic and others)
  5663                          ;  (no code!!!!!!!!!!)
  5664  fc01 4cb0fc             	jmp prendn
  5665                          
  5666                          ; FC04 Check for ACIA IRQ
  5667  fc04 c910               irq000:	cmp #$10		; find irq source
  5668  fc06 f003               	beq irq002		; not 6551...
  5669  fc08 4c69fc             	jmp irq100
  5670                          
  5671                          ; 6551 interrupt handler
  5672  fc0b ad01dd             irq002:	lda acia+srsn		; find irq source
  5673  fc0e aa                 	tax
  5674  fc0f 2960               	and #$60		; dcd/dsr changes ??
  5675  fc11 a8                 	tay
  5676  fc12 4d7b03             	eor dcdsr
  5677  fc15 f00d               	beq irq004		; no change...
  5678  fc17 98                 	tya
  5679  fc18 8d7b03             	sta dcdsr		; update old dsr/dcd status
  5680  fc1b 0d7a03             	ora rsstat		; update rs232 status
  5681  fc1e 8d7a03             	sta rsstat
  5682  fc21 4cadfc             	jmp irq900		; done!
  5683                          ;
  5684  fc24 8a                 irq004:	txa
  5685  fc25 2908               	and #$08		; receiver ??
  5686  fc27 f025               	beq irq010		; no...
  5687                          
  5688                          ; receiver service
  5689  fc29 ac7d03             	ldy ridbe		; check buffers
  5690  fc2c c8                 	iny
  5691  fc2d cc7c03             	cpy ridbs		; have we passed start?
  5692  fc30 d004               	bne irq005		; no...
  5693                          
  5694  fc32 a908               	lda #doverr		; input buffer full error
  5695  fc34 d012               	bne irq007		; bra...set status
  5696                          
  5697  fc36 8c7d03             irq005:	sty ridbe		; move end foward
  5698  fc39 88                 	dey
  5699  fc3a a6a8               	ldx ribuf+2
  5700  fc3c 8601               	stx i6509
  5701                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5702  fc3e ae01dd             	ldx acia+srsn		; get status register
  5703  fc41 2052ff             	jsr patch2		; moved to end because 1 byte missing here
  5704  fc44 8a                 	txa			; set status
  5705  fc45 ea                 	nop
  5706                          } else{
  5707                          	lda acia+drsn
  5708                          	sta (ribuf),y		; data to buffer
  5709                          	lda acia+srsn		; get status register
  5710                          }
  5711  fc46 2907               	and #$07
  5712  fc48 0d7a03             irq007:	ora rsstat		; set status
  5713  fc4b 8d7a03             	sta rsstat
  5714                          
  5715  fc4e ad01dd             irq010:	lda acia+srsn		; find irq source
  5716  fc51 2910               	and #$10		; transmitter ?
  5717  fc53 f011               	beq irq090		; no...
  5718  fc55 ad02dd             	lda acia+cdr		; check for transmitter on
  5719  fc58 290c               	and #$0c
  5720  fc5a c904               	cmp #$04		; bits(32)=01 => xmitter int enabled
  5721  fc5c d008               	bne irq090		; off...
  5722                          
  5723                          ; transmitter service (no interrrupt driven transmissions)
  5724  fc5e a9f3               	lda #%11110011		; turn of transmitter
  5725  fc60 2d02dd             	and acia+cdr
  5726  fc63 8d02dd             	sta acia+cdr
  5727  fc66 4cadfc             irq090:	jmp irq900		; exit..pop priority...
  5728                          
  5729                          ; FC69 Check for coprozessor IRQ
  5730  fc69 c908               irq100:	cmp #$08		; check if inter-process irq
  5731  fc6b d00a               	bne irq110		; no...
  5732  fc6d ad0ddb             	lda ipcia+icr		; clear irq condition
  5733  fc70 58                 	cli			; this irq can be interrupted
  5734  fc71 2056fd             	jsr ipserv		; do the request
  5735  fc74 4cadfc             	jmp irq900		; done!
  5736                          
  5737                          ; FC77 Check for CIA IRQ
  5738  fc77 58                 irq110:	cli			; all other irq's may be interrupted, too
  5739  fc78 c904               	cmp #$04		; check if 6526
  5740  fc7a d00c               	bne irq200		; no...
  5741                          
  5742                          ; 6526 interrupt reconized
  5743  fc7c ad0ddc             	lda cia+icr		; get active interrupts
  5744  fc7f 0d6903             	ora alarm		; in case we lose something
  5745  fc82 8d6903             	sta alarm
  5746                          
  5747                          ; nothing to do at present....need code ********
  5748  fc85 4cadfc             	jmp irq900		; ...dump interrupt
  5749                          
  5750                          ; FC88 Check for IEC bus IRQ (and ignore it)
  5751  fc88 c902               irq200:	cmp #$02		; check for ieee srq
  5752  fc8a d003               	bne irq300
  5753                          
  5754                          ; need code ************
  5755  fc8c 4cadfc             	jmp irq900		; ...dump interrupt
  5756                          
  5757                          ; FC8F Must be a 50/60Hz IRQ - poll keyboard, update time
  5758  fc8f 2013e0             irq300:	jsr jkey		; scan the keyboard
  5759  fc92 2080f9             	jsr udtim		; set stopkey flag
  5760                          
  5761                          ; test for cassette switch
  5762  fc95 ad01de             	lda tpi1+pb		; get cass switch
  5763  fc98 1009               	bpl irq310		; switch is down...
  5764  fc9a a000               	ldy #0			; flag motor off...
  5765  fc9c 8c7503             	sty cas1
  5766  fc9f 0940               	ora #$40		; turn motor off...
  5767  fca1 d007               	bne irq320		; jump
  5768  fca3 ac7503             irq310:	ldy cas1		; test for flag on...
  5769  fca6 d005               	bne irq900		; yes computer control..leave alone
  5770  fca8 29bf               	and #$FF-$40		; turn motor on...
  5771  fcaa 8d01de             irq320:	sta tpi1+pb		; store mods into port
  5772                          
  5773  fcad 8d07de             irq900:	sta tpi1+air		; pop the interrupt...
  5774                          
  5775                          prendn: ;lda pass	; check for foriegn call
  5776                          	;bne segrti	; yes...return
  5777                          	;pla
  5778                          	;sta pass	; restore interrupted interrupt
  5779  fcb0 68                 	pla             ;restore registers
  5780  fcb1 8501               	sta i6509
  5781  fcb3 68                 prend:	pla			; entry point for register only
  5782  fcb4 a8                 	tay
  5783  fcb5 68                 	pla
  5784  fcb6 aa                 	tax
  5785  fcb7 68                 	pla
  5786                          
  5787                          ; Default NMI routine
  5788  fcb8 40                 panic:	rti			; come here if no new nmi vector.
  5789                          ; -------------------------------------------------------------------------------------------------
  5790                          ; send a request
  5791                          ;   enter:   ipb buffer is initialized to hold the
  5792                          ;            command
  5793                          ;            input parameter bytes
  5794                          ;
  5795                          ;   exit:    ipb buffer holds
  5796                          ;            output parameter bytes
  5797                          ;            all other bytes in ipb unchanged
  5798                          ;---------------------------------------------------------------
  5799                          ; FCB9 Coprocessor request
  5800  fcb9 ad0008             iprqst:	lda ipb+ipccmd
  5801  fcbc 297f               	and #$7F
  5802  fcbe a8                 	tay
  5803  fcbf 202ffe             	jsr getpar		; get #ins,outs
  5804  fcc2 a904               	lda #sem88		; check 8088 semaphore
  5805  fcc4 2d01db             	and ipcia+prb
  5806  fcc7 d0f0               	bne iprqst		; locked out by other processor
  5807  fcc9 a908               	lda #sem65
  5808  fccb 0d01db             	ora ipcia+prb		; lock 6509 semaphore
  5809  fcce 8d01db             	sta ipcia+prb
  5810  fcd1 ea                 	nop			; a pause
  5811                          
  5812  fcd2 ad01db             	lda ipcia+prb		; collisions with 8088?
  5813  fcd5 aa                 	tax
  5814  fcd6 2904               	and #sem88
  5815  fcd8 f00c               	beq ipr100		; ok...
  5816  fcda 8a                 	txa
  5817  fcdb 4908               	eor #sem65
  5818  fcdd 8d01db             	sta ipcia+prb		; nope, clear 6509 semaphore
  5819  fce0 8a                 	txa			; kill some time
  5820  fce1 ea                 	nop
  5821  fce2 ea                 	nop
  5822  fce3 ea                 	nop
  5823  fce4 d0d3               	bne iprqst		; try again (br always)
  5824                          
  5825                          ;     send cmd byte and cause irq
  5826  fce6 a9ff               ipr100: lda #$FF
  5827  fce8 8d02db             	sta ipcia+ddra		; port direction = out
  5828  fceb ad0008             	lda ipb+ipccmd
  5829  fcee 8d00db             	sta ipcia+pra		; write cmd byte to port
  5830                          ; cause irq
  5831  fcf1 2016fe             	jsr frebus		; give up bus
  5832  fcf4 ad01db             	lda ipcia+prb		; pb6 := 0
  5833  fcf7 29bf               	and #$BF
  5834  fcf9 8d01db             	sta ipcia+prb
  5835  fcfc 0940               	ora #$40		; keep low for 4us (8 cycles)
  5836  fcfe 58                 	cli
  5837  fcff ea                 	nop
  5838  fd00 ea                 	nop
  5839  fd01 ea                 	nop
  5840  fd02 8d01db             	sta ipcia+prb		; pb6 := high
  5841                          
  5842  fd05 20fcfd             	jsr waithi		; sem8088 -> hi (cmd byte recvd)
  5843  fd08 a900               	lda #$00
  5844  fd0a 8d02db             	sta ipcia+ddra		; port direction = in
  5845  fd0d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5846  fd10 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5847                          
  5848                          ;    send data bytes, if any
  5849  fd13 a000               	ldy #0
  5850  fd15 f01d               	beq ipr250		; always
  5851                          
  5852  fd17 a9ff               ipr200:	lda #$FF
  5853  fd19 8d02db             	sta ipcia+ddra		; port direction = out
  5854  fd1c b90508             	lda ipb+ipcdat,y	; get next data byte
  5855  fd1f 8d00db             	sta ipcia+pra		; write cmd out
  5856  fd22 200dfe             	jsr ackhi		; sem6509 -> hi (data ready)
  5857  fd25 20fcfd             	jsr waithi		; sem8088 -> hi (data recvd)
  5858  fd28 a900               	lda #$00
  5859  fd2a 8d02db             	sta ipcia+ddra		; port direction = in
  5860  fd2d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5861  fd30 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5862  fd33 c8                 	iny			; bump index to next data byte
  5863  fd34 cc0308             ipr250:	cpy ipb+ipcin		; any more ??
  5864  fd37 d0de               	bne ipr200		; yes...
  5865                          
  5866                          ;    receive data bytes, if any
  5867  fd39 a000               	ldy #0
  5868  fd3b f013               	beq ipr350		; always
  5869                          
  5870  fd3d 200dfe             ipr300:	jsr ackhi		; sem6509 -> hi (rdy to receive)
  5871  fd40 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5872  fd43 ad00db             	lda ipcia+pra		; get data from port
  5873  fd46 990508             	sta ipb+ipcdat,y	; stuff it away
  5874  fd49 2004fe             	jsr acklo		; sem6509 -> lo (data recvd)
  5875  fd4c 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5876  fd4f c8                 	iny
  5877                          
  5878  fd50 cc0408             ipr350:	cpy ipb+ipcout		; more?
  5879  fd53 d0e8               	bne ipr300		; yes...
  5880  fd55 60                 	rts			; done!!
  5881                          ; -------------------------------------------------------------------------------------------------
  5882                          ; service an 8088 request
  5883                          ;-------------------------------------------------------------------
  5884                          ; FD56 Coprocessor irq handler
  5885                          ipserv: ;ldy #ipbsiz-1	; copy ip buffer to stack
  5886                          	;ips050 lda ipb,y
  5887                          	; pha
  5888                          	; dey
  5889                          	; bpl ips050
  5890                          
  5891  fd56 a900               	lda #0
  5892  fd58 8d02db             	sta ipcia+ddra		; port dir=in, just in case...
  5893  fd5b ad00db             	lda ipcia+pra		; read cmd from port
  5894  fd5e 8d0008             	sta ipb+ipccmd		; store cmd and decode it
  5895  fd61 297f               	and #$7F		; mask off bus bit
  5896  fd63 a8                 	tay
  5897  fd64 202ffe             	jsr getpar		; get param counts
  5898  fd67 98                 	tya			; adjust offset for jump table
  5899  fd68 0a                 	asl
  5900  fd69 a8                 	tay
  5901  fd6a b91008             	lda ipjtab,y		; jump address(lo)
  5902  fd6d 8d0108             	sta ipb+ipcjmp
  5903  fd70 c8                 	iny
  5904  fd71 b91008             	lda ipjtab,y		; jump address (hi)
  5905  fd74 8d0208             	sta ipb+ipcjmp+1
  5906  fd77 200dfe             	jsr ackhi		; sem6509 -> hi (cmd recvd)
  5907  fd7a 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5908                          
  5909                          ;    receive input bytes, if any
  5910  fd7d a000               	ldy #0
  5911                          
  5912  fd7f cc0308             ips100:	cpy ipb+ipcin		; any more?
  5913  fd82 f015               	beq ips200		; no...
  5914  fd84 2004fe             	jsr acklo		; sem6509 ->lo (ack ack)
  5915  fd87 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5916  fd8a ad00db             	lda ipcia+pra		; read data byte
  5917  fd8d 990508             	sta ipb+ipcdat,y	; store it
  5918  fd90 200dfe             	jsr ackhi		; sem6509 -> hi (data recvd)
  5919  fd93 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5920  fd96 c8                 	iny
  5921  fd97 d0e6               	bne ips100		; always...
  5922                          
  5923                          ;    process cmd
  5924  fd99 2c0008             ips200:	bit ipb+ipccmd		; cmd requires bus?
  5925  fd9c 3033               	bmi ips500		; yes...
  5926  fd9e a9fd               	lda #>ipsret		; push return
  5927  fda0 48                 	pha
  5928  fda1 a9a6               	lda #<ipsret
  5929  fda3 48                 	pha
  5930  fda4 6c0108             	jmp (ipb+ipcjmp)	; gone!!!
  5931                          
  5932                          ;    send return bytes, if any
  5933                          ips300:
  5934                          ipsret=ips300-1
  5935  fda7 2004fe             	jsr acklo		; sem6509 -> lo
  5936  fdaa a000               	ldy #0
  5937  fdac f01d               	beq ips350		; always
  5938                          ips310:
  5939  fdae 20fcfd             	jsr waithi		; sem8088 -> hi (8088 rdy to recv)
  5940  fdb1 a9ff               	lda #$FF
  5941  fdb3 8d02db             	sta ipcia+ddra		; port direction = out
  5942  fdb6 b90508             	lda ipb+ipcdat,y
  5943  fdb9 8d00db             	sta ipcia+pra		; write data to port
  5944  fdbc 200dfe             	jsr ackhi		; sem6509 -> hi (data available)
  5945  fdbf 20f4fd             	jsr waitlo		; sem8088 -> lo (data recvd)
  5946  fdc2 a900               	lda #0
  5947  fdc4 8d02db             	sta ipcia+ddra		; port direction = in
  5948  fdc7 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5949  fdca c8                 	iny
  5950  fdcb cc0408             ips350:	cpy ipb+ipcout		; any more?
  5951  fdce d0de               	bne ips310		; yes, repeat...
  5952                          
  5953                          ips400:	;ldy #0
  5954                          	;ips450 pla	; restore ip buffer
  5955                          	; sta ipb,y
  5956                          	; iny
  5957                          	; cpy #ipbsiz
  5958                          	; bne ips450
  5959  fdd0 60                 	rts			; done!
  5960                          
  5961                          ;      special,   for commands requiring the bus
  5962  fdd1 a9fd               ips500:	lda #>buret
  5963  fdd3 48                 	pha
  5964  fdd4 a9dc               	lda #<buret
  5965  fdd6 48                 	pha			; push return
  5966  fdd7 201ffe             	jsr getbus		; grab bus
  5967  fdda 6c0108             	jmp (ipb+ipcjmp)	; gone!
  5968                          
  5969                          ips600:
  5970                          buret=ips600-1
  5971  fddd 2016fe             	jsr frebus		; give up bus
  5972  fde0 ad0408             	lda ipb+ipcout		; #bytes to return
  5973  fde3 8d0308             	sta ipb+ipcin
  5974  fde6 8d0008             	sta ipb+ipccmd		; return op=#bytes to return
  5975  fde9 a900               	lda #0
  5976  fdeb 8d0408             	sta ipb+ipcout		; just send to 8088
  5977  fdee 20b9fc             	jsr iprqst
  5978  fdf1 4cd0fd             	jmp ips400		; done!
  5979                          
  5980                          ; FDF4 waitlo - wait until sem88 goes low
  5981  fdf4 ad01db             waitlo:	lda ipcia+prb
  5982  fdf7 2904               	and #sem88
  5983  fdf9 d0f9               	bne waitlo
  5984  fdfb 60                 	rts
  5985                          ; waithi - wait until sem88 goes high
  5986                          
  5987  fdfc ad01db             waithi:	lda ipcia+prb
  5988  fdff 2904               	and #sem88
  5989  fe01 f0f9               	beq waithi
  5990  fe03 60                 	rts
  5991                          
  5992                          ; acklo - acknowlegde sem65 low
  5993  fe04 ad01db             acklo:	lda ipcia+prb
  5994  fe07 29f7               	and #$FF-sem65
  5995  fe09 8d01db             	sta ipcia+prb
  5996  fe0c 60                 	rts
  5997                          
  5998                          ; ackhi - acknowledge sem6509 hi
  5999  fe0d a908               ackhi:	lda #sem65
  6000  fe0f 0d01db             	ora ipcia+prb
  6001  fe12 8d01db             	sta ipcia+prb
  6002  fe15 60                 	rts
  6003                          
  6004                          ; frebus - give up bus
  6005  fe16 ad01de             frebus:	lda tpi1+pb		; pb4 := 0
  6006  fe19 29ef               	and #$EF
  6007  fe1b 8d01de             	sta tpi1+pb
  6008  fe1e 60                 	rts
  6009                          
  6010                          ; getbus - grab bus
  6011                          getbus:
  6012  fe1f ad01db             	lda ipcia+prb		; check nbusy2
  6013  fe22 2902               	and #$02
  6014  fe24 f0f9               	beq getbus		; 2nd proc not off
  6015                          
  6016  fe26 ad01de             	lda tpi1+pb		; pb4 := 1
  6017  fe29 0910               	ora #$10
  6018  fe2b 8d01de             	sta tpi1+pb
  6019  fe2e 60                 	rts
  6020                          
  6021                          ; getpar
  6022                          ;  enter - .y = table offset
  6023                          ;  exit:   .y = table offset
  6024                          ;          #ins,#outs put into ipb buffer
  6025  fe2f b91009             getpar:	lda ipptab,y		; break apart nibbles
  6026  fe32 48                 	pha
  6027  fe33 290f               	and #$0F
  6028  fe35 8d0308             	sta ipb+ipcin		; #input bytes
  6029  fe38 68                 	pla
  6030  fe39 4a                 	lsr
  6031  fe3a 4a                 	lsr
  6032  fe3b 4a                 	lsr
  6033  fe3c 4a                 	lsr
  6034  fe3d 8d0408             	sta ipb+ipcout		; #output bytes
  6035  fe40 60                 	rts
  6036                          
  6037                          ; ipcgo - free bus, interrupt 2nd processor
  6038                          ;         go into a loop, waiting for requests.
  6039                          ;  * returns if bus error occurs
  6040  fe41 a2ff               ipcgo:	ldx #$FF
  6041  fe43 8601               	stx i6509		; indirects to bank f only
  6042  fe45 ad01de             	lda tpi1+pb		; tpi1 pb4:=0 frees dbus
  6043  fe48 29ef               	and #$EF
  6044  fe4a 8d01de             	sta tpi1+pb
  6045  fe4d ea                 	nop			; a pause
  6046  fe4e ad01db             	lda ipcia+prb		; check nbusy1
  6047  fe51 6a                 	ror
  6048  fe52 b001               	bcs ipcgx
  6049  fe54 60                 	rts			; bus not free!, error...
  6050                          
  6051  fe55 a900               ipcgx:	lda #0			; pb6 lo->hi in 4us...
  6052  fe57 78                 	sei
  6053  fe58 8d01db             	sta ipcia+prb		; interrupt 2nd processeor
  6054  fe5b a940               	lda #$40		; 2 cycles (4us=8cycles)
  6055  fe5d ea                 	nop
  6056  fe5e ea                 	nop
  6057  fe5f ea                 	nop
  6058  fe60 ea                 	nop			; 8 cycles of garb. 5us safer than 4!
  6059  fe61 8d01db             	sta ipcia+prb		; turn pb6 back on
  6060  fe64 58                 	cli
  6061  fe65 4c65fe             iploop:	jmp iploop		; sit down
  6062                          ; -------------------------------------------------------------------------------------------------
  6063                          ; FE68 no cassette routines avaliable
  6064  fe68 6c6a03             xtape:	jmp     (itape)		; goto tape device indirect -> nocass
  6065                          ;
  6066  fe6b 68                 nocass:	pla			; remove jsr xtape and return
  6067  fe6c 68                 	pla
  6068  fe6d 4c4cf9             	jmp error5		; send back ?device not present
  6069                          ; -------------------------------------------------------------------------------------------------
  6070                          ; some needed routines
  6071                          ; FE70 
  6072  fe70 a59a               rd300:	lda stah
  6073  fe72 8594               	sta sah
  6074  fe74 a599               	lda stal
  6075  fe76 8593               	sta sal
  6076  fe78 a59b               	lda stas
  6077  fe7a 8595               	sta sas
  6078  fe7c 8501               	sta i6509
  6079  fe7e 60                 	rts
  6080                          ; FE7F 
  6081  fe7f 38                 cmpste: sec
  6082  fe80 a593               	lda sal
  6083  fe82 e596               	sbc eal
  6084  fe84 a594               	lda sah
  6085  fe86 e597               	sbc eah
  6086  fe88 a595               	lda sas
  6087  fe8a e598               	sbc eas
  6088  fe8c 60                 	rts
  6089                          !ifndef CBMPATCH{
  6090                          ; FE8D
  6091                          incsal: inc sal
  6092                          	bne incr20
  6093                          	inc sah
  6094                          	bne incr20
  6095                          	inc sas
  6096                          	lda sas
  6097                          	sta i6509
  6098                          	lda #$02		; skip $0000 and $0001
  6099                          	sta sal
  6100                          incr20:	rts
  6101                          }
  6102                          ; -------------------------------------------------------------------------------------------------
  6103                          ;-------------------------------------
  6104                          ; tapery - get from the tape buffer
  6105                          ;   lda (tape1)y ;replacement
  6106                          ;-------------------------------------
  6107                          ;tapiry iny
  6108                          ;tapery ldx i6509
  6109                          ; lda tape1+2
  6110                          ; sta i6509
  6111                          ; lda (tape1)y
  6112                          ; stx i6509
  6113                          ; rts
  6114                          ;-------------------------------------
  6115                          ; tapewy - put char in the tape buffer
  6116                          ;   sta (tape1)y ;replacement
  6117                          ;-------------------------------------
  6118                          ;tapzwy ldy #$ff ;first byte in buffer
  6119                          ;tapiwy iny ;auto inc into buffer
  6120                          ;tapewy ldx i6509
  6121                          ; pha
  6122                          ; lda tape1+2
  6123                          ; sta i6509
  6124                          ; pla
  6125                          ; sta (tape1)y
  6126                          ; stx i6509
  6127                          ; rts
  6128                          ;-------------------------------------
  6129                          ; fnadry - get from file name buffer
  6130                          ;   lda (fnadr)y ;replacement
  6131                          ;-------------------------------------
  6132                          ; FEA0 Load a byte from the file name
  6133  fe8d a601               fnadry: ldx i6509
  6134  fe8f a592               	lda fnadr+2
  6135  fe91 8501               	sta i6509
  6136  fe93 b190               	lda (fnadr),y
  6137  fe95 8601               	stx i6509
  6138  fe97 60                 	rts
  6139                          ; -------------------------------------------------------------------------------------------------
  6140                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6141                          *= $FE9D
  6142                          ; ##### transx #####
  6143                          ; txjmp - transfer-of-execution jumper
  6144                          ;   entry - .a=seg # .x=low .y=high
  6145                          ;   caller must be a jsr txjmp
  6146                          ;   all registers and i6509 destroyed
  6147                          ;   returns directly to caller...
  6148  fe9d 8501               txjmp:	sta i6509		; bp routine
  6149  fe9f 8a                 	txa
  6150  fea0 18                 	clc
  6151  fea1 6902               	adc #2			; add 2 to target address
  6152  fea3 9001               	bcc txjmp1
  6153  fea5 c8                 	iny
  6154  fea6 aa                 txjmp1:	tax
  6155  fea7 98                 	tya
  6156  fea8 48                 	pha			; store target+2 to stack
  6157  fea9 8a                 	txa
  6158  feaa 48                 	pha
  6159  feab 2019ff             	jsr ipinit		; go initilize ipoint
  6160  feae a9fe               	lda #$fe
  6161  feb0 91ac               	sta (ipoint),y		; $fe to top of foreign stack
  6162                          ; 04/14/83 bp
  6163                          ; transfer exec routines for cbm2
  6164                          }
  6165                          ; -------------------------------------------------------------------------------------------------
  6166                          ; FEAB Support routine for cross bank calls
  6167  feb2 08                 exsub:	php			; save status
  6168  feb3 78                 	sei			; disable interrupts
  6169  feb4 48                 	pha			; .a
  6170  feb5 8a                 	txa
  6171  feb6 48                 	pha			; .x
  6172  feb7 98                 	tya
  6173  feb8 48                 	pha			; .y
  6174  feb9 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6175  febc a8                 	tay			; .y is xfer seg stack pointer
  6176  febd a500               	lda e6509		; push return segment to user stack
  6177  febf 202aff             	jsr putas		; push .a to other stack
  6178  fec2 a904               	lda #<excrt2		; xfer seg rts routn
  6179  fec4 a2ff               	ldx #>excrt2		; xfer seg rts routn
  6180  fec6 2024ff             	jsr putaxs		; put .a.x to xfer seg stack
  6181  fec9 ba                 	tsx
  6182  feca bd0501             	lda stack+5,x		; .sp +5 is actual routn addr lo
  6183  fecd 38                 	sec
  6184  fece e903               	sbc #03			; -3 for jsr to this routn
  6185  fed0 48                 	pha			; save .a
  6186  fed1 bd0601             	lda stack+6,x		; hi addr
  6187  fed4 e900               	sbc #00	
  6188  fed6 aa                 	tax			; .x hi
  6189  fed7 68                 	pla			; restore .a lo
  6190  fed8 2024ff             	jsr putaxs		; save .a.x onto xfer seg stack
  6191  fedb 98                 	tya			; xfer seg stack pointer
  6192  fedc 38                 excomm:	sec
  6193  fedd e904               	sbc #04			; 4 bytes .y.x.a.p
  6194  fedf 8dff01             	sta stackp		; xfer seg new stack pointer temp storage
  6195  fee2 a8                 	tay			; use this as new pointer also
  6196  fee3 a204               	ldx #04			; 4 bytes .y.x.a.p
  6197  fee5 68                 exsu10:	pla
  6198  fee6 c8                 	iny
  6199  fee7 91ac               	sta (ipoint),y		; push regs from this stack to xfer seg stack
  6200  fee9 ca                 	dex
  6201  feea d0f9               	bne exsu10
  6202  feec acff01             	ldy stackp		; restore .y as stack pointer for xfer seg
  6203  feef a92d               	lda #<expul2		; pull regs and rts routn
  6204  fef1 a2ff               	ldx #>expul2		; .hi prendn routn in xfer seg
  6205  fef3 2024ff             	jsr putaxs		; put .a.x on xfer seg stack
  6206  fef6 68                 	pla			; fix stack
  6207  fef7 68                 	pla			; fix stack
  6208  fef8 ba                 exgby:	tsx
  6209  fef9 8eff01             	stx stackp		; save current stack pointer this seg
  6210  fefc 98                 	tya			; .y is stack pointer for xfer seg
  6211  fefd aa                 	tax
  6212  fefe 9a                 	txs			; new stack for xfer seg
  6213  feff a501               	lda i6509		; xfer seg #
  6214  ff01 4cf6ff             	jmp gbye		; good bye
  6215                          ; -------------------------------------------------------------------------------------------------
  6216  ff04 ea                 	nop			; returns here if rti
  6217                          ; FEFE Return from call to foreign bank
  6218  ff05 08                 excrts: php			; .p
  6219  ff06 08                 	php			; .p
  6220                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6221  ff07 78                 	sei             	; dis ints
  6222                          }
  6223  ff08 48                 	pha			; .a
  6224  ff09 8a                 	txa
  6225  ff0a 48                 	pha			; .x
  6226  ff0b 98                 	tya
  6227  ff0c 48                 	pha			; .y
  6228  ff0d ba                 	tsx
  6229  ff0e bd0601             	lda stack+6,x		; sp +6 is return seg
  6230  ff11 8501               	sta i6509		; restore i6509 to return seg
  6231  ff13 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6232  ff16 4cdcfe             	jmp excomm
  6233                          ; -------------------------------------------------------------------------------------------------
  6234                          ; FF11 ipoint = $100, Y = $FF (stack)
  6235  ff19 a001               ipinit: ldy #01
  6236  ff1b 84ad               	sty ipoint+1
  6237  ff1d 88                 	dey
  6238  ff1e 84ac               	sty ipoint		; ipoint=$0100
  6239  ff20 88                 	dey			; .y=$ff
  6240  ff21 b1ac               	lda (ipoint),y		; load stack pointer from $001ff
  6241  ff23 60                 	rts
  6242                          ; -------------------------------------------------------------------------------------------------
  6243                          ; FF1C Place X/A to ipoint (build stack in foreign bank)
  6244  ff24 48                 putaxs: pha			; save A
  6245  ff25 8a                 	txa
  6246  ff26 91ac               	sta (ipoint),y		; .x hi
  6247  ff28 88                 	dey
  6248  ff29 68                 	pla
  6249                          ; FF22 Place A to ipoint (build stack in foreign bank)
  6250  ff2a 91ac               putas:  sta (ipoint),y		; .a lo
  6251  ff2c 88                 	dey
  6252  ff2d 60                 	rts
  6253                          ; -------------------------------------------------------------------------------------------------
  6254                          ; FF26 Pull registers after calling subroutine in foreign bank
  6255  ff2e 68                 expull: pla
  6256  ff2f a8                 	tay			; .y
  6257  ff30 68                 	pla
  6258  ff31 aa                 	tax			; .x
  6259  ff32 68                 	pla			; .a
  6260  ff33 28                 	plp			; .p
  6261  ff34 60                 	rts
  6262                          ; -------------------------------------------------------------------------------------------------
  6263                          ; FF2D Helper routine to route interrupts from foreign to system bank
  6264  ff35 08                 exnmi:  php			; .p
  6265  ff36 6cfaff             	jmp (hwnmi)		; do nmi proc
  6266                          ; -------------------------------------------------------------------------------------------------
  6267                          ; FF31 Helper routine to route BRK insns from foreign to system bank
  6268  ff39 00                 exbrk:  brk
  6269  ff3a ea                 	nop
  6270  ff3b 60                 	rts
  6271                          ; -------------------------------------------------------------------------------------------------
  6272                          ; FF34 Helper routine to route interrupts from foreign to system bank
  6273  ff3c 58                 exirq:  cli
  6274  ff3d 60                 	rts
  6275                          exend:
  6276                          ;
  6277                          excrt2=excrts-1
  6278                          expul2=expull-1
  6279                          ; -------------------------------------------------------------------------------------------------
  6280                          ; (FF36) Unused space
  6281  ff3e ac                 	!byte $AC
  6282                          ; -------------------------------------------------------------------------------------------------
  6283                          !ifdef CBMPATCH{		; ***** moved to place to transfer routines right!
  6284                          ; FE8D 
  6285  ff3f e693               incsal: inc sal
  6286  ff41 d00e               	bne incr20
  6287  ff43 e694               	inc sah
  6288  ff45 d00a               	bne incr20
  6289  ff47 e695               	inc sas
  6290  ff49 a595               	lda sas
  6291  ff4b 8501               	sta i6509
  6292  ff4d a902               	lda #$02		; skip $0000 and $0001
  6293  ff4f 8593               	sta sal
  6294  ff51 60                 incr20:	rts
  6295                          
  6296                          patch2:				; ********** cbmii revision -03 PATCH  ACIA-IRQ routine **********
  6297  ff52 ad00dd             	lda acia+drsn
  6298  ff55 91a6               	sta (ribuf),y		; data to buffer
  6299  ff57 60                 	rts
  6300                          }
  6301                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  6302  ff58 a95a               chkwarm:lda #winit
  6303  ff5a cdfb03             	cmp evect+3		; check winit ?
  6304  ff5d d003               	bne xcold		; no -> cold start
  6305  ff5f 4cfbf9             	jmp swarm		; yes -> warm start
  6306                          
  6307  ff62 4cadf9             xcold:	jmp scold
  6308                          }
  6309                          ; -------------------------------------------------------------------------------------------------
  6310                          ; ##### vectors #####
  6311                          ; FF6F (FF6C) Jump table kernal functions
  6312                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6313                          *= $FF6C
  6314  ff6c 4c9dfe             newsys:	jmp txjmp		; Transfer-of-execution jumper
  6315                          }
  6316                          *= $FF6F
  6317  ff6f 4cd9fb             	jmp vreset		; Power-on/off vector reset
  6318  ff72 4c41fe             ipcgov:	jmp ipcgo		; Loop for ipc system
  6319  ff75 4c22e0             	jmp jfunky		; Function key vector
  6320  ff78 4cb9fc             	jmp iprqst		; Send ipc request
  6321  ff7b 4cfef9             	jmp ioinit		; I/O initialization
  6322  ff7e 4c04e0             	jmp jcint		; Screen initialization
  6323  ff81 4c07f4             aloca:	jmp alocat		; Allocation routine
  6324  ff84 4cb8fb             	jmp vector		; read/set I/O vectors
  6325  ff87 4cb1fb             	jmp restor		; restore I/O vectors
  6326  ff8a 4c67f6             	jmp lkupsa		; Match sa--return sa,fa
  6327  ff8d 4c7ff6             	jmp lkupla		; Match la--return sa,fa
  6328  ff90 4c69fb             	jmp setmsg		; Control o.s. messages
  6329  ff93 6c2403             secnd:	jmp (isecnd)		; Send sa after listen
  6330  ff96 6c2603             tksa:	jmp (itksa)		; Send sa after talk
  6331  ff99 4c87fb             	jmp memtop		; set/read top of memory
  6332  ff9c 4c9cfb             	jmp membot		; set/read bottom of memory
  6333  ff9f 4c13e0             	jmp jkey		; Scan keyboard
  6334  ffa2 4c83fb             	jmp settmo		; set timeout in IEEE
  6335  ffa5 6c2803             acptr:	jmp (iacptr)		; Handshake IEEE byte in
  6336  ffa8 6c2a03             ciout:	jmp (iciout)		; Handshake IEEE byte out
  6337  ffab 6c2c03             untlk:	jmp (iuntlk)		; Send untalk out IEEE
  6338  ffae 6c2e03             unlsn:	jmp (iunlsn)		; Send unlisten out IEEE
  6339  ffb1 6c3003             listn:	jmp (ilistn)		; Send listen out IEEE
  6340  ffb4 6c3203             talk:	jmp (italk)		; Send talk out IEEE
  6341  ffb7 4c56fb             	jmp readst		; read/write I/O status byte
  6342  ffba 4c4ffb             	jmp setlfs		; set la, fa, sa
  6343  ffbd 4c40fb             	jmp setnam		; set length and fn adr
  6344  ffc0 6c0603             open:	jmp (iopen)		; Open logical file/transmit command
  6345  ffc3 6c0803             close:	jmp (iclose)		; Close logical file
  6346  ffc6 6c0a03             chkin:	jmp (ichkin)		; Open channel in
  6347  ffc9 6c0c03             ckout:	jmp (ickout)		; Open channel out
  6348  ffcc 6c0e03             clrch:	jmp (iclrch)		; Close I/O channel
  6349  ffcf 6c1003             basin:	jmp (ibasin)		; Input from channel
  6350  ffd2 6c1203             bsout:	jmp (ibsout)		; Output to channel
  6351  ffd5 6c1a03             load:	jmp (iload)		; Load from file
  6352  ffd8 6c1c03             save:	jmp (isave)		; Save to file
  6353  ffdb 4c15f9             	jmp settim		; Set internal clock
  6354  ffde 4cedf8             	jmp rdtim		; read internal clock
  6355  ffe1 6c1403             stop: 	jmp (istop)		; scan stop key
  6356  ffe4 6c1603             getin:	jmp (igetin)		; Get char from q
  6357  ffe7 6c1803             clall:	jmp (iclall)		; Close all files
  6358  ffea 4c80f9             	jmp udtim		; increment clock
  6359  ffed 4c10e0             	jmp jscror		; Screen org
  6360  fff0 4c19e0             	jmp jplot		; read/set x,y coord
  6361  fff3 4c1ce0             	jmp jiobas		; return I/O base
  6362                          ; -------------------------------------------------------------------------------------------------
  6363                          ; FFF6 Actual execution segment switch routine
  6364  fff6 8500               gbye:	sta e6509		; goodbye...
  6365  fff8 60                 	rts
  6366  fff9 80                 	!byte $80
  6367                          *= $FFFA
  6368                          ; -------------------------------------------------------------------------------------------------
  6369                          ; FFFA Hardware vectors
  6370  fffa 3dfb               hwnmi:  !word nmi		; FB3D Program defineable
  6371  fffc 9ef9               	!word start		; F99E Initialization code
