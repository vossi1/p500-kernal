
; ******** Source: p500kernal.b
     1                          ; Commodore P500 Kernal 901234-02 with Fastboot Patches from Steve Gray
     2                          ; disassembled with DA65 18.4.2020 (Info-file from Ulrich Bassewitz)
     3                          ; modified for ACME assembling by Vossi 05/2020, last update 05/2024
     4                          ; v1.1 special f-keys
     5                          ; v1.2 full ramtest selection (fast test checks only byte $0002 in each page)
     6                          ; v1.3 all patches selectable
     7                          ; v1.4 new F-keys for petsd+
     8                          ; v1.5 superfast video if always in indirect bank 15
     9                          ; v1.6 add txjmp routine from b-series rev -03 kernal (diagtest detects too much RAM - only vice!)
    10                          ; v1.7 moved tx-routines in the correct place = 100% identical to cbm2 04a kernal
    11                          ; v1.8 basic SYS patched - now to selected bank -> Basic $8063 csys vector =  $EDDC-1: $DB, $ED
    12                          ; v1.9 movchar single line screen, slow scroll preserve flags patches rev -03 kernal
    13                          ; v2.0 added complete rev -03 new patched key functions in the editor
    14                          ; v2.1 optional solid Atari Style cursor ;)
    15                          ; v2.2 optional IEEE rev -03 patch with ren
    16                          ; v2.3 dclose patch from b-series rev -03 kernal
    17                          ; v2.4 patch rev. -03 reserves two top pages for swapping system
    18                          ; v2.5 finished all comments, labels, patches
    19                          ; v2.6 correct cbm checksum $e0
    20                          ; v2.7 reset sid
    21                          ; v2.8 patch rev. 04a clear insert flag, rs232
    22                          ; v2.9 SRAM patch - checks warm flags reliable to allow usage of any SRAM chip type
    23                          !cpu 6502
    24                          !ct pet		; Standard text/char conversion table -> pet = petscii
    25                          !to "kernal.bin", plain
    26                          ; * switches
    27                          ;STANDARD_FKEYS	= 1	; Standard F-keys
    28                          ;FULL_RAMTEST	= 1	; Standard full and slow RAM-test
    29                          ;STANDARD_VIDEO	= 1	; Standard doublechecked video writes (original kernal unfinished)
    30                          CBMPATCH	= 1	; CBM B-series patches -03/-04, Vossi $3BF patches
    31                          CBMPATCH4A	= 1	; CBM B-series patches -04a
    32                          IEEEPATCH	= 1	; CBM-B-series ieee-patches -03 (with ren)
    33                          BANK15_VIDEO	= 1	; Superfast Video with standard vram in bank15
    34                          			;   with vram in bank 0 the kernal doesnt write the color in bank 15!
    35                          SYSPATCH	= 1	; patched Basic SYS command to start code in all banks
    36                          			;   for a return is the txjump kernal part in the ram bank necessary! 
    37                          			;   the patched basic lo with the new sys-vector is also necessary 
    38                          SRAMPATCH	= 1	; checks warm flags reliable to allow usage of any SRAM chip type
    39                          ; the checksum must be adjusted for each individual configuration!
    40                          ; * constants
    41                          FILL		= $AA	; Fills free memory areas with $AA
    42                          TEXTCOL		= $06	; Default text color:   $06 = blue
    43                          BGRCOL		= $01	; background color      $01 = white
    44                          EXTCOL		= $03	; exterior color        $03 = cyan
    45                          ; ########################################### INFO ################################################
    46                          ; ROM-CHECKSUM-BYTE: cksume
    47                          ; loop3 E129 = Main loop - wait for key input
    48                          ; **************************************** DISCLAIMER *********************************************
    49                          ;***************************************
    50                          ;*                                     *
    51                          ;* KK  K EEEEE RRRR  NN  N  AAA  LL    *
    52                          ;* KK KK EE    RR  R NNN N AA  A LL    *
    53                          ;* KKK   EE    RR  R NNN N AA  A LL    *
    54                          ;* KKK   EEEE  RRRR  NNNNN AAAAA LL    *
    55                          ;* KK K  EE    RR  R NN NN AA  A LL    *
    56                          ;* KK KK EE    RR  R NN NN AA  A LL    *
    57                          ;* KK KK EEEEE RR  R NN NN AA  A LLLLL *
    58                          ;*                                     *
    59                          ;***************************************
    60                          ;***************************************
    61                          ;* CBM KERNAL                          *
    62                          ;*   MEMORY AND I/O DEPENDENT ROUTINES *
    63                          ;* DRIVING THE HARDWARE OF THE         *
    64                          ;* FOLLOWING CBM MODEL :               *
    65                          ;*   P-SERIES (5XX)                    *
    66                          ;* COPYRIGHT (C) 1983 BY               *
    67                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
    68                          ;***************************************
    69                          ;
    70                          ; 6509  used to extend memory on bc2 & p2 systems
    71                          ;   location - used to direct
    72                          ;   $0000 -  execution register (4 bits)
    73                          ;   $0001 -  indirect  register (4 bits)
    74                          ;
    75                          ;   these registers provide 4 extra high-order address control lines.  
    76                          ;     on 6509 reset all lines are high.
    77                          ;
    78                          ; current memory map:
    79                          ;   segment 15- $ffff-$e000  rom (kernal)
    80                          ;               $dfff-$df00  i/o  6525 tpi2
    81                          ;               $deff-$de00  i/o  6525 tpi1
    82                          ;               $ddff-$dd00  i/o  6551 acia
    83                          ;               $dcff-$dc00  i/o  6526 cia
    84                          ;               $dbff-$db00  i/o  unused (z80,8088,68008)
    85                          ;               $daff-$da00  i/o  6581 sid
    86                          ;               $d9ff-$d900  i/o  unused (disks)
    87                          ;               $d8ff-$d800  i/o  6569 vic
    88                          ;               $d7ff-$d400  color nybles
    89                          ;               $d3ff-$d000  video matrix
    90                          ;               $cfff-$c000  character dot rom
    91                          ;               $bfff-$8000  roms external (language)
    92                          ;               $7fff-$4000  roms external (extensions)
    93                          ;               $3fff-$2000  rom  external
    94                          ;               $1fff-$1000  rom  internal
    95                          ;               $0fff-$0400  unused
    96                          ;               $03ff-$0002  ram (kernal/basic system)
    97                          ;   segment 14- segment 4 open (future expansion)
    98                          ;   segment 3 - $ffff-$0002  ram p2 optinal
    99                          ;   segment 2 - $ffff-$0002  ram p2 optinal
   100                          ;   segment 1 - $ffff-$0002  ram p2 standard
   101                          ;   segment 0 - $ffff-$0002  ram p2 standard
   102                          ;
   103                          ; the 6509 registers appear in locations $0000 and $0001 in all segments of memory.
   104                          ; ***************************************** ZEROPAGE **********************************************
   105                          	e6509		= $00		; 6509 execution bank reg
   106                          	i6509		= $01		; 6509 indirect bank reg
   107                          ;
   108                          ; $02-$8f BASIC zeropage 
   109                          ;
   110                          ; Kernal page zero variables
   111                          ; Kernal indirect address variables
   112                          	fnadr		= $90		; Address of file name string
   113                          	sal		= $93		; Current load/store address
   114                          	sah		= $94		;   low, high, bank
   115                          	sas		= $95
   116                          	eal		= $96		; End of load/save
   117                          	eah		= $97
   118                          	eas		= $98
   119                          	stal		= $99		; Start of load/save
   120                          	stah		= $9A
   121                          	stas		= $9B
   122                          	; Frequently used kernal variables
   123                          	status		= $9C		; I/O operation status
   124                          	fnlen		= $9D		; File name length
   125                          	la		= $9E		; Current logical index
   126                          	fa		= $9F		; Current first address
   127                          	sa		= $A0		; Current secondary address
   128                          	dfltn		= $A1		; Default input device
   129                          	dflto		= $A2		; Default output device
   130                          ; Tape buffer pointer
   131                          	tape1		= $A3		; Address of tape buffer
   132                          ; RS-232 input buffer
   133                          	ribuf		= $A6		; Input buffer
   134                          ; Variables for kernal speed
   135                          	stkey		= $A9		; Stop key flag
   136                          	ctemp		= $A9		; used to reduce cassette read times 
   137                          	c3po		= $AA		; IEEE buffer flag
   138                          	snsw1		= $AA		; used to reduce cassette read times 
   139                          	bsour		= $AB		; IEEE character buffer 
   140                          ; Cassette temps - overlays IPC buffer
   141                          	ipoint		= $AC		; next 2 bytes used for transx code
   142                          	syno		= $AC
   143                          	dpsw		= $AD
   144                          ; next 18 bytes also used for monitor
   145                          	ptr1		= $AE		; index to pass1 errors
   146                          	ptr2		= $AF		; index to pass2 errors
   147                          	pcntr		= $B0
   148                          	firt		= $B1
   149                          	cntdn		= $B2
   150                          	shcnl		= $B3
   151                          	rer		= $B4
   152                          	rez		= $B5
   153                          	rdflg		= $B6
   154                          	flagt1		= $B7		; temp during bit read time
   155                          	shcnh		= $B7
   156                          	cmp0		= $B8
   157                          	diff		= $B9
   158                          	prp		= $BA
   159                          	ochar		= $BB
   160                          	prty		= $BC
   161                          	fsblk		= $BD
   162                          	mych		= $BE
   163                          	cdata		= $BF		; how to turn cassette timers on
   164                          ; Monitor virtual registers - Place in these locations temporarly...
   165                          	pch		= $AE		; counter
   166                          	pcl		= $AF
   167                          	flgs		= $B0		; Processor status
   168                          	acc		= $B1		; Accumulator
   169                          	xr		= $B2		; X register
   170                          	yr		= $B3		; Y register
   171                          	sp		= $B4		; Stack pointer
   172                          	xi6509		= $B5		; Old indirection segment
   173                          	re6509		= $B6		; Return execution segment
   174                          	invh		= $B7		; User interrupt vector
   175                          	invl		= $B8
   176                          ; Monitor indirect variables
   177                          	tmp0		= $B9		; Temp pointer
   178                          	tmp2		= $BB		; Temp pointer
   179                          ; Other monitor variables
   180                          	tmpc		= $BD		; Place to save last cmd
   181                          	t6509		= $BE		; Temporary i6509
   182                          	ddisk		= $BF		; Default disk unit # for monitor
   183                          ; Screen editor page zero variables
   184                          ; Editor indirect variables
   185                          	pkybuf		= $C0		; Start adr of pgm key
   186                          	keypnt		= $C2		; Current pgm key buf
   187                          	sedsal		= $C4		; Scroll ptr
   188                          	sedeal		= $C6		; Scroll ptr
   189                          	pnt		= $C8		; Current character pointer
   190                          ; Editor variables for speed & size
   191                          	tblx		= $CA		; Cursor line
   192                          	pntr		= $CB		; Cursor column
   193                          	grmode		= $CC		; Graphic/text mode flag $00=graphic, $02=text
   194                          	lstx		= $CD		; Last character index
   195                          	lstp		= $CE		; Screen editor start position
   196                          	lsxp		= $CF		; Screen editor start row
   197                          	crsw		= $D0		; cr flag - cr pressed -> input from screen
   198                          	ndx		= $D1		; Index to keyd queue
   199                          	qtsw		= $D2		; Quote mode flag
   200                          	insrt		= $D3		; Insert mode flag
   201                          	config		= $D4		; Char before blink (petii)
   202                          	indx		= $D5		; last byte position on line (##234-02##244-02)
   203                          	kyndx		= $D6		; count of program key string
   204                          	rptcnt		= $D7		; Deelay tween chars
   205                          	delay		= $D8		; Delay to next repeat
   206                          	sedt1		= $D9		; Frequently used temp variables
   207                          	sedt2		= $DA
   208                          ; Frequently used editor variables
   209                          	data		= $DB		; Current print data
   210                          	sctop		= $DC		; Top screen 0-24 of current window
   211                          	scbot		= $DD		; Bottom 0-24
   212                          	sclf		= $DE		; Left margin
   213                          	scrt		= $DF		; Right margin
   214                          	modkey		= $E0		; Keyscanner shift/control flags ($ff-nokey)
   215                          	norkey		= $E1		; Keyscanner normal key number ($ff-nokey)
   216                          ; Screen editor usage
   217                          	bitabl		= $E2		; Wrap bitmap
   218                          	blnon		= $E6		; Blinking cursor on = $00
   219                          	blncnt		= $E7		; Blink counter
   220                          	user		= $E8		; Pointer to color RAM
   221                          	tcolor		= $EA		; Temporary color
   222                          	blnsw		= $EB		; Blink switch
   223                          	color		= $EC		; Character color
   224                          	gdcol		= $ED		; Color behind cursor
   225                          	saver		= $EE		; Temp store for output char
   226                          	scrseg		= $EF		; Segment /bank of video RAM
   227                          ; Free zero page space, 16 bytes
   228                          	zpend		= $F0
   229                          ; ***************************************** ABSOLUTE **********************************************
   230                          ; System stack area
   231                          	stack		= $0100		; Stack
   232                          	bad		= $0100		; Cassette bad address table
   233                          	stackp		= $01FF		; System Stack pointer transx code
   234                          ; -------------------------------------------------------------------------------------------------
   235                          ; $200 - $256 Basic's ROM page work area
   236                          	buf		= $0200		; Basic input buffer
   237                          ; Basic RAM vectors
   238                          	ierror		= $0280         ; Basic error indirect
   239                          ; -------------------------------------------------------------------------------------------------
   240                          ; System RAM vectors
   241                          	cinv		= $0300		; IRQ vector
   242                          	cbinv		= $0302		; BRK vector
   243                          	nminv		= $0304		; NMI vector
   244                          	iopen		= $0306		; Open file vector
   245                          	iclose		= $0308		; Close file vector
   246                          	ichkin		= $030A		; Open channel in vector
   247                          	ickout		= $030C		; Open channel out vector
   248                          	iclrch		= $030E		; Close channel vector
   249                          	ibasin		= $0310		; Input from channel vector 
   250                          	ibsout		= $0312		; Output to channel vector
   251                          	istop		= $0314		; Check stop key vector
   252                          	igetin		= $0316		; Get from queue vector
   253                          	iclall		= $0318		; Close all files vector
   254                          	iload		= $031A		; Load from file vector
   255                          	isave		= $031C		; Save to file vector
   256                          	usrcmd		= $031E		; Monitor extension vector
   257                          	escvec		= $0320		; User ESC key vector
   258                          	ctlvec		= $0322		; unused control key vector
   259                          	isecnd		= $0324		; IEEE listen secondary address
   260                          	itksa		= $0326		; IEEE talk secondary address
   261                          	iacptr		= $0328		; IEEE character in routine
   262                          	iciout		= $032A		; IEEE character out routine
   263                          	iuntlk		= $032C		; IEEE bus untalk
   264                          	iunlsn		= $032E		; IEEE bus unlisten
   265                          	ilistn		= $0330		; IEEE listen device primary address
   266                          	italk		= $0332		; IEEE talk device primary address
   267                          ; Kernal absolute variables
   268                          	lat		= $0334		; Logical file numbers / table
   269                          	fat		= $033E		; Device numbers / table
   270                          	sat		= $0348		; Secondary addresses / table
   271                          ;
   272                          	lowadr		= $0352		; Start of system memory: low, high, bank
   273                          	hiadr		= $0355		; Top of system memory: low, high, bank
   274                          	memstr		= $0358		; Start of user memory: low, high, bank
   275                          	memsiz		= $035B		; Top of user memory: low, high, bank
   276                          	timout		= $035E		; IEEE timeout enable
   277                          	verck		= $035F		; load/verify flag
   278                          	ldtnd		= $0360		; Device table index
   279                          	msgflg		= $0361		; Message flag
   280                          	bufpt		= $0362		; Cassette buffer index
   281                          ; Kernal temporary (local) variables
   282                          	t1		= $0363
   283                          	t2		= $0364 
   284                          	xsav		= $0365 
   285                          	savx		= $0366 
   286                          	svxt		= $0367 
   287                          	temp		= $0368 
   288                          	alarm		= $0369		; IRQ variable holds 6526 IRQ's
   289                          ; Kernal cassette variables
   290                          	itape		= $036A		; Indirect for cassette code
   291                          	cassvo		= $036C		; Cassette read variable
   292                          	aservo		= $036D		; Flag1***indicates t1 timeout cassette read
   293                          	caston		= $036E		; How to turn on timers
   294                          	relsal		= $036F		; moveable start load address
   295                          	relsah		= $0370		; 
   296                          	relsas		= $0371		; 
   297                          	oldinv		= $0372		; restore user IRQ and i6509 after cassettes
   298                          	cas1		= $0375		; Cassette switch flag
   299                          ; RS-232 information storage
   300                          	m51ctr		= $0376		; 6551 control image
   301                          	m51cdr		= $0377		; 6551 command image
   302                          	rsstat		= $037A		; perm. RS-232 status
   303                          	dcdsr		= $037B		; last DCD/DSR value
   304                          	ridbs		= $037C		; Input start index
   305                          	ridbe		= $037D		; Input end index
   306                          ; Screen editor absolute
   307                          ; $037E - $037F Block some area for editor
   308                          	pkyend		= $0380		; Program key buffer end address
   309                          	keyseg		= $0382		; Segment / bank of function key texts
   310                          	rvs		= $0383		; Reverse mode flag
   311                          	lintmp		= $0384		; Line # between in and out 
   312                          	lstchr		= $0385		; Last char printed
   313                          	insflg		= $0386		; Insert mode flag
   314                          	scrdis		= $0387		; Scroll disable flag
   315                          	bitmsk		= $0388		; Temorary bitmask
   316                          	fktmp		= $0388		;   also used for function key temporary
   317                          	keyidx		= $0389		; Index to programmables
   318                          	logscr		= $038A		; Logical/physical scroll flag
   319                          	bellmd		= $038B		; Bell on/off flag
   320                          	pagsav		= $038C		; Temp RAM page
   321                          	keysiz		= $038D		; Sizes of function key texts
   322                          	tab		= $03A1		; Tabstop flags
   323                          	keyd		= $03AB		; Keyboard buffer
   324                          	funvec		= $03B5		; Vector: funktion key handler
   325                          	iwrtvrm		= $03B7		; Vector: video ram write routine
   326                          	iwrtcrm		= $03B9		; Vector: color ram write routine
   327                          	iunkwn1		= $03BB		; Vector: -> E039 nofunc
   328                          	iunkwn2		= $03BD		; Vector: -> E039 nofunc
   329                          	unknwn		= $03BF		; unknown from old editor (some flag like quote or insert?)
   330                          ; $03C0 - $3F7 Free absolute space
   331                          	absend		= $03C0
   332                          ; System warm start variables and vectors
   333                          	evect		= $03F8		; Warm start vector and flags 5 bytes
   334                          ; -------------------------------------------------------------------------------------------------
   335                          ; Free bank 15 RAM 1024 bytes
   336                          	ramloc          = $0400		; First free ram location
   337                          ; -------------------------------------------------------------------------------------------------
   338                          ; Kernal inter-process communication variables 
   339                          	ipbsiz		= 16            ; Ipc buffer size
   340                          	ipb		= $0800		; IPC buffer
   341                          	ipjtab		= ipb+ipbsiz	; IPC jump table
   342                          	ipptab		= $0910		; IPC param spec table
   343                          ; Ipc buffer offsets
   344                          	ipccmd		= 0		; Ipc command
   345                          	ipcjmp		= 1		; Ipc jump address
   346                          	ipcin		= 3		; Ipc #input bytes
   347                          	ipcout		= 4		; Ipc #output bytes
   348                          	ipcdat		= 5		; Ipc data buffer (8 bytes max)
   349                          ; *************************************** IO / EQUATES ********************************************
   350                          ; Equates
   351                          	irom	= $F		; System bank
   352                          	id55hz	= 14		; 55hz value required by ioinit
   353                          	warm	= $A5		; Warm start flag
   354                          	winit	= $5A  		; Initialization complete flag
   355                          	llen	= 40            ; Screen length
   356                          	nrows	= 25            ; Screen length
   357                          	scxmax	= llen-1        ; Max column number
   358                          	scymax	= nrows-1       ; Max line number
   359                          	keymax	= 9             ; Keyboard buffer size - 1
   360                          	dblzer	= 89            ; Key code for double zero
   361                          	pgmkys	= 20            ; Number of progam keys
   362                          ; Tape block types
   363                          	eot	= 5             ; End of tape
   364                          	blf	= 1             ; Basic load file
   365                          	bdf	= 2             ; Basic data file
   366                          	bdfh	= 4             ; Basic data file header
   367                          	bufsz	= 192           ; Buffer size
   368                          	cr	= $d            ; Carriage return
   369                          ; ROM / RAM addresses
   370                          	basic	= $8000		; Start of ROM (language)
   371                          	chrrom	= $C000		; Character ROM
   372                          	scnram	= $D000		; Video RAM
   373                          	clrram	= $D400		; Color RAM nibbles
   374                          	kernal	= $E000		; Start of ROM (kernal)
   375                          ; 6569 VIC Video interface device
   376                          	vic	= $D800		; VIC
   377                          	memptr	= $18		; VIC memory pointers register
   378                          ; 6581 SID Sound interface device
   379                          	sid	= $DA00
   380                          	osc1	= $00		; base addresses osc1, osc2, osc3
   381                          	osc2	= $07
   382                          	osc3	= $0E
   383                          	freqlo	= $00		; osc registers
   384                          	freqhi	= $01
   385                          	pulsef	= $02
   386                          	pulsec	= $03
   387                          	oscctl	= $04
   388                          	atkdcy	= $05
   389                          	susrel	= $06
   390                          	fclow	= $15		; filter control
   391                          	fchi	= $16
   392                          	resnce	= $17
   393                          	volume	= $18
   394                          	potx	= $19		; pots, random number and env3 out
   395                          	poty	= $1A
   396                          	random	= $1B
   397                          	env3	= $1C
   398                          ; 6526 CIA for inter-process communication
   399                          	ipcia	= $DB00
   400                          	; pra  = data port
   401                          	; prb0 = busy1 (1=>6509 off dbus)
   402                          	; prb1 = busy2 (1=>8088/z80 off dbus)
   403                          	; prb2 = semaphore 8088/z80
   404                          	; prb3 = semaphore 6509
   405                          	; prb4 = unused
   406                          	; prb5 = unused
   407                          	; prb6 = irq to 8088/z80 (lo)
   408                          	; prb7 = unused
   409                          	sem88	= $04	; prb bit2
   410                          	sem65	= $08	; prb bit3
   411                          ; 6526 CIA Complex interface adapter - game / IEEE data / user
   412                          	; timer a: ieee local / cass local / music / game
   413                          	; timer b: ieee deadm / cass deadm / music / game
   414                          	;
   415                          	; pra0: ieee data1 / user / paddle game 1
   416                          	; pra1: ieee data2 / user / paddle game 2
   417                          	; pra2: ieee data3 / user
   418                          	; pra3: ieee data4 / user
   419                          	; pra4: ieee data5 / user
   420                          	; pra5: ieee data6 / user
   421                          	; pra6: ieee data7 / user / game trigger 14
   422                          	; pra7: ieee data8 / user / game trigger 24
   423                          	;
   424                          	; prb0: user / game 10
   425                          	; prb1: user / game 11
   426                          	; prb2: user / game 12
   427                          	; prb3: user / game 13
   428                          	; prb4: user / game 20
   429                          	; prb5: user / game 21
   430                          	; prb6: user / game 22
   431                          	; prb7: user / game 23
   432                          	;
   433                          	; flag: user / cassette read
   434                          	cia	= $DC00
   435                          	pra	= $0	; Data reg A
   436                          	prb	= $1	; Data reg B
   437                          	ddra	= $2	; Direction reg a
   438                          	ddrb	= $3	; Direction reg b
   439                          	talo	= $4	; Timer A low  byte
   440                          	tahi	= $5	; Timer A high byte
   441                          	tblo	= $6	; Timer B low  byte
   442                          	tbhi	= $7	; Timer B high byte
   443                          	tod10	= $8	; 10ths of seconds
   444                          	todsec	= $9	; Seconds
   445                          	todmin	= $A	; Minutes
   446                          	todhr	= $B	; Hours
   447                          	sdr	= $C	; Serial data register
   448                          	icr	= $D	; Interrupt control register
   449                          	cra	= $E	; Control register A
   450                          	crb	= $F	; Control register B
   451                          ; 6551 ACIA RS-232 and network interface
   452                          	acia	= $DD00
   453                          	drsn	= $0	; Transmitt/receive data register
   454                          	srsn	= $1	; Status register
   455                          	cdr	= $2	; Command register
   456                          	ctr	= $3	; Control register
   457                          	; Equates
   458                          	dsrerr	= $40	; Data set ready error
   459                          	dcderr	= $20	; Data carrier detect error
   460                          	doverr	= $08	; Receiver outer buffer overrun
   461                          ; 6525 TPI1 Triport interface device #1 - IEEE control / cassette / network / vic / irq
   462                          	tpi1	= $DE00
   463                          	; pa0: ieee dc control (ti parts)
   464                          	; pa1: ieee te control (ti parts) (t/r)
   465                          	; pa2: ieee ren
   466                          	; pa3: ieee atn
   467                          	; pa4: ieee dav
   468                          	; pa5: ieee eoi
   469                          	; pa6: ieee ndac
   470                          	; pa7: ieee nrfd
   471                          	;
   472                          	; pb0: ieee ifc
   473                          	; pb1: ieee srq
   474                          	; pb2: network transmitter enable
   475                          	; pb3: network receiver enable
   476                          	; pb4: arbitration logic switch
   477                          	; pb5: cassette write
   478                          	; pb6: cassette motor
   479                          	; pb7: cassette switch
   480                          	;
   481                          	; irq0: 50/60 hz irq
   482                          	; irq1: ieee srq
   483                          	; irq2: 6526 irq
   484                          	; irq3: (opt) 6526 inter-processor
   485                          	; irq4: 6551
   486                          	; *irq: 6569 (vic) / user devices
   487                          	; cb:   vic dot select - cr #7-6 11=bank 15, 01=bank 0
   488                          	; ca:   vic matrix select - cr #5-4 11=bank 15, 01=bank 0
   489                          	pa	= $0	; Port register A
   490                          	pb	= $1	; Port register B
   491                          	pc	= $2	; Port register C
   492                          	lir	= $2	; Interrupt latch register mc=1
   493                          	ddpa	= $3	; Data direction register A
   494                          	ddpb	= $4	; Data direction register B
   495                          	ddpc	= $5	; Data direction register C
   496                          	mir	= $5	; Interrupt mask register mc=1
   497                          	creg	= $6	; Control reg: #0 mc=IRQ mode / #1 ip= IRQ parity / #2-3 edge i3,i4	
   498                          	air	= $7	; Active interrupt register
   499                          	; Equates
   500                          	dc	= $01	; 75160/75161 control line
   501                          	te	= $02	; 75160/75161 control line
   502                          !ifdef IEEEPATCH{
   503                          	ren	= $04	; Remote enable
   504                          } else{
   505                          	ren	= 0	; Remote enable
   506                          }
   507                          	atn	= $08	; Attention
   508                          	dav	= $10	; Data available
   509                          	eoi	= $20	; End or identify
   510                          	ndac	= $40	; Not data accepted
   511                          	nrfd	= $80	; Not ready for data
   512                          	ifc	= $01	; Interface clear
   513                          	srq	= $02	; Service request
   514                          	
   515                          	rddb	= nrfd+ndac+te+dc+ren	;directions for receiver
   516                          	tddb	= eoi+dav+atn+te+dc+ren	;directions for transmitt
   517                          	
   518                          	eoist	= $40	; eoi status test
   519                          	tlkr	= $40	; device is talker
   520                          	lstnr	= $20	; device is listener
   521                          	utlkr	= $5f	; device untalk
   522                          	ulstn	= $3f	; device unlisten
   523                          	       
   524                          	toout	= $01	; timeout status on output
   525                          	toin	= $02	; timeout status on input
   526                          	eoist	= $40	; eoi on input
   527                          	nodev	= $80	; no device on bus.
   528                          	sperr	= $10	; verify error
   529                          	; Equates for c3p0 flag bits 6 and 7.
   530                          	slock	= $40	; screen editor lock-out
   531                          	dibf	= $80	; data in output buffer
   532                          ; 6525 TPI2 Triport interface device #2
   533                          	tpi2	= $DF00
   534                          	; pa: kyrd out 8-15
   535                          	; pb: kybd out 0-7
   536                          	;
   537                          	; pc0: kybd in 0
   538                          	; pc1: kybd in 1
   539                          	; pc2: kybd in 2
   540                          	; pc3: kybd in 3
   541                          	; pc4: kybd in 4
   542                          	; pc5: kybd in 5
   543                          	; pc6: vic 16k bank select low
   544                          	; pc7: vic 16k bank select hi
   545                          ; **************************************** COLD START *********************************************
   546                          !initmem FILL                   ; All unused memory filled with $AA
   547                          !zone cold
   548                          *= kernal
   549  e000 4c09ee             jmoncld:jmp monoff		; Monitor cold start
   550  e003 ea                 	nop
   551                          ; ****************************************** EDITOR ***********************************************
   552                          ;***************************************
   553                          ;*                                     *
   554                          ;* EEEEE DDD   IIIII TTTTT  OOO  RRRR  *
   555                          ;* E     D  D    I     T   O   O R   R *
   556                          ;* E     D   D   I     T   O   O R   R *
   557                          ;* EEE   D   D   I     T   O   O RRRR  *
   558                          ;* E     D   D   I     T   O   O R R   *
   559                          ;* E     D  D    I     T   O   O R  R  *
   560                          ;* EEEE  DDD   IIIII   T    OOO  R   R *
   561                          ;*                                     *
   562                          ;***************************************
   563                          ;***************************************
   564                          ;*   CBM EDITOR FOR P-SERIES SYSTEMS   *
   565                          ;*   KEYBOARD AND SCREEN EDIT ROUTINES *
   566                          ;* DRIVING THE HARDWARE OF THE         *
   567                          ;* FOLLOWING CBM MODELS:               *
   568                          ;*   P-SERIES                          *
   569                          ;* COPYRIGHT (C) 1983 BY               *
   570                          ;* COMMODORE BUSINESS MACHINES (CBM)   *
   571                          ;***************************************
   572                          !zone editor
   573                          *= kernal+4
   574                          ;****************************************
   575                          ;
   576                          ;  40 column pet ii screen editor
   577                          ;    with unlimited screen line wrap
   578                          ;
   579                          ;****************************************
   580                          ; E004 Jump vector table
   581  e004 4c44e0             jcint:  jmp cint		; Init Screen editor, VIC, F-keys
   582  e007 4cf4e0             jlp2:	jmp lp2			; Read a key from keyboard to A
   583  e00a 4c74e1             jloop5:	jmp loop5		; Read character from screen to A
   584  e00d 4c84e2             jprt:	jmp prt			; Print character from A on screen
   585  e010 4c3fe0             jscror:	jmp scrorg		; Return screen dimensions to X, Y
   586  e013 4c0ce9             jkey:	jmp scnkey		; Keyboard scan
   587  e016 4c36e0             jmvcur: jmp nofunc		; not used in P500 - only for CRTC hardware cursor in b-series
   588  e019 4c25e0             jplot:  jmp plot		; Get/set the cursor position to/from X, Y
   589  e01c 4c3ae0             jiobas:	jmp iobase		; Return CIA base address to X, Y
   590  e01f 4c3cea             jescrt:	jmp escape		; Handle an escape sequence
   591  e022 4ca1e7             jfunky:	jmp keyfun		; Get/set/list function keys
   592                          ; -------------------------------------------------------------------------------------------------
   593                          ; E025 Get/set the cursor position
   594  e025 b00b               plot:   bcs rdplt		; if C=1 get cursor position
   595                          ; set cursor
   596  e027 86ca               	stx tblx		; store line, last line 
   597  e029 86cf               	stx lsxp
   598  e02b 84cb               	sty pntr		; store column, last column
   599  e02d 84ce               	sty lstp
   600                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
   601  e02f 20dfe0             	jsr stupt		; Change pointer to this new line
   602  e032 a6ca               rdplt:  ldx tblx
   603  e034 a4cb               	ldy pntr		; load column, row
   604  e036 60                 nofunc: rts
   605                          } else{
   606                          	jsr sreset		; set full screen window
   607                          	jsr stupt		; Change pointer to this new line
   608                          ; get cursor pos
   609                          rdplt:  ldx tblx		; load row, column
   610                          	ldy pntr
   611                          nofunc: rts
   612                          }
   613                          *= $E03A
   614                          ; -------------------------------------------------------------------------------------------------
   615                          ; E03A Return CIA base address
   616  e03a a200               iobase: ldx #<cia
   617  e03c a0dc               	ldy #>cia
   618  e03e 60                 	rts
   619                          ; -------------------------------------------------------------------------------------------------
   620                          ; E03F Return screen dimensions
   621  e03f a228               scrorg: ldx #llen		; 40 columns
   622  e041 a019               	ldy #nrows		; 25 rows
   623  e043 60                 	rts
   624                          ; -------------------------------------------------------------------------------------------------
   625                          ; $E044 Screen editor init (editor, F-Keys, VIC)
   626                          ; Clear editor variables
   627  e044 a900               cint:   lda #0
   628  e046 a22d               	ldx #zpend-keypnt-1	; $C2-$EF
   629  e048 95c2               cloop1: sta keypnt,x		; clear page 0 variables
   630  e04a ca                 	dex
   631  e04b 10fb               	bpl cloop1
   632                          
   633  e04d a23c               	ldx #absend-rvs-1	; $38D-$3C9
   634  e04f 9d8d03             cloop2: sta keysiz,x		; clear absolute variables
   635  e052 ca                 	dex
   636  e053 10fa               	bpl cloop2
   637                          ; init some variables
   638  e055 a90f               	lda #irom
   639  e057 85ef               	sta scrseg		; store bank with video RAM = system bank
   640  e059 a90c               	lda #$C
   641  e05b 85e7               	sta blncnt		; init blink counter
   642  e05d 85e6               	sta blnon
   643                          ; init F-keys
   644  e05f a5c0               	lda pkybuf		; check if buffers are allocated
   645  e061 05c1               	ora pkybuf+1
   646  e063 d022               	bne keycpy		; yes..just copy f-keys (erased with absolute vars)
   647  e065 ad5503             	lda hiadr		; get end of key area
   648  e068 8d8003             	sta pkyend
   649  e06b ad5603             	lda hiadr+1
   650  e06e 8d8103             	sta pkyend+1
   651  e071 a940               	lda #$40		; NO SENSE - will be overwritten in alocat                
   652  e073 a200               	ldx #0	
   653  e075 a002               	ldy #2
   654  e077 2081ff             	jsr aloca		; get 512 bytes at end of system memory $FEFF
   655  e07a b026               	bcs noroom		; no room found...just reset the screen
   656  e07c 8d8203             	sta keyseg		; store bank for F-keys
   657  e07f e8                 	inx
   658  e080 86c0               	stx pkybuf		; save start address (returned X+1)
   659  e082 d001               	bne room10
   660  e084 c8                 	iny
   661  e085 84c1               room10: sty pkybuf+1		; save start address
   662  e087 a039               keycpy: ldy #keyend-keydef	; load size of F-key texts
   663  e089 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   664  e08c b9b5ec             kyset1: lda keydef-1,y
   665  e08f 88                 	dey
   666  e090 91c0               	sta (pkybuf),y		; copy key texts to buffer
   667  e092 d0f8               	bne kyset1
   668                          
   669  e094 207ce2             	jsr pagres		; restore ram page (indirect segment)
   670  e097 a00a               	ldy #keydef-keylen	; 10 F-key length bytes
   671  e099 b9abec             kyset2: lda keylen-1,y
   672  e09c 998c03             	sta keysiz-1,y		; copy F-key text length to $38D
   673  e09f 88                 	dey
   674  e0a0 d0f7               	bne kyset2
   675                          ; init VIC, screen
   676  e0a2 2093ea             noroom: jsr sreset		; set full screen window
   677  e0a5 a211               	ldx #$11		; init vic regs $21-$11
   678  e0a7 a021               	ldy #$21
   679  e0a9 bdf6ec             vicint:	lda tvic-1,x
   680  e0ac 2012e6             	jsr wrtvic		; write A to VIC register Y
   681  e0af 88                 	dey
   682  e0b0 ca                 	dex
   683  e0b1 d0f6               	bne vicint
   684  e0b3 2053e2             	jsr txcrt		; set text mode/char rom
   685                          
   686  e0b6 a20a               	ldx #$0A
   687  e0b8 bd07ed             edvecl: lda edvect-1,x		; copy extended editor vector table to $3B5
   688  e0bb 9db403             	sta funvec-1,x
   689  e0be ca                 	dex
   690  e0bf d0f7               	bne edvecl
   691                          
   692  e0c1 a906               	lda #TEXTCOL
   693  e0c3 85ec               	sta color		; init color
   694                          ; E0C8 Clear screen, cursor home
   695  e0c5 20d3e0             clsr:	jsr nxtd		; Start at top of window
   696  e0c8 20e1e0             cls10:	jsr scrset		; set screen pointers
   697  e0cb 2024e2             	jsr clrln		; clear the line
   698  e0ce e4dd               	cpx scbot		; done ?
   699  e0d0 e8                 	inx
   700  e0d1 90f5               	bcc cls10		; no
   701                          ; E0D3 Cursor home
   702  e0d3 a6dc               nxtd:   ldx sctop		; move to top
   703  e0d5 86ca               	stx tblx
   704  e0d7 86cf               	stx lsxp		; for input after home or clear
   705  e0d9 a4de               stu10:  ldy sclf		; left of the screen window
   706  e0db 84cb               	sty pntr
   707  e0dd 84ce               	sty lstp
   708                          ; E0DF Reset screen ptr to line begin
   709  e0df a6ca               stupt:	ldx tblx		; get curent line index
   710                          ; E0F1 Set screen ptr to line X 
   711  e0e1 bd3aec             scrset: lda ldtb2,x		; load start of screen line low
   712  e0e4 85c8               	sta pnt			; and store to screen, color RAM ptr
   713  e0e6 85e8               	sta user
   714  e0e8 bd53ec             	lda ldtb1,x		; load high
   715  e0eb 85c9               	sta pnt+1		; and store to char pointer
   716  e0ed 2903               	and #$03
   717  e0ef 09d4               	ora #>clrram		; calc color RAM high and store to color RAM ptr
   718  e0f1 85e9               	sta user+1
   719  e0f3 60                 	rts
   720                          ; -------------------------------------------------------------------------------------------------
   721                          ; *** Input routines ***
   722                          ; E0F4 Remove character from queue
   723  e0f4 a6d6               lp2:  	ldx kyndx		; are there any pgm keys
   724  e0f6 f012               	beq lp3			; branch if not
   725  e0f8 ac8903             	ldy keyidx		; get index to current char
   726  e0fb 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
   727  e0fe b1c2               	lda (keypnt),y		; get current byt
   728  e100 207ce2             	jsr pagres		; restore ram page (indirect segment)
   729  e103 c6d6               	dec kyndx		; 1 byte down
   730  e105 ee8903             	inc keyidx		; bump index to next char
   731  e108 58                 	cli
   732  e109 60                 	rts
   733                          ; No F-key
   734  e10a acab03             lp3: 	ldy keyd		; get key from irq buffer
   735  e10d a200               	ldx #0
   736  e10f bdac03             lp1:  	lda keyd+1,x		; shift key buffer
   737  e112 9dab03             	sta keyd,x
   738  e115 e8                 	inx
   739  e116 e4d1               	cpx ndx			; shift till last key in buffer
   740  e118 d0f5               	bne lp1
   741  e11a c6d1               	dec ndx			; decrease key index
   742  e11c 98                 	tya			; return char in A
   743  e11d 58                 	cli
   744  e11e 60                 	rts
   745                          ; -------------------------------------------------------------------------------------------------
   746                          ; E11F Screen input - Main loop
   747  e11f 2084e2             loop4:	jsr prt			; print the character
   748                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
   749  e122 4c28e1             	jmp loop3
   750                          } else{
   751                          	asl unknwn
   752                          	lsr unknwn		; clear bit#7 in $03BF
   753                          }
   754                          *= $E128
   755                          ; wait for key input
   756  e128 a5d1               loop3:  lda ndx			; check key and pgm-key index
   757  e12a 05d6               	ora kyndx
   758  e12c 85e6               	sta blnon
   759  e12e f0f8               	beq loop3		; loop - wait for key input
   760                          ; key available
   761  e130 78                 	sei			; disable interrupts
   762  e131 a5eb               	lda blnsw
   763  e133 f00b               	beq lp21		; skip if cursor blink already switched off
   764  e135 a5d4               	lda config		; load char before blink
   765  e137 a000               	ldy #$00
   766  e139 84eb               	sty blnsw		; switch off cursor blink
   767  e13b a6ed               	ldx gdcol		; load color behind cursor
   768  e13d 200fe2             	jsr dspcol		; write char before blink
   769                          ; check key
   770  e140 20f4e0             lp21:	jsr lp2			; get key input
   771  e143 c90d               	cmp #$D
   772  e145 d0d8               	bne loop4		; print char if not cr
   773                          ; return recognized
   774  e147 85d0               	sta crsw		; set cr flag - we pass chars now
   775  e149 20f7e4             	jsr fndend		; check nxt line for cont (double line?)
   776  e14c 8e8403             	stx lintmp		; save last line number of sentence
   777                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
   778  e14f 202fed             	jsr patch4a2		; ***** patch4a-2 - make space for clear insert flag *****
   779  e152 85d3               	sta insrt		; ***** patch4a-2 - clear insert flag *****
   780                          } else{
   781                          	jsr fistrt		; find begining of line
   782                          	lda #0
   783                          }
   784  e154 85d2               	sta qtsw		; clear quote mode
   785  e156 a4de               	ldy sclf		; retrieve from line start if left it
   786  e158 a5cf               	lda lsxp		; input started row
   787  e15a 3013               	bmi lp80		; flag we left start line
   788  e15c c5ca               	cmp tblx
   789  e15e 900f               	bcc lp80
   790  e160 a4ce               	ldy lstp		; input started column
   791  e162 cd8403             	cmp lintmp		; on start line
   792  e165 d004               	bne lp70
   793  e167 c4d5               	cpy indx		; past start column
   794  e169 f002               	beq lp75		; ok if the same
   795  e16b b011               lp70:	bcs clp2		; yes - null input
   796  e16d 85ca               lp75:	sta tblx		; start from here on input
   797  e16f 84cb               lp80:	sty pntr
   798  e171 4c86e1             	jmp lop5		; input a line
   799                          ; -------------------------------------------------------------------------------------------------
   800                          ; E174 Read character from screen
   801  e174 98                 loop5:	tya
   802  e175 48                 	pha
   803  e176 8a                 	txa
   804  e177 48                 	pha
   805  e178 a5d0               	lda crsw		; passing chars to input
   806  e17a f0ac               	beq loop3		; no - buffer on screen
   807  e17c 1008               	bpl lop5		; not done - get next char
   808  e17e a900               clp2:	lda #0			; input done clear flag
   809  e180 85d0               	sta crsw
   810  e182 a90d               	lda #$D			; pass a return
   811  e184 d039               	bne clp7
   812  e186 20dfe0             lop5:	jsr stupt		; set pnt and user
   813  e189 203fe2             	jsr get1ch		; get a screen char
   814                          ; convert screencode to petscii
   815  e18c 85db               	sta data		; store screen code for bit#5,6,7 check temporary
   816  e18e 293f               	and #$3F		; clear bit#6,7 in A
   817  e190 06db               	asl data		; check: scrcode bit#7->C
   818  e192 24db               	bit data		; check: scrcode bit#6->N, #5->V (shiftet to left)
   819  e194 1002               	bpl lop54		; skip if scrcode #6=0 x0x -> 00x
   820  e196 0980               	ora #$80		; x1x -> 10x
   821  e198 9004               lop54:	bcc lop52		; skip if scrcode #7=0 (not reverse)
   822  e19a a6d2               	ldx qtsw
   823  e19c d004               	bne lop53		; skip if bit#7=1 & quote on: 10x -> 00x, 11x -> 10x
   824                          				; if quote off or bit#7=0:
   825  e19e 7002               lop52:	bvs lop53		; skip if scrcode #5=1: 001 -> 001, 011 -> 101
   826  e1a0 0940               	ora #$40		; 000 -> 010, 100 -> 110
   827  e1a2 20c8e1             lop53:	jsr qtswc
   828  e1a5 a4ca               	ldy tblx		; on input end line ?
   829  e1a7 cc8403             	cpy lintmp
   830  e1aa 900a               	bcc clp00		; no
   831  e1ac a4cb               	ldy pntr		; on input end column ?
   832  e1ae c4d5               	cpy indx
   833  e1b0 9004               	bcc clp00		; no
   834  e1b2 66d0               	ror crsw		; c=1 minus flags last char sent
   835  e1b4 3003               	bmi clp1		; always
   836                          
   837  e1b6 2021e5             clp00:	jsr nxtchr		; at next char
   838  e1b9 c9de               clp1:	cmp #$DE		; a pi ?
   839  e1bb d002               	bne clp7		; no
   840  e1bd a9ff               	lda #$FF		; translate
   841  e1bf 85db               clp7:	sta data
   842  e1c1 68                 	pla
   843  e1c2 aa                 	tax
   844  e1c3 68                 	pla
   845  e1c4 a8                 	tay
   846  e1c5 a5db               	lda data		; return petscii char in A
   847  e1c7 60                 	rts
   848                          ; -------------------------------------------------------------------------------------------------
   849                          ; *** Test for quote mode ***
   850                          ; E1C8 Switch quote mode depending on in A
   851  e1c8 c922               qtswc:	cmp #$22 ; "
   852  e1ca d008               	bne qtswl		; skip if no quote-char
   853  e1cc a5d2               	lda qtsw
   854  e1ce 4901               	eor #$1			; toggle quoteswitch
   855  e1d0 85d2               	sta qtsw
   856  e1d2 a922               	lda #$22 ; "		; restore quote in A
   857  e1d4 60                 qtswl:	rts
   858                          ; -------------------------------------------------------------------------------------------------
   859                          ; E1D5 *** Output chars ***
   860  e1d5 2c8303             nxt3:	bit rvs
   861  e1d8 1002               	bpl nvs
   862  e1da 0980               	ora #$80
   863  e1dc a6d3               nvs:	ldx insrt
   864  e1de f002               	beq nvsa
   865  e1e0 c6d3               	dec insrt
   866  e1e2 2c8603             nvsa:	bit insflg		; are we in auto insert mode?
   867  e1e5 1009               	bpl nvs1		; branch if not
   868  e1e7 48                 	pha			; save the char
   869  e1e8 2091e5             	jsr insert		; make room for this char
   870  e1eb a200               	ldx #0
   871  e1ed 86d3               	stx insrt		; make sure we turn off insert mode.
   872  e1ef 68                 	pla			; restore char
   873  e1f0 2009e2             nvs1:	jsr dsppcc		; display the character
   874  e1f3 20dbe5             	jsr movchr		; move to next char pos
   875                          ; -------------------------------------------------------------------------------------------------
   876                          ; E1F6 ********* exit from prt *********
   877  e1f6 a5db               loop2:	lda data		; copy last char
   878  e1f8 8d8503             	sta lstchr
   879  e1fb 68                 	pla
   880  e1fc a8                 	tay
   881  e1fd a5d3               	lda insrt
   882  e1ff f002               	beq lop2
   883  e201 46d2               	lsr qtsw		; clear quote switch if in insert mode
   884  e203 68                 lop2:	pla
   885  e204 aa                 	tax
   886  e205 68                 	pla
   887  e206 60                 	rts
   888                          ; -------------------------------------------------------------------------------------------------
   889                          ;********************************
   890                          ; Display a character
   891                          ;********************************
   892                          ; E207 Write blank ($20) at cusor position
   893  e207 a920               doblnk: lda #' '		; load blank
   894                          ; E209 Write char A with color or tcolor if color bit#7=1
   895  e209 a6ec               dsppcc: ldx color		; load char color
   896  e20b 1002               	bpl dspcol
   897                          ; E20D Write char A with tcolor
   898  e20d a6ea               dsptco: ldx tcolor
   899                          ; E20f Write char A with color X and set blink counter
   900  e20f a002               dspcol: ldy #$02
   901  e211 84e7               	sty blncnt		; blink cusor
   902                          ; E213 Write char A with color X
   903  e213 a4cb               dspp:   ldy pntr		; get char index
   904  e215 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
   905  e218 206fe6             	jsr jwrvrm		; write char to screen
   906  e21b 48                 	pha
   907  e21c 8a                 	txa			; move color to A
   908  e21d 2072e6             	jsr jwrcrm		; write color to color RAM
   909  e220 68                 	pla
   910  e221 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
   911                          ; -------------------------------------------------------------------------------------------------
   912                          ; E224 Subroutine to clear one line
   913                          ;   x = line number
   914                          ;   clrln :  blank entire line
   915                          ;   clrprt:  y = starting column position
   916  e224 a4de               clrln:	ldy sclf		; load left margin
   917  e226 20b6e4             	jsr clrbit		; make sure non-continued line
   918  e229 8a                 clrprt:	txa
   919  e22a 48                 	pha			; save X
   920  e22b a5cb               	lda pntr
   921  e22d 48                 	pha			; remember column
   922  e22e 88                 	dey
   923  e22f c8                 clr10:	iny
   924  e230 84cb               	sty pntr
   925  e232 2007e2             	jsr doblnk		; print a blank
   926  e235 c4df               	cpy scrt		; line completely blank?
   927  e237 d0f6               	bne clr10		; branch if not
   928                          
   929  e239 68                 	pla
   930  e23a 85cb               	sta pntr
   931  e23c 68                 	pla
   932  e23d aa                 	tax
   933  e23e 60                 	rts
   934                          ; -------------------------------------------------------------------------------------------------
   935                          ; E23F Grab a character from screen
   936  e23f a4cb               get1ch: ldy pntr		; get char/color index
   937                          ; E241 Get char from column Y
   938  e241 206ee2             getych: jsr pagscr		; switch to screen memory page (indirect segment)
   939  e244 b1c8               	lda (pnt),y		; get the character
   940  e246 48                 	pha
   941  e247 a900               	lda #$00
   942  e249 11e8               	ora (user),y		; get color (ORA = always systembank)
   943  e24b 85ea               	sta tcolor		; and store it to tcolor
   944  e24d 68                 	pla
   945  e24e 4c7ce2             	jmp pagres      	; restore ram page (indirect segment)
   946                          ; -------------------------------------------------------------------------------------------------
   947                          ; E251 Set text/graphic mode (C=1 graphic)
   948  e251 b004               ctext:	bcs grcrt		; skip if graphic mode
   949  e253 a002               txcrt:	ldy #$02		; set Bit#1 for text character set   
   950  e255 d002               	bne crtset
   951  e257 a000               grcrt:	ldy #$00		; clear Bit#1 for graphic char set
   952  e259 84cc               crtset: sty grmode		; store new mode
   953  e25b ad18d8             	lda vic+memptr		; load vic memory pointers register
   954  e25e 29fd               	and #$FD
   955  e260 05cc               	ora grmode		; clear bit #1 and set to desired mode (char-ROM base-adr bit#11)
   956  e262 a018               	ldy #memptr
   957  e264 4c12e6             	jmp wrtvic		; write VIC memory pointers reg
   958                          ; -------------------------------------------------------------------------------------------------
   959                          ;**************************************************
   960                          ;   Handle ram paging (indirect segment)
   961                          ;**************************************************
   962                          ; E267 Switch to segment with key buffer
   963  e267 48                 pagkey: pha
   964  e268 ad8203             	lda keyseg              ; for function key page (segment)
   965  e26b 4c71e2             	jmp pagsub
   966                          ; E26E Switch to segment with video screen
   967  e26e 48                 pagscr: pha
   968  e26f a5ef               	lda scrseg              ; for screen memory page (segment)
   969  e271 48                 pagsub: pha
   970  e272 a501               	lda i6509		; get current page (segment) number
   971  e274 8d8c03             	sta pagsav              ; - and save it
   972  e277 68                 	pla
   973  e278 8501               	sta i6509               ; switch to new indirect segment
   974  e27a 68                 	pla                     ; restore a-reg
   975  e27b 60                 	rts
   976                          ; -------------------------------------------------------------------------------------------------
   977                          ; E27C Restore indirect segment
   978  e27c 48                 pagres: pha			; save a-reg
   979  e27d ad8c03             	lda pagsav		; get saved ram page (segment) number
   980  e280 8501               	sta i6509               ; restore ram page number
   981  e282 68                 	pla			; restore a-reg
   982  e283 60                 	rts
   983                          ; -------------------------------------------------------------------------------------------------
   984                          ; E284 *** Print a char ***
   985  e284 48                 prt:	pha
   986  e285 c9ff               	cmp #$FF
   987  e287 d002               	bne prt10
   988  e289 a9de               	lda #$DE		; convert pi character
   989  e28b 85db               prt10:	sta data		; save char
   990  e28d 8a                 	txa			; save regs
   991  e28e 48                 	pha
   992  e28f 98                 	tya
   993  e290 48                 	pha
   994  e291 a900               	lda #0			; clear cr flag
   995  e293 85d0               	sta crsw
   996  e295 a4cb               	ldy pntr		; column we are in
   997  e297 a5db               	lda data
   998  e299 297f               	and #$7F
   999  e29b c920               	cmp #$20		; test if control character (< $20)
  1000  e29d 9041               	bcc ntcn		; yes
  1001                          !ifndef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1002                          	ldx qtsw		; test if in quote mode...
  1003                          	beq njt1		; if not, skip
  1004                          	ldx unknwn		; ?
  1005                          	beq njt2
  1006                          	jsr junkwn1		; vector -> nofunc (rts)
  1007                          	lda data
  1008                          	jmp njt2
  1009                          njt1:	ldx insrt		; test if in insert mode
  1010                          	bne njt2		; if not, skip
  1011                          	bit unknwn		; ?
  1012                          	bpl njt2
  1013                          	jsr junkwn1		; vector -> nofunc (rts)
  1014                          	lda data
  1015                          	cmp #$22
  1016                          	beq njt10
  1017                          	jmp loop2
  1018                          }
  1019  e29f ae8503             njt2:	ldx lstchr		; was last char an esc
  1020  e2a2 e01b               	cpx #$1B
  1021  e2a4 d006               	bne njt10		; no
  1022  e2a6 20dee6             	jsr sequen		; yes - do esc sequence
  1023  e2a9 4cf6e1             	jmp loop2
  1024  e2ac 293f               njt10:	and #$3F		; no - make a screen char
  1025  e2ae 24db               njt20:	bit data
  1026  e2b0 1002               	bpl njt30		; skip ahead if normal set - 00 - 3f
  1027  e2b2 0940               	ora #$40		; convert a0 - bf to 60 - 7f & c0 - df to 40 - 5f
  1028  e2b4 20c8e1             njt30:	jsr qtswc		; test for quote
  1029  e2b7 4cd5e1             	jmp nxt3		; put on screen
  1030                          *= $E2E0
  1031                          ; E2E0 ********* Control keys *********
  1032  e2e0 c90d               ntcn:	cmp #$0D		; test if a return
  1033  e2e2 f029               	beq ntcn20		; no inverse if yes
  1034                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1035  e2e4 c914               	cmp #$14		; test if insert or delete
  1036  e2e6 f025               	beq ntcn20		; allow in insert or quote mode
  1037  e2e8 c91b               	cmp #$1b		; test if escape key
  1038  e2ea d011               	bne ntcn1
  1039  e2ec 24db               	bit data
  1040  e2ee 300d               	bmi ntcn1		; its a $9b
  1041  e2f0 a5d2               	lda qtsw		; test if in quote mode...
  1042  e2f2 05d3               	ora insrt		; ...or insert mode
  1043  e2f4 f017               	beq ntcn20		; if not, go execute remaining code
  1044  e2f6 2072e7             	jsr toqm		; else go turn off all modes
  1045  e2f9 85db               	sta data		; and forget about this character
  1046  e2fb f010               	beq ntcn20		; always
  1047  e2fd c903               ntcn1	cmp #$03		; test if a run/load or stop
  1048                          } else{
  1049                          	cmp #$1B		; test if escape key
  1050                          	bne ntcn1
  1051                          	bit data
  1052                          	bmi ntcn1		; its a $9b
  1053                          	lda qtsw		; test if in quote mode...
  1054                          	ora insrt		; ...or insert mode
  1055                          	beq ntcn20		; if not, go execute remaining code
  1056                          	jsr toqm		; else go turn off all modes
  1057                          	sta data		; and forget about this character
  1058                          	beq ntcn20		; always
  1059                          ntcn1:	cmp #$03		; test if a run/load or stop
  1060                          	beq ntcn20
  1061                          	cmp #$14		; test if insert or delete
  1062                          }
  1063  e2ff f00c               	beq ntcn20		; no inverse if yes
  1064  e301 a4d3               	ldy insrt		; test if in insert mode
  1065  e303 d004               	bne ntcn10		; go reverse - if yes
  1066  e305 a4d2               	ldy qtsw		; check for quote mode
  1067  e307 f004               	beq ntcn20		; do not reverse if not
  1068  e309 0980               ntcn10:	ora #$80		; make reverse
  1069  e30b d0a1               	bne njt20
  1070  e30d a5db               ntcn20:	lda data
  1071  e30f 0a                 	asl			; set carry if shifted ctrl
  1072  e310 aa                 	tax
  1073  e311 2017e3             	jsr ctdsp		; indirect jsr
  1074  e314 4cf6e1             	jmp loop2
  1075                          *= $E317
  1076                          ; E317 Control code dispatcher
  1077  e317 bd6dec             ctdsp:	lda ctable+1,x		; hi byte
  1078  e31a 48                 	pha
  1079  e31b bd6cec             	lda ctable,x		; low byte
  1080  e31e 48                 	pha
  1081  e31f a5db               	lda data
  1082  e321 60                 	rts			; indirect jmp
  1083                          ; -------------------------------------------------------------------------------------------------
  1084                          ; E322 User control code jump vector
  1085  e322 6c2203             cuser:	jmp (ctlvec)
  1086                          ; -------------------------------------------------------------------------------------------------
  1087                          ; E325 Cursor down/up
  1088  e325 b00d               cdnup:  bcs cup			; cursor up
  1089                          ; cursor down
  1090  e327 208be3             cdwn:	jsr nxln
  1091  e32a 20a6e4             cdn10:	jsr getbit		; a wrapped line ?
  1092  e32d b003               	bcs cdrts		; skip if yes
  1093  e32f 38                 	sec			; flag we left line
  1094  e330 66cf               	ror lsxp
  1095                          
  1096  e332 18                 cdrts:  clc
  1097  e333 60                 	rts
  1098                          ; E334 Cursor up
  1099  e334 a6dc               cup:	ldx sctop		; cursor up
  1100  e336 e4ca               	cpx tblx		; at top of window ?
  1101  e338 b00f               	bcs critgo		; yes - do nothing
  1102  e33a 202ae3             cup10:	jsr cdn10		; about to wrap to a new line ?
  1103  e33d c6ca               	dec tblx		; up a line
  1104  e33f 4cdfe0             	jmp stupt
  1105                          ; -------------------------------------------------------------------------------------------------
  1106                          ; E342 Cursor right/left
  1107  e342 b006               crtlf:  bcs cleft		; cursor left
  1108                          ; cursor right
  1109  e344 2021e5             crit:	jsr nxtchr		; cursor right
  1110  e347 b0e1               	bcs cdn10		; yes - test for wrap
  1111                          
  1112  e349 60                 critgo: rts
  1113                          ; E34A Cursor left
  1114  e34a 2034e5             cleft:  jsr bakchr		; move back
  1115  e34d b0fa               	bcs critgo		; abort if at top left
  1116  e34f d0e1               	bne cdrts		; no - exit
  1117  e351 e6ca               	inc tblx
  1118  e353 d0e5               	bne cup10		; go set flag if needed
  1119                          ; -------------------------------------------------------------------------------------------------
  1120                          ; E355 RVS on/off
  1121  e355 4980               rvsf:   eor #$80
  1122  e357 8d8303             	sta rvs
  1123  e35a 60                 	rts
  1124                          ; -------------------------------------------------------------------------------------------------
  1125                          ; E35B Home/clear
  1126  e35b 9003               homclr:	bcc homes		; if C=0 home
  1127  e35d 4cc5e0             	jmp clsr		; Clear screen, cursor home
  1128                          ; E360 Cursor home
  1129  e360 cd8503             homes:	cmp lstchr		; last char a home ?
  1130  e363 d003               	bne hm110		; no
  1131  e365 2093ea             	jsr sreset		; top=0,left=0,bot=nrows-1,rt=cols-1
  1132  e368 4cd3e0             hm110:  jmp nxtd		; set to top left
  1133                          ; -------------------------------------------------------------------------------------------------
  1134                          ; E36B Tab function
  1135  e36b a4cb               tabit:  ldy pntr
  1136  e36d b012               	bcs tabtog		; a tab toggle
  1137  e36f c4df               tab1:	cpy scrt		; at right of window
  1138  e371 9005               	bcc tab2		; no - tab to next
  1139  e373 a5df               	lda scrt		; set to screen right
  1140  e375 85cb               	sta pntr
  1141  e377 60                 	rts
  1142                          
  1143  e378 c8                 tab2:   iny			; find next tab stop
  1144  e379 2026ea             	jsr gettab
  1145  e37c f0f1               	beq tab1		; not yet !
  1146  e37e 84cb               	sty pntr
  1147  e380 60                 	rts
  1148                          ; E381 Toggle tabulator
  1149  e381 2026ea             tabtog: jsr gettab		; flip tab stop
  1150  e384 4d8803             	eor bitmsk
  1151  e387 9da103             	sta tab,x
  1152  e38a 60                 	rts
  1153                          ; -------------------------------------------------------------------------------------------------
  1154                          ; E38B Skip to next line
  1155                          ;   wrap to top if scroll disabled
  1156  e38b a6ca               nxln:	ldx tblx
  1157  e38d e4dd               	cpx scbot		; of the bottom of window ?
  1158  e38f 900f               	bcc nxln1		; no
  1159  e391 2c8703             	bit scrdis		; what if scrolling is disabled?
  1160  e394 1006               	bpl doscrl		; branch if scroll is enabled
  1161  e396 a5dc               	lda sctop		; wrap to top
  1162  e398 85ca               	sta tblx
  1163  e39a b006               	bcs nowhop		; always
  1164                          
  1165  e39c 2008e4             doscrl:	jsr scrup		; scroll it all
  1166  e39f 18                 	clc			; indicate scroll ok
  1167  e3a0 e6ca               nxln1:	inc tblx
  1168  e3a2 4cdfe0             nowhop:	jmp stupt		; set line base adr
  1169                          ; -------------------------------------------------------------------------------------------------
  1170                          ; E3A5 A return or shift return
  1171  e3a5 20f7e4             nxt1:   jsr fndend		; find the end of the current line
  1172  e3a8 e8                 	inx
  1173  e3a9 20b6e4             	jsr clrbit		; set next line as non-continued
  1174  e3ac a4de               	ldy sclf		; else point to start of next line
  1175  e3ae 84cb               	sty pntr
  1176  e3b0 208be3             	jsr nxln		; set up next line
  1177  e3b3 4c72e7             	jmp toqm		; turn off all modes
  1178                          ; -------------------------------------------------------------------------------------------------
  1179                          ; ****** scroll routines ******
  1180                          ; E3B6 Move one line
  1181  e3b6 bd3aec             movlin:	lda ldtb2,x		; set pointers to line address lo
  1182  e3b9 85c6               	sta sedeal
  1183  e3bb 85c4               	sta sedsal
  1184  e3bd bd53ec             	lda ldtb1,x
  1185  e3c0 85c5               	sta sedsal+1		; set pointer hi to vram
  1186  e3c2 2903               	and #$03
  1187  e3c4 09d4               	ora #>clrram		; calc colorram hi and set second pointer
  1188  e3c6 85c7               	sta sedeal+1
  1189                          
  1190  e3c8 206ee2             	jsr pagscr		; switch to screen memory page (indirect segment)
  1191  e3cb b1c4               movl10: lda (sedsal),y
  1192  e3cd 206fe6             	jsr jwrvrm		; copy vram
  1193  e3d0 a900               	lda #$00
  1194  e3d2 11c6               	ora (sedeal),y		; read from color ram (ora() always from kernal bank)
  1195  e3d4 2072e6             	jsr jwrcrm		; write color ram
  1196  e3d7 c4df               	cpy scrt		; done a whole line ?
  1197  e3d9 c8                 	iny
  1198  e3da 90ef               	bcc movl10		; no
  1199                          
  1200  e3dc 4c7ce2             	jmp pagres    		; restore ram page (indirect segment)
  1201                          ; -------------------------------------------------------------------------------------------------
  1202                          ; E3DF ****** Scroll down ******
  1203  e3df a6cf               scrdwn: ldx lsxp
  1204  e3e1 3006               	bmi scd30		; skip if new line flag already set
  1205  e3e3 e4ca               	cpx tblx
  1206  e3e5 9002               	bcc scd30		; skip if old line is below scroll area
  1207  e3e7 e6cf               	inc lsxp		; else inc start line number
  1208  e3e9 a6dd               scd30:  ldx scbot		; scroll down, start bottom
  1209                          
  1210  e3eb 20e1e0             scd10:  jsr scrset		; set pnt to line
  1211  e3ee a4de               	ldy sclf
  1212  e3f0 e4ca               	cpx tblx		; test if at destination line
  1213  e3f2 f00e               	beq scd20		; done if yes
  1214  e3f4 ca                 	dex			; point to previous line as source
  1215  e3f5 20a8e4             	jsr getbt1
  1216  e3f8 e8                 	inx
  1217  e3f9 20b4e4             	jsr putbt1		; move continuation byte
  1218  e3fc ca                 	dex
  1219  e3fd 20b6e3             	jsr movlin		; move one line
  1220  e400 b0e9               	bcs scd10		; always
  1221                          
  1222  e402 2024e2             scd20:	jsr clrln		; set line to blanks
  1223  e405 4cc3e4             	jmp setbit		; mark as continuation line
  1224                          ; -------------------------------------------------------------------------------------------------
  1225                          ; E408 ****** Scroll up ******
  1226  e408 a6dc               scrup:  ldx sctop
  1227  e40a e8                 scru00: inx
  1228  e40b 20a8e4             	jsr getbt1		; find first non-continued line
  1229  e40e 900a               	bcc scru15
  1230  e410 e4dd               	cpx scbot		; is entire screen 1 line?
  1231  e412 90f6               	bcc scru00		; do normal scroll if not
  1232                          
  1233  e414 a6dc               	ldx sctop
  1234  e416 e8                 	inx
  1235  e417 20b6e4             	jsr clrbit		; clear to only scroll 1 line
  1236                          
  1237  e41a c6ca               scru15:	dec tblx
  1238  e41c 24cf               	bit lsxp
  1239  e41e 3002               	bmi scru20		; no change if already new line
  1240  e420 c6cf               	dec lsxp		; move input up one
  1241  e422 a6dc               scru20:	ldx sctop
  1242  e424 e4da               	cpx sedt2
  1243  e426 b002               	bcs scru30
  1244  e428 c6da               	dec sedt2		; in case doing insert
  1245  e42a 203fe4             scru30:	jsr scr10		; scroll
  1246  e42d a6dc               	ldx sctop
  1247  e42f 20a8e4             	jsr getbt1
  1248  e432 08                 	php
  1249  e433 20b6e4             	jsr clrbit		; make sure top line is not continuation
  1250  e436 28                 	plp
  1251  e437 9005               	bcc scru10		; done if top line off
  1252  e439 2c8a03             	bit logscr		; logical scroll ?
  1253  e43c 30ca               	bmi scrup		; yes - keep scrolling  ********** b128 v4: -> scru15
  1254  e43e 60                 scru10: rts
  1255                          ; E43F
  1256  e43f 20e1e0             scr10:	jsr scrset		; point to start of line
  1257  e442 a4de               	ldy sclf
  1258  e444 e4dd               	cpx scbot		; at last line ?
  1259  e446 b00e               	bcs scr40		; yes
  1260  e448 e8                 	inx			; point to next line
  1261  e449 20a8e4             	jsr getbt1
  1262  e44c ca                 	dex
  1263  e44d 20b4e4             	jsr putbt1		; move continuation byte
  1264  e450 e8                 	inx
  1265  e451 20b6e3             	jsr movlin		; move one line
  1266  e454 b0e9               	bcs scr10
  1267                          ; E456 Test for slow scroll
  1268  e456 2024e2             scr40:  jsr clrln		; make last line blank
  1269  e459 a2ff               	ldx #$FF
  1270  e45b a0fe               	ldy #$FE		; allow only output line 0
  1271  e45d 2098e4             	jsr getlin		; get input
  1272  e460 2920               	and #$20		; check if interrupt i5 = control
  1273  e462 d013               	bne scr80		; if not skip ahead - not slow scroll
  1274                          ; E464 Slow scroll delay loop
  1275                          scr60:
  1276                          !ifndef CBMPATCH{		; ********** PATCH nop's are for 2MHz B-series, P is slow enough ;)
  1277                          				;            get an extra byte for the cbmii patch below!
  1278                          	nop			; yes - waste time
  1279                          	nop
  1280                          }
  1281  e464 ca                 	dex
  1282  e465 d0fd               	bne scr60
  1283  e467 88                 	dey
  1284  e468 d0fa               	bne scr60
  1285                          
  1286  e46a 84d1               scr70:  sty ndx
  1287  e46c a27f               scr75:  ldx #$7F
  1288  e46e 8e00df             	stx tpi2+pa
  1289  e471 a2ff               	ldx #$FF
  1290  e473 8e01df             	stx tpi2+pb
  1291  e476 60                 	rts
  1292                          ; E479 Scroll stop
  1293  e477 a2f7               scr80:  ldx #$F7		; allow only output line 11
  1294  e479 a0ff               	ldy #$FF
  1295  e47b 2098e4             	jsr getlin		; get input lines key
  1296  e47e 2910               	and #$10		; check for the commodore key
  1297  e480 d0ea               	bne scr75		; exit if not - no stop scroll
  1298                          
  1299  e482 2098e4             scr90:	jsr getlin		; get input lines
  1300  e485 2910               	and #$10		; check for the commodore key
  1301  e487 f0f9               	beq scr90		; wait until com.key not depressed
  1302                          
  1303  e489 a000               scr95:	ldy #0
  1304  e48b a200               	ldx #0			; allow all output lines
  1305  e48d 2098e4             	jsr getlin		; get inputs
  1306  e490 293f               	and #$3F		; check for any input
  1307  e492 493f               	eor #$3F
  1308  e494 f0f3               	beq scr95		; wait
  1309  e496 d0d2               	bne scr70		; always
  1310                          ; E49A Keyboard check for slow scroll
  1311                          getlin: 
  1312                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1313  e498 08                  	php			; preserve the irq flag
  1314                          }
  1315  e499 78                 	sei
  1316  e49a 8e00df             	stx tpi2+pa		; set port-a output
  1317  e49d 8c01df             	sty tpi2+pb		; set port-b outputs
  1318  e4a0 20eae9             	jsr getkey		; get port-c inputs
  1319                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1320  e4a3 28                 	plp
  1321                          } else{
  1322                          	cli
  1323                          }
  1324  e4a4 60                 	rts
  1325                          *= $E4A6
  1326                          ; -------------------------------------------------------------------------------------------------
  1327                          ; ****** wrap table subroutines *******
  1328                          ; E4A6 Check for a double length line
  1329  e4a6 a6ca               getbit: ldx tblx		; load current line
  1330                          ; E4a8 Check line X for double length
  1331  e4a8 20cfe4             getbt1: jsr bitpos		; get byte & bit positions
  1332  e4ab 35e2               	and bitabl,x		; check if bit for line is set in table
  1333  e4ad c901               	cmp #1			; make carry clear if zero
  1334  e4af 4cbfe4             	jmp bitout		; return 0 if not a double length line
  1335                          ; -------------------------------------------------------------------------------------------------
  1336                          ; E4B2 Mark current line as double length C=1, unmark C=0
  1337                          ; putbit - set bit according to carry
  1338  e4b2 a6ca               putbit: ldx tblx		; load current line
  1339                          ; Mark line X
  1340  e4b4 b00d               putbt1: bcs setbit		; go if to mark as wrappped line
  1341                          ; clrbit - clear wrap bit
  1342  e4b6 20cfe4             clrbit: jsr bitpos		; get byte & bit positions
  1343  e4b9 49ff               	eor #$FF		; invert bit position
  1344  e4bb 35e2               	and bitabl,x		; clear bit
  1345  e4bd 95e2               bitsav: sta bitabl,x		; and store it to table at byte position X
  1346  e4bf ae8803             bitout: ldx bitmsk		; move byte table position to X
  1347  e4c2 60                 	rts
  1348                          ; setbit  -  set bit to mark as wrapped line
  1349  e4c3 2c8703             setbit: bit scrdis		; auto line link disable...
  1350  e4c6 70e0               	bvs getbt1		; branch if scrolling is disabled
  1351  e4c8 20cfe4             	jsr bitpos		; get byte & bit position
  1352  e4cb 15e2               	ora bitabl,x		; set wrap bit
  1353  e4cd d0ee               	bne bitsav		; always
  1354                          ; Find bit table position for line X
  1355  e4cf 8e8803             bitpos: stx bitmsk		; remember line
  1356  e4d2 8a                 	txa
  1357  e4d3 2907               	and #$07		; get bit position
  1358  e4d5 aa                 	tax
  1359  e4d6 bdefec             	lda bits,x		; get bit mask
  1360  e4d9 48                 	pha			; remember it
  1361  e4da ad8803             	lda bitmsk
  1362  e4dd 4a                 	lsr
  1363  e4de 4a                 	lsr			; shift to get byte position (/8)
  1364  e4df 4a                 	lsr
  1365  e4e0 aa                 	tax			; move byte pos to X
  1366  e4e1 68                 	pla			; return bit value in A
  1367  e4e2 60                 	rts
  1368                          ; -------------------------------------------------------------------------------------------------
  1369                          ; E4E2 ****** Move to start of line
  1370                          ; Find line start/end
  1371  e4e3 9012               	bcc fndend		; if C=0 find line end - NOT USED
  1372                          ; E4E5 cursor to line start (esc-j)
  1373  e4e5 a4de               fndfst:	ldy sclf
  1374  e4e7 84cb               	sty pntr		; set to leftmost column
  1375  e4e9 20a6e4             fistrt:	jsr getbit		; find start of current line
  1376  e4ec 9006               	bcc fnd0		; branch if found
  1377  e4ee c6ca               	dec tblx		; up a line
  1378  e4f0 10f7               	bpl fistrt		; always
  1379  e4f2 e6ca               	inc tblx		; whoops went too far
  1380  e4f4 4cdfe0             fnd0:	jmp stupt		; set line base adr
  1381                          ; -------------------------------------------------------------------------------------------------
  1382                          ; E4F7 ****** Find last non-blank char of line
  1383                          ;   pntr= column #
  1384                          ;   tblx= line #
  1385                          ; cursor to end of line (esc-k)
  1386  e4f7 e6ca               fndend:	inc tblx
  1387  e4f9 20a6e4             	jsr getbit		; is this line continued
  1388  e4fc b0f9               	bcs fndend		; branch if so
  1389  e4fe c6ca               	dec tblx		; found it - compensate for inc tblx
  1390  e500 20dfe0             	jsr stupt		; reset screen pointer to line start
  1391  e503 a4df               	ldy scrt		; get right margin
  1392  e505 84cb               	sty pntr		; point to right margin
  1393  e507 1005               	bpl eloup2		; always
  1394  e509 2034e5             eloup1:	jsr bakchr		; backup one char
  1395  e50c b010               	bcs endbye		; if at top left get out
  1396  e50e 203fe2             eloup2: jsr get1ch		; get char from screen
  1397  e511 c920               	cmp #$20
  1398  e513 d009               	bne endbye		; yes, space
  1399  e515 c4de               	cpy sclf		; are we at the left margin?
  1400  e517 d0f0               	bne eloup1		; branch if not
  1401  e519 20a6e4             	jsr getbit		; if we're on a wraped line
  1402  e51c b0eb               	bcs eloup1		; always scan the above line
  1403                          
  1404  e51e 84d5               endbye: sty indx		; remember this
  1405  e520 60                 	rts
  1406                          ; -------------------------------------------------------------------------------------------------
  1407                          ; E521 ****** Move to next char
  1408                          ; scroll if enabled
  1409                          ; wrap to top if disabled
  1410  e521 48                 nxtchr:	pha
  1411  e522 a4cb               	ldy pntr
  1412  e524 c4df               	cpy scrt		; are we at the right margin?
  1413  e526 9007               	bcc bumpnt		; branch if not
  1414                          
  1415  e528 208be3             	jsr nxln		; point to nextline
  1416  e52b a4de               	ldy sclf		; point to first char of 1st line
  1417  e52d 88                 	dey
  1418  e52e 38                 	sec			; set to show moved to new line
  1419  e52f c8                 bumpnt:	iny			; increment char index
  1420  e530 84cb               	sty pntr
  1421  e532 68                 	pla
  1422  e533 60                 	rts
  1423                          ; -------------------------------------------------------------------------------------------------
  1424                          ; E534 Backup one char - Move one char left
  1425                          ; wrap up and stop a top left
  1426  e534 a4cb               bakchr:	ldy pntr
  1427  e536 88                 	dey
  1428  e537 3004               	bmi bakot1
  1429  e539 c4de               	cpy sclf		; are we at the left margin
  1430  e53b b00f               	bcs bakout		; no - past it
  1431  e53d a4dc               bakot1:	ldy sctop
  1432  e53f c4ca               	cpy tblx		; are we at top line last character?
  1433  e541 b00e               	bcs bakot2		; leave with carry set
  1434  e543 c6ca               	dec tblx		; else backup a line
  1435  e545 48                 	pha
  1436  e546 20dfe0             	jsr stupt		; set line base adr
  1437  e549 68                 	pla
  1438  e54a a4df               	ldy scrt		; move cursor to right side
  1439  e54c 84cb               bakout: sty pntr
  1440  e54e c4df               	cpy scrt		; set z-flag if moved to new line
  1441  e550 18                 	clc			; always clear
  1442  e551 60                 bakot2: rts
  1443                          ; -------------------------------------------------------------------------------------------------
  1444                          ; E552 savpos - Save row & column position
  1445  e552 a4cb               savpos: ldy pntr
  1446  e554 84d9               	sty sedt1
  1447  e556 a6ca               	ldx tblx
  1448  e558 86da               	stx sedt2
  1449  e55a 60                 	rts
  1450                          ; -------------------------------------------------------------------------------------------------
  1451                          ; E55B Delete or insert a character
  1452  e55b b034               delins: bcs insert		; C=1 is insert
  1453                          ; delete a character
  1454  e55d 204ae3             deleet: jsr cleft		; move back 1 position
  1455  e560 2052e5             	jsr savpos		; save column & row positions
  1456  e563 b00f               	bcs delout		; abort if at top left corner
  1457                          
  1458  e565 c4df               deloop: cpy scrt		; at right margin?
  1459  e567 9016               	bcc delop1		; no - skip ahaed
  1460  e569 a6ca               	ldx tblx
  1461  e56b e8                 	inx
  1462  e56c 20a8e4             	jsr getbt1		; is next line a wrapped line?
  1463  e56f b00e               	bcs delop1		; yes - continue with delete
  1464  e571 2007e2             	jsr doblnk		; no - blank last character
  1465                          
  1466  e574 a5d9               delout: lda sedt1		; restore column and row positions
  1467  e576 85cb               	sta pntr
  1468  e578 a5da               	lda sedt2
  1469  e57a 85ca               	sta tblx
  1470  e57c 4cdfe0             	jmp stupt		; restore pnt and exit
  1471                          ; E57F
  1472  e57f 2021e5             delop1: jsr nxtchr
  1473  e582 203fe2             	jsr get1ch		; get next character
  1474  e585 2034e5             	jsr bakchr
  1475  e588 200de2             	jsr dsptco		; move it back 1 position
  1476  e58b 2021e5             	jsr nxtchr		; move up 1 position
  1477  e58e 4c65e5             	jmp deloop		; loop until at end of line
  1478                          ; E591 Insert a character 
  1479  e591 2052e5             insert: jsr savpos		; save column & row positions
  1480  e594 20f7e4             	jsr fndend		; move to last char on the line
  1481  e597 e4da               	cpx sedt2		; last row equal to starting row?
  1482  e599 d002               	bne ins10		; no - skip ahead
  1483  e59b c4d9               	cpy sedt1		; is last position before starting position?
  1484  e59d 9021               ins10:	bcc ins50		; yes - no need to move anything
  1485  e59f 20dbe5             	jsr movchr		; move to next char position
  1486  e5a2 b022               	bcs insout		; abort if scroll needed but disabled
  1487                          
  1488  e5a4 2034e5             ins30:	jsr bakchr
  1489  e5a7 203fe2             	jsr get1ch		; move char forward 1 position
  1490  e5aa 2021e5             	jsr nxtchr
  1491  e5ad 200de2             	jsr dsptco
  1492  e5b0 2034e5             	jsr bakchr
  1493  e5b3 a6ca               	ldx tblx
  1494  e5b5 e4da               	cpx sedt2		; at original position
  1495  e5b7 d0eb               	bne ins30
  1496  e5b9 c4d9               	cpy sedt1
  1497  e5bb d0e7               	bne ins30		; no - loop till we are
  1498                          
  1499  e5bd 2007e2             	jsr doblnk		; insert a blank
  1500  e5c0 e6d3               ins50:	inc insrt		; inc insert count
  1501  e5c2 d002               	bne insout		; only allow up to 255
  1502  e5c4 c6d3               	dec insrt
  1503  e5c6 4c74e5             insout:	jmp delout		; restore original position
  1504                          ; -------------------------------------------------------------------------------------------------
  1505                          ; E5C9 Stop/run
  1506  e5c9 900f               stprun: bcc runrts		; exit if a stop code
  1507  e5cb 78                 	sei			; disable interrupts
  1508  e5cc a209               	ldx #9
  1509  e5ce 86d1               	stx ndx			; set keyboard queue size
  1510  e5d0 bd30ec             runlop:	lda runtb-1,x
  1511  e5d3 9daa03             	sta keyd-1,x		; load run character sequence into kybd queue
  1512  e5d6 ca                 	dex
  1513  e5d7 d0f7               	bne runlop
  1514                          
  1515  e5d9 58                 	cli			; enable interrupts
  1516  e5da 60                 runrts: rts
  1517                          ; -------------------------------------------------------------------------------------------------
  1518                          ; E5DB movchr  -  Move to next char position
  1519                          ; insert blank line if at end of line
  1520                          ;   y = column position
  1521                          ;   on exit - carry set = abort - scroll disabled
  1522  e5db c4df               movchr: cpy scrt
  1523  e5dd 900b               	bcc movc10		; easy if not at end of line
  1524  e5df a6ca               	ldx tblx
  1525  e5e1 e4dd               	cpx scbot
  1526  e5e3 9005               	bcc movc10		; skip if not last line of screen
  1527  e5e5 2c8703             	bit scrdis
  1528  e5e8 3017               	bmi movc30		; abort if scrolling disabled
  1529                          
  1530  e5ea 20dfe0             movc10:	jsr stupt		; set pnt address
  1531  e5ed 2021e5             	jsr nxtchr		; move to next char position
  1532  e5f0 900f               	bcc movc30		; done if not move to new line
  1533  e5f2 20a6e4             	jsr getbit		; check if on a continued line
  1534  e5f5 b009               	bcs movc20		; skip ahead if not
  1535                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1536  e5f7 2023ed             	jsr patch1		; patch in a check for single line screen
  1537  e5fa 38                 	sec			; prep for abort...
  1538                          } else{
  1539                          	sec			; prep for abort...
  1540                          	bit scrdis
  1541                          }
  1542  e5fb 7004               	bvs movc30
  1543  e5fd 20dfe3             	jsr scrdwn		; else insert a blank line
  1544                          
  1545  e600 18                 movc20:	clc			; for clean exit
  1546  e601 60                 movc30: rts
  1547                          ; -------------------------------------------------------------------------------------------------
  1548                          ; E602 Change color
  1549  e602 a010               chkcol:	ldy #16			; there's 16 colors
  1550  e604 88                 chk1a:	dey
  1551  e605 3008               	bmi chk1b
  1552  e607 d912ed             	cmp coltab,y
  1553  e60a d0f8               	bne chk1a
  1554  e60c 84ec               	sty color		; change the color
  1555  e60e 60                 	rts
  1556                          
  1557  e60f 4c22e3             chk1b:	jmp cuser
  1558                          ; -------------------------------------------------------------------------------------------------
  1559                          ; E612 Write a byte to the VIC chip
  1560                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1561                          wrtvic: sta saver		; remember value
  1562                          wrtvrpt:lda saver
  1563                          	sta vic,y		; store value to VIC register
  1564                          	eor vic,y		; check stored value
  1565                          	beq wrtvok		; jump to end if success
  1566                          	cpy #$20
  1567                          	bcs wrtvg20		; jump if reg >= $20
  1568                          	cpy #$11
  1569                          	bcc wrtvrpt		; write again if register < $10 is different
  1570                          	and wrtvtbl - $11,y	; clear unused bits with register mask table 
  1571                          	bne wrtvrpt		; write register again if different
  1572                          wrtvg20:and #$0F		; clear upper nibble because only bit#0-3 used
  1573                          	bne wrtvrpt		; write register again if different
  1574                          wrtvok: lda saver
  1575                          	rts
  1576                          wrtvtbl:!byte $7F,$00,$00,$00,$FF,$3F,$FF,$FE
  1577                          	!byte $00,$0F,$FF,$FF,$FF,$FF,$FF
  1578                          } else{				; ********** Fast video PATCH **********
  1579  e612 9900d8             wrtvic: sta vic,y
  1580  e615 60                 	rts
  1581                          }
  1582                          *= $E641
  1583                          ; -------------------------------------------------------------------------------------------------
  1584                          ; E641 Write char A to screen at current line, column Y
  1585                          !ifdef STANDARD_VIDEO{		; ********** Standard video **********
  1586                          wrvram:	sta saver		; remember value
  1587                          wrtrrpt:lda saver
  1588                          	sta (pnt),y		; store to screen RAM
  1589                          	lda (pnt),y		; load from screen
  1590                          	eor saver		; check if same
  1591                          	bne wrtrrpt		; repeat store if not equal
  1592                          
  1593                          	lda saver
  1594                          	rts
  1595                          } else{                         ; ********** Fast video PATCH **********
  1596  e641 91c8               wrvram:	sta (pnt),y		; store byte to screen line pointer + coulmn X
  1597  e643 60                 	rts
  1598                          }
  1599                          *= $E650
  1600                          ; -------------------------------------------------------------------------------------------------
  1601                          ; E650 Write color to color RAM at current line, column Y
  1602                          !ifdef STANDARD_VIDEO{          ; ********** Standard video **********
  1603                          wrcram:	sta saver		; remember value
  1604                          	lda i6509
  1605                          	pha			; remember indirect bank
  1606                          	lda #irom
  1607                          	sta i6509		; switch to system bank
  1608                          wrtcrpt:lda saver
  1609                          	sta (user),y		; store to color RAM
  1610                          	eor (user),y		; check if same
  1611                          	and #$0F		; load and isolate low nibble
  1612                          	bne wrtcrpt		; repeat if not equal
  1613                          
  1614                          	pla
  1615                          	sta i6509		; restore ibank
  1616                          	lda saver
  1617                          	rts
  1618                          } else{
  1619                          !ifdef BANK15_VIDEO{            ; ********** Video bank15 PATCH **********
  1620  e650 91e8               wrcram:	sta (user),y		; store to color RAM
  1621  e652 60                 	rts
  1622                          	} else{                 ; ********** Fast video PATCH **********
  1623                          wrcram:	sta saver		; remember value
  1624                          	lda i6509
  1625                          	pha			; remember indirect bank
  1626                          	lda #irom
  1627                          	sta i6509		; switch to system bank
  1628                          	lda saver
  1629                          	sta (user),y		; store to color RAM
  1630                          	pla
  1631                          	sta i6509		; restore ibank
  1632                          	lda saver
  1633                          	rts
  1634                          }
  1635                          }
  1636                          *= $E669
  1637                          ; -------------------------------------------------------------------------------------------------
  1638                          ; E669 Vector unused
  1639  e669 6cbb03             junkwn1:jmp (iunkwn1)		; vector -> nofunc (rts)
  1640                          ; -------------------------------------------------------------------------------------------------
  1641                          ; E66C Vector unused
  1642  e66c 6cbd03             junkwn2:jmp (iunkwn2)		; vector -> nofunc (rts)
  1643                          ; -------------------------------------------------------------------------------------------------
  1644                          ; E66F Jump vector: Write char to screen
  1645  e66f 6cb703             jwrvrm:	jmp (iwrtvrm)		; -> $03B7 -> $E641
  1646                          ; -------------------------------------------------------------------------------------------------
  1647                          ; E672 Jump vector: Write color to color RAM
  1648  e672 6cb903             jwrcrm:	jmp (iwrtcrm)		; -> $03B9 -> $E650
  1649                          ; -------------------------------------------------------------------------------------------------
  1650                          ; E675 Ring the bell, if enabled
  1651  e675 ad8b03             bell:   lda bellmd
  1652  e678 d028               	bne bellgo
  1653  e67a a90f               	lda #$0F
  1654  e67c 8d18da             	sta sid+volume		; turn up volume
  1655  e67f a900               	lda #$00
  1656  e681 8d05da             	sta sid+osc1+atkdcy	; attack=0, decay=0
  1657  e684 a9f8               	lda #$F8
  1658  e686 8d06da             	sta sid+osc1+susrel	; sustain=15, release=8
  1659  e689 a940               	lda #$40
  1660  e68b 8d01da             	sta sid+osc1+freqhi	; voice 1 freq.
  1661  e68e a980               	lda #$80
  1662  e690 8d0fda             	sta sid+osc3+freqhi	; voice 3 freq.
  1663  e693 a215               	ldx #$15
  1664  e695 8e04da             	stx sid+osc1+oscctl	; voice 1 gate on, triangle, ring mod. 
  1665  e698 a000               	ldy #$00
  1666  e69a c8                 bell10:	iny
  1667  e69b ea                 	nop			; wait to reach sustain level
  1668  e69c d0fc               	bne bell10
  1669                          
  1670  e69e ca                 	dex
  1671  e69f 8e04da             	stx sid+osc1+oscctl	; gate off
  1672  e6a2 60                 bellgo: rts
  1673                          ; -------------------------------------------------------------------------------------------------
  1674                          ; E6A3 ce - Clear entry
  1675                          ;   always deletes last character entered
  1676                          ;   will delete all <#>s. (0 1 2 3 4 5 6 7 8 9 .)
  1677                          ;   will delete if (<#>e<+/->)
  1678                          ;   cursor must be next posistion beyond entry being deleted.
  1679  e6a3 a5cb               ce:	lda pntr		; get index on line
  1680  e6a5 48                 	pha			; save for final delete if necessary
  1681  e6a6 a4cb               cet0:	ldy pntr
  1682  e6a8 88                 	dey
  1683  e6a9 2041e2             	jsr getych		; get previous character
  1684  e6ac c92b               	cmp #'+'		; (+)
  1685  e6ae f004               	beq cet1
  1686  e6b0 c92d               	cmp #'-'		; (-)
  1687  e6b2 d008               	bne cet2
  1688                          
  1689  e6b4 88                 cet1:	dey			; try for an <#>e
  1690  e6b5 2041e2             	jsr getych
  1691  e6b8 c905               	cmp #5			; (e)
  1692  e6ba d01a               	bne cet4		; exit if not...it can only be an <#>e
  1693                          
  1694  e6bc c905               cet2:	cmp #5			; (e)
  1695  e6be d004               	bne cet3
  1696  e6c0 88                 	dey
  1697  e6c1 2041e2             	jsr getych
  1698                          
  1699  e6c4 c92e               cet3:	cmp #'.'		; try for a <#>
  1700  e6c6 900e               	bcc cet4		; (.)
  1701  e6c8 c92f               	cmp #'0'-1
  1702  e6ca f00a               	beq cet4
  1703  e6cc c93a               	cmp #'9'+1		; (0-9)
  1704  e6ce b006               	bcs cet4
  1705                          
  1706  e6d0 205de5             	jsr deleet
  1707  e6d3 4ca6e6             	jmp cet0
  1708                          
  1709  e6d6 68                 cet4:	pla			; check if any deletes occured
  1710  e6d7 c5cb               	cmp pntr
  1711  e6d9 d0c7               	bne bellgo		; yes...exit
  1712  e6db 4c5de5             	jmp deleet		; else... go delete a character
  1713                          ; -------------------------------------------------------------------------------------------------
  1714                          ; E6DE Escape sequence vector
  1715  e6de 6c2003             sequen:	jmp (escvec)		; escape indirect
  1716                          ; -------------------------------------------------------------------------------------------------
  1717                          ;******************************
  1718                          ; E6E1 Insert line (esc-i)
  1719                          ;*****************************
  1720  e6e1 20dfe3             iline:	jsr scrdwn		; insert a blank line
  1721  e6e4 20d9e0             	jsr stu10		; move to start of line
  1722  e6e7 e8                 	inx
  1723  e6e8 20a8e4             	jsr getbt1
  1724  e6eb 08                 	php
  1725  e6ec 20b2e4             	jsr putbit		; set continuation same as in previous line
  1726  e6ef 28                 	plp
  1727  e6f0 b003               	bcs linrts		; skip if was wrapped
  1728  e6f2 38                 	sec
  1729  e6f3 66cf               	ror lsxp  		; set flag - new line
  1730                          
  1731  e6f5 60                 linrts: rts
  1732                          ; -------------------------------------------------------------------------------------------------
  1733                          ;**************************
  1734                          ; Delete line (esc-d)
  1735                          ;**************************
  1736                          ; E6F8 Insert or delete a line
  1737  e6f6 b0e9               	bcs iline		; insert if C=1
  1738                          
  1739  e6f8 20e9e4             dline:	jsr fistrt		; find start of line
  1740  e6fb a5dc               	lda sctop		; save current of window
  1741  e6fd 48                 	pha
  1742  e6fe a5ca               	lda tblx		; make 1st display line top of window
  1743  e700 85dc               	sta sctop
  1744  e702 ad8a03             	lda logscr		; make sure logical scrl is off
  1745  e705 48                 	pha
  1746  e706 a980               	lda #$80
  1747  e708 8d8a03             	sta logscr
  1748  e70b 201ae4             	jsr scru15		; scroll the top line away
  1749  e70e 68                 	pla
  1750  e70f 8d8a03             	sta logscr
  1751  e712 a5dc               	lda sctop		; make old 1st line of this 1 current
  1752  e714 85ca               	sta tblx
  1753  e716 68                 	pla
  1754  e717 85dc               	sta sctop
  1755  e719 38                 	sec
  1756  e71a 66cf               	ror lsxp		; set flag - new line
  1757  e71c 4cd9e0             	jmp stu10		; make this line the current one
  1758                          ; -------------------------------------------------------------------------------------------------
  1759                          ;******************************
  1760                          ; E71F Erase to end of line (esc-q)
  1761                          ;******************************
  1762  e71f 18                 etoeol: clc
  1763  e720 24                 	!byte $24               ; skip next instruction
  1764                          ;******************************
  1765                          ; E721 Erase to start of line (esc-p)
  1766                          ;******************************
  1767  e721 38                 etosol: sec
  1768  e722 2052e5             	jsr savpos
  1769  e725 b012               	bcs etstol
  1770                          ; Erase to end of line
  1771  e727 2029e2             etol:	jsr clrprt		; blank rest of line
  1772  e72a e6ca               	inc tblx		; move to next line
  1773  e72c 20dfe0             	jsr stupt
  1774  e72f a4de               	ldy sclf
  1775  e731 20a6e4             	jsr getbit		; check if next is wrapped line
  1776  e734 b0f1               	bcs etol		; yes - blank next line
  1777                          
  1778  e736 4c74e5             etout:	jmp delout		; exit and restore original position
  1779                          ; Erase to start of line
  1780  e739 2007e2             etstol:	jsr doblnk		; do a blank
  1781  e73c c4de               	cpy sclf		; done a line ?
  1782  e73e d005               	bne ets100		; no
  1783  e740 20a6e4             	jsr getbit		; at top of line
  1784  e743 90f1               	bcc etout		; yes - exit
  1785  e745 2034e5             ets100:	jsr bakchr		; back up
  1786  e748 90ef               	bcc etstol		; always
  1787                          ; -------------------------------------------------------------------------------------------------
  1788                          ;*****************************
  1789                          ; E74A Scroll up (esc-v)
  1790                          ;*****************************
  1791  e74a 18                 esuup:	clc
  1792  e74b 24                 	!byte $24               ; skips next instruction
  1793                          ;*****************************
  1794                          ; E74C Scroll down (esc-w)
  1795                          ;*****************************
  1796  e74c 38                 esddn:	sec
  1797                          ; E74D Scroll screen depending on carry
  1798  e74d 2052e5             suup:	jsr savpos
  1799  e750 b00b               	bcs sddn		; scroll down if C=1
  1800                          ; Scroll up
  1801  e752 8a                 	txa
  1802  e753 48                 	pha
  1803  e754 2008e4             	jsr scrup
  1804  e757 68                 	pla
  1805  e758 85da               	sta sedt2
  1806  e75a 4c36e7             	jmp etout		; always
  1807                          ; Scroll down
  1808  e75d 20a6e4             sddn:   jsr getbit
  1809  e760 b003               	bcs sddn2
  1810  e762 38                 	sec
  1811  e763 66cf               	ror lsxp		; set flag - left line
  1812  e765 a5dc               sddn2:  lda sctop
  1813  e767 85ca               	sta tblx		; scroll from screen top
  1814  e769 20dfe3             	jsr scrdwn
  1815  e76c 20b6e4             	jsr clrbit		; make first line non-continued
  1816  e76f 4c36e7             	jmp etout		; always
  1817                          ; -------------------------------------------------------------------------------------------------
  1818                          ;**************************************
  1819                          ; Turn off all modes
  1820                          ;   expected to return zero
  1821                          ;**************************************
  1822                          ; E772 Reset modes: insert, reverse, quote
  1823  e772 a900               toqm:	lda #0
  1824  e774 85d3               	sta insrt
  1825  e776 8d8303             	sta rvs
  1826  e779 85d2               	sta qtsw
  1827                          !ifdef CBMPATCH{		; ********** Vossi p500 $3BF PATCH **********
  1828  e77b 8d18da             	sta sid+volume		; turn off sid
  1829                          } else{
  1830                          	sta unknwn
  1831                          }
  1832  e77e 60                 	rts
  1833                          *= $E77F
  1834                          ; -------------------------------------------------------------------------------------------------
  1835                          ; E77F Enable scrolling (esc-l)
  1836  e77f 18                 scrsw0:	clc
  1837  e780 9001               	bcc scrsw
  1838                          ; E782 Disable scrolling (esc-m)
  1839  e782 38                 scrsw1:	sec
  1840                          ; Scrolling enable/disable
  1841                          ;           carry set = disable
  1842  e783 a900               scrsw:	lda #0
  1843  e785 6a                 	ror
  1844  e786 8d8703             	sta scrdis		; store flag: $00 = enable, $80 = disable
  1845  e789 60                 	rts
  1846                          ; -------------------------------------------------------------------------------------------------
  1847                          ; E78A Insert mode off
  1848  e78a 18                 insoff:	clc
  1849  e78b 9001               	bcc inssw
  1850                          ; E78D Insert mode on
  1851  e78d 38                 inson:	sec
  1852                          ; Auto insert on/off
  1853                          ;           carry set = on
  1854  e78e a900               inssw:	lda #0
  1855  e790 6a                 	ror
  1856  e791 8d8603             	sta insflg		; store flag: $00 = off, $80 = on
  1857  e794 60                 	rts
  1858                          ; -------------------------------------------------------------------------------------------------
  1859                          ; E795 Enable/Disable logical scroll
  1860  e795 18                 logoff:	clc			; disable logical scroll (single line scroll)
  1861  e796 9001               	bcc logsw
  1862                          
  1863  e798 38                 logon:	sec			; enable logical scroll (scroll a set of lines)
  1864                          ; Logical scroll enable/disable
  1865                          ;   carry set = enable
  1866  e799 a900               logsw:	lda #0
  1867  e79b 6a                 	ror
  1868  e79c 8d8a03             	sta logscr		; store flag: $00 = disable, $80 = enable
  1869  e79f 60                 	rts
  1870                          ; -------------------------------------------------------------------------------------------------
  1871                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  1872                          ; E7A0 This function is not used - removed in patch 3
  1873  e7a0 60                 unused:	rts			; something related to $03BF
  1874                          				;   code removed to free space for new f-key functions below
  1875                          ; -------------------------------------------------------------------------------------------------
  1876                          ; ********** Patched new f-key functions with sei/cli and chr$(141) for shift-return **********
  1877  e7a1 78                 keyfun: sei			; prevent fight over variables with keyscan...
  1878  e7a2 88                 	dey
  1879  e7a3 3003               	bmi listky		; do list if no parameters given
  1880  e7a5 4c64e8             	jmp addkey		; - else go add a new key definition
  1881                          ; list key defintions
  1882  e7a8 a000               listky:	ldy #0			; initialize key counter
  1883                          
  1884  e7aa c8                 listlp:	iny
  1885  e7ab 84d9               	sty sedt1
  1886  e7ad 88                 	dey			; minus 1 for indexing
  1887  e7ae b98d03             	lda keysiz,y		; get key length
  1888  e7b1 f06b               	beq nodefn		; no listing if no defintion
  1889  e7b3 8d8903             	sta keyidx		; save key length
  1890  e7b6 2015ea             	jsr findky		; get buffer start addr for function key
  1891  e7b9 85c2               	sta keypnt
  1892  e7bb 86c3               	stx keypnt+1		; save 2 byte address in temp loc
  1893                          ; print 'key ' preamble
  1894  e7bd a203               	ldx #3
  1895  e7bf bd4ce8             preamb:	lda keword,x
  1896  e7c2 20d2ff             	jsr bsout
  1897  e7c5 ca                 	dex
  1898  e7c6 10f7               	bpl preamb
  1899                          ; convert to 1 or 2 digit ascii
  1900  e7c8 a22f               	ldx #$2F
  1901  e7ca a5d9               	lda sedt1		; get key number
  1902  e7cc 38                 	sec
  1903  e7cd e8                 ky2asc:	inx			; .x=$30, if two digits it will inc to $31
  1904  e7ce e90a               	sbc #10
  1905  e7d0 b0fb               	bcs ky2asc		; repeat if >9
  1906  e7d2 693a               	adc #$3A		; add 10 & make ascii
  1907  e7d4 e030               	cpx #$30
  1908  e7d6 f006               	beq nosec		; skip 2nd digit print
  1909  e7d8 48                 	pha			; save first digit-10
  1910  e7d9 8a                 	txa
  1911  e7da 20d2ff             	jsr bsout		; print second digit
  1912  e7dd 68                 	pla			; restore first digit-10
  1913                          ; print key string
  1914  e7de 20d2ff             nosec:	jsr bsout		; print first digit
  1915  e7e1 a000               	ldy #0			; init string position counter
  1916  e7e3 a92c               	lda #','		; for comma print
  1917  e7e5 20d2ff             lstk20:	jsr bsout		; print char - comma or plus-sign
  1918  e7e8 a207               	ldx #7			; for chr$ printing - no plus-sign or quote to preceed
  1919  e7ea 2067e2             txtprt:	jsr pagkey		; make sure function key ram page (indirect segment)
  1920  e7ed b1c2               	lda (keypnt),y		; get byte
  1921  e7ef 207ce2             	jsr pagres		; restore ram page (indirect segment)
  1922  e7f2 c90d               	cmp #13
  1923  e7f4 f031               	beq lstkcr		; print chr$(13) for return
  1924  e7f6 c98d               	cmp #141
  1925  e7f8 f030               	beq lstksc		; print chr$(141) for shift-return
  1926  e7fa c922               	cmp #34
  1927  e7fc f02f               	beq lstkqt		; print chr$(34) for quote
  1928  e7fe e009               	cpx #9			; was a normal char printed last time
  1929  e800 f007               	beq lstk10		; yes - skip ahead
  1930  e802 48                 	pha			; save char
  1931  e803 a922               	lda #$22
  1932  e805 20d2ff             	jsr bsout		; print a quote
  1933  e808 68                 	pla			; restore the char
  1934                          
  1935  e809 20d2ff             lstk10:	jsr bsout		; print the char
  1936  e80c a209               	ldx #9			; for chr$ - print quote and plus next time
  1937  e80e c8                 	iny
  1938  e80f cc8903             	cpy keyidx
  1939  e812 d0d6               	bne txtprt		; loop to end of string
  1940                          
  1941  e814 a922               	lda #$22
  1942  e816 20d2ff             	jsr bsout		; print ending quote
  1943                          
  1944  e819 a90d               lstk30:	lda #$0D
  1945  e81b 20d2ff             	jsr bsout		; do a return
  1946                          
  1947  e81e a4d9               nodefn:	ldy sedt1		; get key number
  1948  e820 c014               	cpy #pgmkys
  1949  e822 d086               	bne listlp		; loop til all keys checked
  1950                          
  1951  e824 58                 	cli			; all done...clear the keyscan holdoff
  1952  e825 18                 	clc			; okay return always
  1953  e826 60                 	rts
  1954                          
  1955  e827 a20a               lstkcr:	ldx #qtword-cdword-1	; index for return
  1956  e829 2c                 	!byte $2c		; skip 2
  1957  e82a a213               lstksc:	ldx #addkey-cdword-1	; index for shifted-return
  1958  e82c 2c                 	!byte $2c		; skip 2
  1959  e82d a20e               lstkqt:	ldx #scword-cdword-1	; index for quote
  1960                          
  1961  e82f 8a                 lstk:	txa			; save value index....
  1962  e830 48                 	pha			; save .x
  1963  e831 a206               	ldx #crword-cdword-1	; print chr$(
  1964  e833 bd50e8             lstklp:	lda cdword,x		; print loop
  1965  e836 f00a               	beq lstk40		; zero is end...
  1966  e838 20d2ff             	jsr bsout
  1967  e83b ca                 	dex
  1968  e83c 10f5               	bpl lstklp
  1969                          
  1970  e83e 68                 	pla			; move number and repeat
  1971  e83f aa                 	tax
  1972  e840 d0f1               	bne lstklp		; loop again for 'xxx)' ending part
  1973                          
  1974  e842 c8                 lstk40:	iny
  1975  e843 cc8903             	cpy keyidx
  1976  e846 f0d1               	beq lstk30		; exit if all string printed
  1977  e848 a92b               	lda #'+'		; set to print plus sign
  1978  e84a d099               	bne lstk20		; return to routine
  1979                          
  1980  e84c 2059454b           keword:	!pet " yek"
  1981  e850 28245248432b22     cdword:	!pet "($rhc+",$22
  1982  e857 00293331           crword:	!pet 0,")31"
  1983  e85b 00293433           qtword:	!pet 0,")43"
  1984  e85f 0029313431         scword:	!pet 0,")141"
  1985                          
  1986                          ; insert a new key defintion
  1987  e864 48                 addkey:	pha			; save zero page address of params
  1988  e865 aa                 	tax
  1989  e866 84d9               	sty sedt1		; save key number in temp loc
  1990  e868 b500               	lda $0,x		; get new string length
  1991  e86a 38                 	sec
  1992  e86b f98d03             	sbc keysiz,y		; subtract old length
  1993  e86e 85da               	sta sedt2		; save difference in temp location
  1994  e870 6e8803             	ror fktmp		; save the carry
  1995  e873 c8                 	iny
  1996  e874 2015ea             	jsr findky		; find start addr of next function key
  1997  e877 85c4               	sta sedsal
  1998  e879 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  1999  e87b a014               	ldy #pgmkys
  2000  e87d 2015ea             	jsr findky		; find end of last function key
  2001  e880 85c6               	sta sedeal
  2002  e882 86c7               	stx sedeal+1		; save next free byte addr in temp loc
  2003  e884 ac8803             	ldy fktmp		; check if new string is longer or shorter
  2004  e887 1013               	bpl keysho		; skip ahead if shorter
  2005  e889 18                 	clc
  2006  e88a ed8003             	sbc pkyend		; subtract last available adress
  2007  e88d a8                 	tay
  2008  e88e 8a                 	txa
  2009  e88f ed8103             	sbc pkyend+1
  2010  e892 aa                 	tax
  2011  e893 98                 	tya
  2012  e894 18                 	clc
  2013  e895 65da               	adc sedt2		; add difference
  2014  e897 8a                 	txa
  2015  e898 6900               	adc #0
  2016  e89a b06c               	bcs kyxit		; exit if no room, skip if memory not full
  2017                          
  2018                          ; expand or contract key area to make room for new key definition.
  2019  e89c 2067e2             keysho:	jsr pagkey		; set up function key ram page (indirect segment)
  2020  e89f a5c6               kymove:	lda sedeal
  2021  e8a1 18                 	clc			; check if entire area expanded or contracted
  2022  e8a2 e5c4               	sbc sedsal
  2023  e8a4 a5c7               	lda sedeal+1
  2024  e8a6 e5c5               	sbc sedsal+1
  2025  e8a8 902a               	bcc keyins		; go insert new key defintion if yes
  2026  e8aa a000               	ldy #0
  2027  e8ac ad8803             	lda fktmp		; check if expand or contract
  2028  e8af 1011               	bpl kshort		; skip if needs to be contracted
  2029                          
  2030  e8b1 a5c6               	lda sedeal
  2031  e8b3 d002               	bne newky4		; dec 1 from source addr
  2032  e8b5 c6c7               	dec sedeal+1		; sub 1 for borrow
  2033  e8b7 c6c6               newky4:	dec sedeal
  2034  e8b9 b1c6               	lda (sedeal),y		; move 1 byte up to expand
  2035  e8bb a4da               	ldy sedt2		; get offset = difference
  2036  e8bd 91c6               	sta (sedeal),y		; move byte up
  2037  e8bf 4c9fe8             	jmp kymove		; loop until all bytes moved
  2038                          
  2039  e8c2 b1c4               kshort:	lda (sedsal),y		; get source byte
  2040  e8c4 a4da               	ldy sedt2		; get offset = difference
  2041  e8c6 c6c5               	dec sedsal+1		; sub 1 to move down
  2042  e8c8 91c4               	sta (sedsal),y		; move the byte down
  2043  e8ca e6c5               	inc sedsal+1
  2044  e8cc e6c4               	inc sedsal		; move source up 1 byte
  2045  e8ce d0cf               	bne kymove
  2046  e8d0 e6c5               	inc sedsal+1		; add 1 for carry
  2047  e8d2 d0cb               	bne kymove		; always
  2048                          ; insert the new string defintion
  2049  e8d4 a4d9               keyins:	ldy sedt1		; get the key index
  2050  e8d6 2015ea             	jsr findky		; find buffer start address for this key
  2051  e8d9 85c4               	sta sedsal
  2052  e8db 86c5               	stx sedsal+1		; save 2 byte address in temp loc
  2053  e8dd a4d9               	ldy sedt1
  2054  e8df 68                 	pla
  2055  e8e0 48                 	pha
  2056  e8e1 aa                 	tax			; get zero page addr of params
  2057  e8e2 b500               	lda $0,x
  2058  e8e4 998d03             	sta keysiz,y		; save key length
  2059  e8e7 a8                 	tay
  2060  e8e8 f01a               	beq kyinok		; equal to zero no keys...exit
  2061  e8ea b501               	lda $1,x		; get & save low byte of string address
  2062  e8ec 85c6               	sta sedeal
  2063  e8ee b502               	lda $2,x		; get & save high byte of string address
  2064  e8f0 85c7               	sta sedeal+1
  2065                          
  2066  e8f2 88                 kyinlp:	dey
  2067  e8f3 b503               	lda $3,x		; get string ram page
  2068  e8f5 8501               	sta i6509
  2069  e8f7 b1c6               	lda (sedeal),y		; get byte
  2070  e8f9 207ce2             	jsr pagres		; restore ram page (indirect segment)
  2071  e8fc 2067e2             	jsr pagkey		; set up function key ram page (indirect segment)
  2072  e8ff 91c4               	sta (sedsal),y		; store into buffer
  2073  e901 98                 	tya			; .y flags...end?
  2074  e902 d0ee               	bne kyinlp		; no... loop
  2075                          
  2076  e904 207ce2             kyinok:	jsr pagres		; restore ram page (indirect segment)
  2077  e907 18                 	clc			; for good exit carry clear
  2078  e908 68                 kyxit:	pla			; pop zero page address for params
  2079  e909 58                 	cli			; all done...release keyscan
  2080  e90a 60                 	rts			; c-set is memory full error
  2081                          } else{			; ********* OLD version without chr$(141) and sei/cli
  2082                          ; -------------------------------------------------------------------------------------------------
  2083                          ; E7A0 Not used - removed in patch 3
  2084                          unused:	lda unknwn		; ($03BF)
  2085                          	eor #$C0
  2086                          	sta unknwn
  2087                          	rts
  2088                          ; -------------------------------------------------------------------------------------------------
  2089                          ;******************************************
  2090                          ; E7A9 Programmable key functions
  2091                          ;******************************************
  2092                          keyfun:	dey
  2093                          	bmi listky		; do list if no parameters given
  2094                          	jmp addkey		; - else go add a new key definition
  2095                          ; List function keys
  2096                          listky:	ldy #0			; initialize key counter
  2097                          
  2098                          listlp: iny
  2099                          	sty sedt1
  2100                          	dey			; minus 1 for indexing
  2101                          	lda keysiz,y		; get key length
  2102                          	beq nodefn		; no listing if no defintion
  2103                          	sta keyidx		; save key length
  2104                          	jsr findky		; get buffer start addr for function key
  2105                          	sta keypnt
  2106                          	stx keypnt+1		; save 2 byte address in temp loc
  2107                          	ldx #3
  2108                          ; print 'key ' preamble
  2109                          preamb: lda keword,x
  2110                          	jsr jbsout
  2111                          	dex
  2112                          	bpl preamb
  2113                          ; convert to 1 or 2 digit ascii
  2114                          	ldx #$2F
  2115                          	lda sedt1		; get key number
  2116                          	sec
  2117                          ky2asc: inx			; .x=$30, if two digits it will inc to $31
  2118                          	sbc #10
  2119                          	bcs ky2asc		; repeat if >9
  2120                          	adc #$3A		; add 10 & make ascii
  2121                          	cpx #'0'
  2122                          	beq nosec		; skip 2nd digit print
  2123                          	pha			; save first digit-10
  2124                          	txa
  2125                          	jsr jbsout		; print second digit '1'
  2126                          	pla			; restore first digit-10
  2127                          
  2128                          nosec:  jsr jbsout		; print first digit
  2129                          	ldy #0			; init string position counter
  2130                          	lda #','		; for comma print
  2131                          	ldx #6
  2132                          txtprt:	cpx #8
  2133                          	beq lstk00		; skip if normal char last time
  2134                          	jsr jbsout		; print char - comma or plus-sign
  2135                          lstk00:	php
  2136                          	jsr pagkey		; set up function key ram page (indirect segment)
  2137                          	lda (keypnt),y		; get byte
  2138                          	jsr pagres		; restore ram page (indirect segment)
  2139                          	plp
  2140                          	cmp #$0D
  2141                          	beq lstkcr		; print chr$(13) for return
  2142                          	cmp #$8D
  2143                          	beq lstkcr		; print chr$(13) for shift-return
  2144                          	cmp #$22
  2145                          	beq lstkqt		; print chr$(34) for quote
  2146                          	cpx #8			; was a normal char printed last time
  2147                          	beq lstk10		; yes - skip ahead
  2148                          	pha			; save char
  2149                          	lda #$22
  2150                          	jsr jbsout		; print a quote
  2151                          	pla
  2152                          	ldx #8			; skip next print at loop start
  2153                          lstk10: jsr jbsout		; print char
  2154                          	lda #'+'
  2155                          	iny
  2156                          	cpy keyidx
  2157                          	bne txtprt		; loop to end of string
  2158                          
  2159                          	cpx #6
  2160                          	beq lstk30
  2161                          	lda #$22
  2162                          	jsr jbsout		; print ending quote
  2163                          
  2164                          lstk30: lda #$0D
  2165                          	jsr jbsout		; do a return
  2166                          
  2167                          nodefn: ldy sedt1		; get key number
  2168                          	cpy #pgmkys
  2169                          	beq listx		; exit if finished list
  2170                          	jmp listlp		; print next key definition
  2171                          
  2172                          listx:	clc
  2173                          	rts
  2174                          ; E83C
  2175                          lstkcr:	clc
  2176                          lstklp:	lda crword,x		; load chr$(13 string
  2177                          lstkqt:	bcc lstk40
  2178                          	lda qtword,x		; load chr$(34 string
  2179                          lstk40:	php			; preserce carry flag for string selection
  2180                          	jsr jbsout
  2181                          	plp
  2182                          	dex
  2183                          	bpl lstklp		; next char
  2184                          
  2185                          	lda #')' 
  2186                          	ldx #6			; mark to print ')' at loop start
  2187                          	bne lstk10
  2188                          ; Jump vector: bsout via indirect vector
  2189                          jbsout:	jmp (ibsout)
  2190                          ; -------------------------------------------------------------------------------------------------
  2191                          ; E856 
  2192                          keword: !pet " yek"		; 'key '
  2193                          crword: !pet "31($rhc+", $22	; "+chr$(13
  2194                          qtword: !pet "43($rhc+", $22	; "+chr$(34
  2195                          ; -------------------------------------------------------------------------------------------------
  2196                          ; E86C Insert a new key defintion
  2197                          addkey: pha			; save zero page address of params
  2198                          	tax
  2199                          	sty sedt1		; save key number in temp loc
  2200                          	lda $00,x		; get new string length
  2201                          	sec
  2202                          	sbc keysiz,y		; subtract old length
  2203                          	sta sedt2		; save difference in temp location
  2204                          	iny
  2205                          	jsr findky		; find start addr of next function key
  2206                          	sta sedsal
  2207                          	stx sedsal+1		; save 2 byte address in temp loc
  2208                          	ldy #pgmkys
  2209                          	jsr findky		; find end of last function key
  2210                          	sta sedeal
  2211                          	stx sedeal+1		; save next free byte addr in temp loc
  2212                          	ldy sedt2		; load difference
  2213                          	bmi keysho		; skip ahead if old key shorter
  2214                          	clc
  2215                          	sbc pkyend		; subtract last available adress
  2216                          	tay
  2217                          	txa
  2218                          	sbc pkyend+1
  2219                          	tax
  2220                          	tya
  2221                          	clc
  2222                          	adc sedt2		; add difference
  2223                          	txa
  2224                          	adc #0			; add carry
  2225                          	bcc keysho		; make room for definition
  2226                          	pla
  2227                          	rts			; exit if no room
  2228                          ; E8A2 expand or contract key area to make room for new key definition.
  2229                          keysho: jsr pagkey		; set up function key ram page (indirect segment)
  2230                          kymove: lda sedeal
  2231                          	clc 			; check if entire area expanded or contracted
  2232                          	sbc sedsal
  2233                          	lda sedeal+1
  2234                          	sbc sedsal+1
  2235                          	bcc keyins		; go insert new key defintion if yes
  2236                          	ldy #0
  2237                          	lda sedt2		; check if expand or contract
  2238                          	bmi kshort		; skip if needs to be contracted
  2239                          
  2240                          	lda sedeal
  2241                          	bne newky4		; dec 1 from source addr
  2242                          	dec sedeal+1		; sub 1 for borrow
  2243                          newky4: dec sedeal
  2244                          	lda (sedeal),y		; move 1 byte up to expand
  2245                          	ldy sedt2		; get offset = difference
  2246                          	sta (sedeal),y		; move byte up
  2247                          	bpl kymove		; loop until all bytes moved
  2248                          
  2249                          kshort:	lda (sedsal),y		; get source byte
  2250                          	ldy sedt2		; get offset = difference
  2251                          	dec sedsal+1		; sub 1 to move down
  2252                          	sta (sedsal),y		; move the byte down
  2253                          	inc sedsal+1
  2254                          	inc sedsal		; move source up 1 byte
  2255                          	bne kymove
  2256                          	inc sedsal+1		; add 1 for carry
  2257                          	bne kymove		; always
  2258                          ;  insert the new string defintion
  2259                          keyins: ldy sedt1		; get the key index
  2260                          	jsr findky		; find buffer start address for this key
  2261                          	sta sedsal
  2262                          	stx sedsal+1		; save 2 byte address in temp loc
  2263                          	ldy sedt1
  2264                          	pla
  2265                          	tax			; get zero page addr of params
  2266                          	lda $00,x
  2267                          	sta keysiz,y		; save key length
  2268                          	tay
  2269                          	lda $01,x		; get & save low byte of string address
  2270                          	sta sedeal
  2271                          	lda $02,x		; get & save high byte of string address
  2272                          	sta sedeal+1
  2273                          
  2274                          kyinlp: dey 
  2275                          	bmi kyinok
  2276                          	lda $03,x		; get string ram bank
  2277                          	sta i6509
  2278                          	lda (sedeal),y		; get byte
  2279                          	jsr pagres		; restore ram page (indirect segment)
  2280                          	jsr pagkey		; set up function key ram page (indirect segment)
  2281                          	sta (sedsal),y		; store into buffer
  2282                          	jmp kyinlp		; next 
  2283                          
  2284                          kyinok: jsr pagres    		; restore indirect bank
  2285                          	clc 			; for good exit carry clear
  2286                          	rts
  2287                          }
  2288                          *= $E90C
  2289                          ; -------------------------------------------------------------------------------------------------
  2290                          ;*******************************
  2291                          ; E90C Keyboard scanner
  2292                          ;*******************************
  2293                          ; Cursor blink routine
  2294  e90c 206ce6             scnkey: jsr junkwn2		; vector -> nofunc (rts)
  2295  e90f a5e6               	lda blnon
  2296  e911 d020               	bne key			; skip if blinking cursor is off (run mode)
  2297                          
  2298                          !ifdef SOLID_CURSOR{		; ********** Solid cursor patch ***********
  2299                          	lda blnsw
  2300                          	bne key			; skip if cursor already visible
  2301                          	
  2302                          	inc blnsw		; set visibility switch
  2303                          	jsr get1ch		; get char and color under cursor
  2304                          	ldx gdcol
  2305                          	sta config		; remember char under cursor
  2306                          	ldx tcolor
  2307                          	stx gdcol		; remember char color
  2308                          	ldx color		; load actual color
  2309                          scnk10:	eor #$80		; inverse char
  2310                          	jsr dspp		; print (reversed) char
  2311                          	jmp key
  2312                          } else{				; ********** Blinking standard cursor **********
  2313  e913 c6e7               	dec blncnt
  2314  e915 d01c               	bne key			; skip if blink counter not zero
  2315  e917 a914               	lda #20
  2316  e919 85e7               	sta blncnt		; reset blink counter
  2317  e91b 203fe2             	jsr get1ch		; get char and color under cursor
  2318  e91e a6ed               	ldx gdcol
  2319  e920 46eb               	lsr blnsw		; reset blink switch
  2320  e922 b00a               	bcs scnk10		; if cursor is off -> reverse char
  2321  e924 e6eb               	inc blnsw		; set blink switch
  2322  e926 85d4               	sta config		; remember char under cursor
  2323  e928 a6ea               	ldx tcolor
  2324  e92a 86ed               	stx gdcol		; remember char color
  2325  e92c a6ec               	ldx color		; load actual color
  2326  e92e 4980               scnk10:	eor #$80		; inverse char
  2327  e930 2013e2             	jsr dspp		; print (reversed) char
  2328                          }
  2329                          *= $E933
  2330                          ; E933 Keyboard scanner
  2331  e933 a0ff               key:    ldy #$FF		; say no keys pressed (real-time keyscan)
  2332  e935 84e0               	sty modkey
  2333  e937 84e1               	sty norkey
  2334  e939 c8                 	iny			; init base kybd index = 0
  2335  e93a 8c01df             	sty tpi2+pb		; allow all output lines
  2336  e93d 8c00df             	sty tpi2+pa
  2337  e940 20eae9             	jsr getkey		; get keybd input
  2338  e943 293f               	and #$3F		; check if any inputs
  2339  e945 493f               	eor #$3F
  2340  e947 f076               	beq nulxit		; exit if none
  2341  e949 a9ff               	lda #$FF
  2342  e94b 8d00df             	sta tpi2+pa		; allow only output line 0
  2343  e94e 0a                 	asl
  2344  e94f 8d01df             	sta tpi2+pb
  2345  e952 20eae9             	jsr getkey		; get input from line 0
  2346  e955 48                 	pha			; save shift & control bits
  2347  e956 85e0               	sta modkey		; shift keys are down
  2348  e958 0930               	ora #$30		; mask them by setting bits
  2349  e95a d003               	bne line01
  2350                          
  2351  e95c 20eae9             linelp: jsr getkey		; get line inputs
  2352  e95f a205               line01: ldx #5			; loop for 6 input lines
  2353  e961 4a                 kyloop: lsr			; check line
  2354  e962 9010               	bcc havkey		; skip ahead if have input
  2355  e964 c8                 	iny			; inc keyd code count
  2356  e965 ca                 	dex
  2357  e966 10f9               	bpl kyloop
  2358                          
  2359  e968 38                 	sec
  2360  e969 2e01df             	rol tpi2+pb		; rotate to activate next
  2361  e96c 2e00df             	rol tpi2+pa		; - output line
  2362  e96f b0eb               	bcs linelp		; loop until all lines done
  2363                          
  2364  e971 68                 	pla			; clear shift/control byte
  2365  e972 904b               	bcc nulxit		; exit if no key
  2366                          ; get pet-ascii using keyboard index and shift and control inputs
  2367  e974 beb1ea             havkey: ldx normtb,y
  2368  e977 84e1               	sty norkey		; have a normal keypress
  2369  e979 68                 	pla			; get shift/control byte
  2370  e97a 0a                 	asl
  2371  e97b 0a                 	asl			; move bits left
  2372  e97c 0a                 	asl
  2373  e97d 900e               	bcc doctl		; skip ahead if control depressed
  2374  e97f 300f               	bmi havasc		; skip ahead if not shifted - have ascii
  2375  e981 be11eb             	ldx shfttb,y		; assume shited textual
  2376  e984 a5cc               	lda grmode		; test text or graphic mode
  2377  e986 d008               	bne havasc		; have key if text mode
  2378  e988 be71eb             	ldx shftgr,y		; get shifted graphic
  2379  e98b d003               	bne havasc		; go process ascii key
  2380                          
  2381  e98d bed1eb             doctl:	ldx ctltbl,y		; get pet-ascii char for this key
  2382                          ; y-reg has keyboard index value
  2383                          ; x-reg has pet-ascii value
  2384  e990 e0ff               havasc: cpx #$FF
  2385  e992 f02d               	beq keyxit		; exit if null pet-ascii
  2386  e994 8a                 	txa
  2387  e995 c9e0               	cmp #$E0		; check if function key
  2388  e997 9009               	bcc notfun		; skip - not a function key
  2389  e999 98                 	tya
  2390  e99a 48                 	pha
  2391  e99b 20f3e9             	jsr funjmp		; do function key indirect
  2392  e99e 68                 	pla
  2393  e99f a8                 	tay
  2394  e9a0 b01f               	bcs keyxit		; done if carry flag set
  2395                          ; E9A2 Not a function key
  2396  e9a2 8a                 notfun: txa			; get pet-ascii code
  2397  e9a3 c4cd               	cpy lstx		; check if same key as last
  2398                          ; Time through
  2399  e9a5 f027               	beq dorpt		; skip ahead if so
  2400                          ; A new key input - check queue availability
  2401  e9a7 a213               	ldx #19
  2402  e9a9 86d8               	stx delay		; reset initial delay count
  2403  e9ab a6d1               	ldx ndx			; get key-in queue size
  2404  e9ad e009               	cpx #keymax		; check if queue full
  2405  e9af f00e               	beq nulxit		; exit if yes
  2406  e9b1 c059               	cpy #dblzer		; check if keypad - 00
  2407  e9b3 d029               	bne savkey		; go save key-in if not
  2408  e9b5 e008               	cpx #keymax-1		; check if room for two
  2409  e9b7 f006               	beq nulxit		; exit if not
  2410  e9b9 9dab03             	sta keyd,x		; save first zero
  2411  e9bc e8                 	inx			; update queue size
  2412  e9bd d01f               	bne savkey		; always
  2413                          
  2414  e9bf a0ff               nulxit: ldy #$FF
  2415  e9c1 84cd               keyxit: sty lstx		; save last key number
  2416  e9c3 a27f               keyxt2: ldx #$7F
  2417  e9c5 8e00df             	stx tpi2+pa		; reset output lines to allow
  2418  e9c8 a2ff               	ldx #$FF		; - stop key input
  2419  e9ca 8e01df             	stx tpi2+pb
  2420  e9cd 60                 	rts
  2421                          
  2422                          ; E9CE Check repeat delays
  2423  e9ce c6d8               dorpt:  dec delay		; dec initial delay count
  2424  e9d0 10f1               	bpl keyxt2		; exit if was not zero - still on 1st delay
  2425  e9d2 e6d8               	inc delay		; - else reset count to zero
  2426                          
  2427                          ; Check if secondary count down to zero
  2428  e9d4 c6d7               	dec rptcnt		; dec repeat btwn keys
  2429  e9d6 10eb               	bpl keyxt2		; exit if was not zero - still on delay
  2430  e9d8 e6d7               	inc rptcnt		; reset back to zero
  2431                          
  2432                          ; Time to repeat - check if key queue empty
  2433  e9da a6d1               	ldx ndx			; get kybd queue size
  2434  e9dc d0e5               	bne keyxt2		; exit if kybd queue not empty
  2435                          
  2436                          ; E9DE Save pet-ascii into key buffer
  2437  e9de 9dab03             savkey: sta keyd,x		; store pet-ascii in kybd buffer
  2438  e9e1 e8                 	inx
  2439  e9e2 86d1               	stx ndx
  2440  e9e4 a203               	ldx #3
  2441  e9e6 86d7               	stx rptcnt		; reset delay btwn keys
  2442  e9e8 d0d7               	bne keyxit
  2443                          ; E9EA Read keyboard matrix and debounce
  2444  e9ea ad02df             getkey: lda tpi2+pc		; debounce keyboard input
  2445  e9ed cd02df             	cmp tpi2+pc
  2446  e9f0 d0f8               	bne getkey
  2447  e9f2 60                 	rts
  2448                          ; -------------------------------------------------------------------------------------------------
  2449                          ; E9F3 Jump vector: Function key indirect
  2450  e9f3 6cb503             funjmp: jmp (funvec)
  2451                          ; -------------------------------------------------------------------------------------------------
  2452                          ; E9F6 Default function key handler
  2453  e9f6 c4cd               dokeyf: cpy lstx
  2454  e9f8 f019               	beq funrts		; exit not allowed to repeat
  2455  e9fa a5d1               	lda ndx
  2456  e9fc 05d6               	ora kyndx
  2457  e9fe d013               	bne funrts		; exit - function queue not empty
  2458  ea00 8d8903             	sta keyidx		; init pointer index into function area
  2459  ea03 8a                 	txa
  2460  ea04 291f               	and #$1F		; mask out to get function key number
  2461  ea06 a8                 	tay
  2462  ea07 b98d03             	lda keysiz,y		; get function key size
  2463  ea0a 85d6               	sta kyndx		; - and store it for key scan
  2464  ea0c 2015ea             	jsr findky
  2465  ea0f 85c2               	sta keypnt		; get function start addr
  2466  ea11 86c3               	stx keypnt+1		; - and save in keypnt
  2467                          
  2468  ea13 38                 funrts: sec
  2469  ea14 60                 	rts
  2470                          ; -------------------------------------------------------------------------------------------------
  2471                          ; EA15 Find address of function key given in y-reg
  2472  ea15 a5c0               findky: lda pkybuf
  2473  ea17 a6c1               	ldx pkybuf+1
  2474                          
  2475  ea19 18                 findlp: clc
  2476  ea1a 88                 	dey			; found key yet?
  2477  ea1b 3008               	bmi fndout		; yes - done
  2478  ea1d 798d03             	adc keysiz,y		; add function key size
  2479  ea20 90f7               	bcc findlp		; loop if no high byte carry-over
  2480  ea22 e8                 	inx
  2481  ea23 d0f4               	bne findlp		; loop - always
  2482                          
  2483  ea25 60                 fndout: rts
  2484                          ; -------------------------------------------------------------------------------------------------
  2485                          ; EA26 Tab set-up (tab positioner)
  2486                          ;   y=column in question
  2487  ea26 98                 gettab: tya			; get bit in question
  2488  ea27 2907               	and #$07
  2489  ea29 aa                 	tax
  2490  ea2a bdefec             	lda bits,x
  2491  ea2d 8d8803             	sta bitmsk
  2492  ea30 98                 	tya			; get 8 bit block
  2493  ea31 4a                 	lsr
  2494  ea32 4a                 	lsr
  2495  ea33 4a                 	lsr
  2496  ea34 aa                 	tax
  2497  ea35 bda103             	lda tab,x
  2498  ea38 2c8803             	bit bitmsk		; set equal flag
  2499  ea3b 60                 	rts
  2500                          ; -------------------------------------------------------------------------------------------------
  2501                          ;************************************************************
  2502                          ;*  routines involved in executing escape functions
  2503                          ;************************************************************
  2504                          ; EA3C Main escape sequence handler
  2505                          ;   entry: character following escape character in acc.
  2506  ea3c 297f               escape: and #$7F
  2507  ea3e 38                 	sec
  2508  ea3f e941               	sbc #'a'		; table begins at ascii a
  2509  ea41 c91a               	cmp #$1A		; 'z'-'a'+1
  2510  ea43 9001               	bcc escgo		; valid char, go get address
  2511  ea45 60                 escrts:	rts			; failed to find entry...ignore it!
  2512                          ; -------------------------------------------------------------------------------------------------
  2513                          ; EA46 Get address of escape routine, and go to it.
  2514  ea46 0a                 escgo:  asl			; multiply index by 2
  2515  ea47 aa                 	tax
  2516  ea48 bd52ea             	lda escvct+1,x		; get high byte
  2517  ea4b 48                 	pha
  2518  ea4c bd51ea             	lda escvct,x		; and low
  2519  ea4f 48                 	pha
  2520  ea50 60                 	rts			; and go to that address
  2521                          ; -------------------------------------------------------------------------------------------------
  2522                          ; EA51 Escape sequence table
  2523  ea51 aaea               escvct:	!word auton-1		; a Auto insert
  2524  ea53 86ea               	!word sethtb-1		; b set bottom
  2525  ea55 a7ea               	!word autoff-1		; c cancel auto insert
  2526  ea57 f7e6               	!word dline-1		; d Delete line
  2527  ea59 a6ea               	!word notimp-1		; e
  2528  ea5b a6ea               	!word notimp-1		; f
  2529  ea5d a1ea               	!word bellon-1		; g enable bell
  2530  ea5f a3ea               	!word bellof-1		; h disable bell
  2531  ea61 e0e6               	!word iline-1		; i Insert line
  2532  ea63 e4e4               	!word fndfst-1		; j Move to start of line
  2533  ea65 f6e4               	!word fndend-1		; k Move to end of line
  2534  ea67 7ee7               	!word scrsw0-1		; l enable scrolling
  2535  ea69 81e7               	!word scrsw1-1		; m disable scrolling
  2536  ea6b a6ea               	!word notimp-1		; n
  2537  ea6d 71e7               	!word toqm-1		; o cancel insert, quote and reverse
  2538  ea6f 20e7               	!word etosol-1		; p Erase to start of line
  2539  ea71 1ee7               	!word etoeol-1		; q Erase to end of line
  2540  ea73 a6ea               	!word notimp-1		; r
  2541  ea75 a6ea               	!word notimp-1		; s
  2542  ea77 84ea               	!word sethtt-1		; t Set top left of page
  2543  ea79 a6ea               	!word notimp-1		; u
  2544  ea7b 49e7               	!word esuup-1		; v Scroll up
  2545  ea7d 4be7               	!word esddn-1		; w Scroll down
  2546  ea7f 44ea               	!word escrts-1		; x cancel esacpe sequence
  2547  ea81 a6ea               	!word notimp-1		; y
  2548  ea83 a6ea               	!word notimp-1		; z
  2549                          ; -------------------------------------------------------------------------------------------------
  2550                          ; EA85 Set top left window corner (esc-t)
  2551  ea85 18                 sethtt: clc			; set upper left corner with C=0
  2552  ea86 24                 	!byte $24		; skip next instruction with bit $xx
  2553                          ; EA87 Set bottom right window corner (esc-b)
  2554  ea87 38                 sethtb: sec			; set lower right corner with C=1
  2555  ea88 a6cb               window: ldx pntr		; load cursor column
  2556  ea8a a5ca               	lda tblx		; load cursour row
  2557  ea8c 900f               	bcc settps		; set upper left corner if C=0
  2558  ea8e 85dd               setbts: sta scbot		; store last row
  2559  ea90 86df               	stx scrt		; store last column
  2560  ea92 60                 	rts
  2561                          ; -------------------------------------------------------------------------------------------------
  2562                          ; EA93 Set full screen window
  2563  ea93 a918               sreset: lda #scymax		; load last row, column of screen
  2564  ea95 a227               	ldx #scxmax
  2565  ea97 208eea             	jsr setbts		; set lower right corner
  2566  ea9a a900               	lda #0			; clear A, X to first row, column
  2567  ea9c aa                 	tax
  2568  ea9d 85dc               settps: sta sctop		; set first row
  2569  ea9f 86de               	stx sclf		; set first column
  2570  eaa1 60                 	rts
  2571                          ; -------------------------------------------------------------------------------------------------
  2572                          ; EAA2 Bell on (esc-g)
  2573  eaa2 a900               bellon: lda #0			; $00 = bell on
  2574                          ; EAA4 Bell off (esc-h)
  2575  eaa4 8d8b03             bellof:sta bellmd		; store bell flag - any value = bell off
  2576                          ; EAA7 Not implemented escape sequences jump here
  2577  eaa7 60                 notimp: rts
  2578                          ; -------------------------------------------------------------------------------------------------
  2579                          ; EAA8 Auto insert mode off (esc-c)
  2580  eaa8 a900               autoff: lda #$00
  2581  eaaa 2c                 	!byte $2C		; skips next instruction
  2582                          ; EAAB Auto insert mode on (esc-a)
  2583  eaab a9ff               auton:  lda #$FF
  2584  eaad 8d8603             	sta insflg
  2585  eab0 60                 	rts
  2586                          ; -------------------------------------------------------------------------------------------------
  2587                          ; EAB1 Keyboard tables
  2588                          normtb:					; keyboard table - no control/no shift
  2589                          	;line 0: f1, escape, tab, null, shift, control
  2590  eab1 e01b09ff0001       	 !byte $e0,$1b,$09,$ff,$00,$01
  2591                          	;line 1: f2, 1, q, a, z, null
  2592  eab7 e13151415aff       	 !byte $e1,$31,$51,$41,$5a,$ff
  2593                          	;line 2: f3, 2, w, s, x, c
  2594  eabd e23257535843       	 !byte $e2,$32,$57,$53,$58,$43
  2595                          	;line 3: f4, 3, e, d, f, v
  2596  eac3 e33345444656       	 !byte $e3,$33,$45,$44,$46,$56
  2597                          	;line 4: f5, 4, r, t, g, b
  2598  eac9 e43452544742       	 !byte $e4,$34,$52,$54,$47,$42
  2599                          	;line 5: f6, 5, 6, y, h, n
  2600  eacf e5353659484e       	 !byte $e5,$35,$36,$59,$48,$4e
  2601                          	;line 6: f7, 7, u, j, m, space
  2602  ead5 e637554a4d20       	 !byte $e6,$37,$55,$4a,$4d,$20
  2603                          	;line 7: f8, 8, i, k, "," , .
  2604  eadb e738494b2c2e       	 !byte $e7,$38,$49,$4b,$2c,$2e
  2605                          	;line 8: f9, 9, o, l, ;, /
  2606  eae1 e8394f4c3b2f       	 !byte $e8,$39,$4f,$4c,$3b,$2f
  2607                          	;line 9: f10, 0, -, p, [, '
  2608  eae7 e9302d505b27       	 !byte $e9,$30,$2d,$50,$5b,$27
  2609                          	;line 10: down cursor, =, _, ], return, pi
  2610  eaed 113d5f5d0dde       	 !byte $11,$3d,$5f,$5d,$0d,$de
  2611                          	;line 11: up cur, lt cur, rt cur, del, cmdr, null
  2612  eaf3 919d1d1402ff       	 !byte $91,$9d,$1d,$14,$02,$ff
  2613                          	;line 12: home, ?, 7, 4, 1, 0
  2614  eaf9 133f37343130       	 !byte $13,$3f,$37,$34,$31,$30
  2615                          	;line 13: rvs on, cancel, 8, 5, 2, decimal point
  2616  eaff 12043835322e       	 !byte $12,$04,$38,$35,$32,$2e
  2617                          	;line 14: graphic, mult, 9, 6, 3, 00
  2618  eb05 8e2a39363330       	 !byte $8e,$2a,$39,$36,$33,$30
  2619                          	;line 15: stop, div, subtr, add, enter, null
  2620  eb0b 032f2d2b0dff       	 !byte $03,$2f,$2d,$2b,$0d,$ff
  2621                          
  2622                          shfttb:					; keyboard table - shift only & text mode
  2623                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2624  eb11 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2625                          	;line 1: f12, !, q, a, z, null
  2626  eb17 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2627                          	;line 2: f13, @, w, s, x, c
  2628  eb1d ec40d7d3d8c3       	 !byte $ec,$40,$d7,$d3,$d8,$c3
  2629                          	;line 3: f14, #, e, d, f, v
  2630  eb23 ed23c5c4c6d6       	 !byte $ed,$23,$c5,$c4,$c6,$d6
  2631                          	;line 4: f15, $, r, t, g, b
  2632  eb29 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2633                          	;line 5: f16, %, ^, y, h, n
  2634  eb2f ef255ed9c8ce       	 !byte $ef,$25,$5e,$d9,$c8,$ce
  2635                          	;line 6: f17, &, u, j, m, shifted space
  2636  eb35 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2637                          	;line 7: f18, *, i, k, <, >
  2638  eb3b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2639                          	;line 8: f19, (, o, l, :, ?
  2640  eb41 f228cfcc3a3f       	 !byte $f2,$28,$cf,$cc,$3a,$3f
  2641                          	;line 9: f20, ), -, p, [, "
  2642  eb47 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2643                          	;line 10: down cursor, +, pound sign, ], sht return, pi
  2644  eb4d 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2645                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2646  eb53 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2647                          	;line 12: clear/home, ?, 7, 4, 1, 0
  2648  eb59 933f37343130       	 !byte $93,$3f,$37,$34,$31,$30
  2649                          	;line 13: rvs off, shft cancel, 8, 5, 2, decimal point
  2650  eb5f 92843835322e       	 !byte $92,$84,$38,$35,$32,$2e
  2651                          	;line 14: text, mult, 9, 6, 3, 00
  2652  eb65 0e2a39363330       	 !byte $0e,$2a,$39,$36,$33,$30
  2653                          	;line 15: run, div, subtr, add, enter, null
  2654  eb6b 832f2d2b8dff       	 !byte $83,$2f,$2d,$2b,$8d,$ff
  2655                          
  2656                          shftgr:					; keyboard table - shift only & graphic mode
  2657                          	;line 0: f11, sht esc, tab toggle, null, shift, ctl
  2658  eb71 ea1b89ff0001       	 !byte $ea,$1b,$89,$ff,$00,$01
  2659                          	;line 1: f12, !, gr, gr, gr, null
  2660  eb77 eb21d1c1daff       	 !byte $eb,$21,$d1,$c1,$da,$ff
  2661                          	;line 2: f13, @, gr, gr, gr, gr
  2662  eb7d ec40d7d3d8c0       	 !byte $ec,$40,$d7,$d3,$d8,$c0
  2663                          	;line 3: f14, #, gr, gr, gr, gr
  2664  eb83 ed23c5c4c6c3       	 !byte $ed,$23,$c5,$c4,$c6,$c3
  2665                          	;line 4: f15, $, gr, gr, gr, gr
  2666  eb89 ee24d2d4c7c2       	 !byte $ee,$24,$d2,$d4,$c7,$c2
  2667                          	;line 5: f16, %, ^, gr, gr, gr
  2668  eb8f ef255ed9c8dd       	 !byte $ef,$25,$5e,$d9,$c8,$dd
  2669                          	;line 6: f17, &, gr, gr, gr, shifted space
  2670  eb95 f026d5cacda0       	 !byte $f0,$26,$d5,$ca,$cd,$a0
  2671                          	;line 7: f18, *, gr, gr, <, >
  2672  eb9b f12ac9cb3c3e       	 !byte $f1,$2a,$c9,$cb,$3c,$3e
  2673                          	;line 8: f19, (, gr, gr, :, ?
  2674  eba1 f228cfd63a3f       	 !byte $f2,$28,$cf,$d6,$3a,$3f
  2675                          	;line 9: f20, ), -, gr, [, "
  2676  eba7 f3292dd05b22       	 !byte $f3,$29,$2d,$d0,$5b,$22
  2677                          	;line 10: down cursor, +, pound, ], shifted return, pi
  2678  ebad 112b5c5d8dde       	 !byte $11,$2b,$5c,$5d,$8d,$de
  2679                          	;line 11: up cursor,left cursor,right cursor, ins, cmdr, null
  2680  ebb3 919d1d9482ff       	 !byte $91,$9d,$1d,$94,$82,$ff
  2681                          	;line 12: clear/home,gr,gr,gr,gr,gr
  2682  ebb9 93b7b4b1b0ad       	 !byte $93,$b7,$b4,$b1,$b0,$ad
  2683                          	;line 13: rvs off,gr,gr,gr,gr,gr
  2684  ebbf 92b8b5b2aebd       	 !byte $92,$b8,$b5,$b2,$ae,$bd
  2685                          	;line 14: text,gr,gr,gr,gr,00
  2686  ebc5 0eb9b6b3db30       	 !byte $0e,$b9,$b6,$b3,$db,$30
  2687                          	;line 15: run,gr,gr,gr,gr,null
  2688  ebcb 83afaaab8dff       	 !byte $83,$af,$aa,$ab,$8d,$ff
  2689                          
  2690                          ctltbl:					; keyboard table... control characters, any mode
  2691                          	;line 0: null,null,null,null,null
  2692  ebd1 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2693                          	;line 1: null,gr,q,a,z,null
  2694  ebd7 ffa111011aff       	 !byte $ff,$a1,$11,$01,$1a,$ff
  2695                          	;line 2: null,gr,w,s,x,c
  2696  ebdd ffa217131803       	 !byte $ff,$a2,$17,$13,$18,$03
  2697                          	;line 3: null,gr,e,d,f,v
  2698  ebe3 ffa305040616       	 !byte $ff,$a3,$05,$04,$06,$16
  2699                          	;line 4: null,gr,r,t,g,b
  2700  ebe9 ffa412140702       	 !byte $ff,$a4,$12,$14,$07,$02
  2701                          	;line 5: null,gr,gr,y,h,n
  2702  ebef ffa5a719080e       	 !byte $ff,$a5,$a7,$19,$08,$0e
  2703                          	;line 6: null,gr,u,j,m,null
  2704  ebf5 ffbe150a0dff       	 !byte $ff,$be,$15,$0a,$0d,$ff
  2705                          	;line 7: null,gr,i,k,gr,null
  2706  ebfb ffbb090bceff       	 !byte $ff,$bb,$09,$0b,$ce,$ff
  2707                          	;line 8: null,gr,o,l,gr,null
  2708  ec01 ffbf0f0cdcff       	 !byte $ff,$bf,$0f,$0c,$dc,$ff
  2709                          	;line 9: null,gr,gr,p,gr,gr
  2710  ec07 ffacbc10cca8       	 !byte $ff,$ac,$bc,$10,$cc,$a8
  2711                          	;line 10: null,gr,gr,gr,null,gr
  2712  ec0d ffa9dfbaffa6       	 !byte $ff,$a9,$df,$ba,$ff,$a6
  2713                          	;line 11: null,null,null,null,null,null
  2714  ec13 ffffffffffff       	 !byte $ff,$ff,$ff,$ff,$ff,$ff
  2715                          	;line 12: null,lred,yell,mag,wht,blk
  2716  ec19 ff969e9c0590       	 !byte $ff,$96,$9e,$9c,$05,$90
  2717                          	;line 13: null,lblue,org,grn,red,null
  2718  ec1f ff99811e1cff       	 !byte $ff,$99,$81,$1e,$1c,$ff
  2719                          	;line 14: null,gray3,brown,blue,cyan,null
  2720  ec25 ff9a951f9fff       	 !byte $ff,$9a,$95,$1f,$9f,$ff
  2721                          	;line 15: null,gray1,gray2,purple,null,null
  2722  ec2b ff97989bffff       	 !byte $ff,$97,$98,$9b,$ff,$ff
  2723                          ; -------------------------------------------------------------------------------------------------
  2724                          ; EC31 <SHIFT> <RUN/STOP> String: DLOAD "*" + RUN
  2725  ec31 44cc222a0d         runtb:  !pet "d",$CC,$22,"*",$0D	; dL"* <RETURN>
  2726  ec36 52554e0d           	!pet "run",$0D          	; run <RETURN>
  2727                          ; -------------------------------------------------------------------------------------------------
  2728                          ;****** address of screen lines ******
  2729                          linz0	= scnram
  2730                          linz1	= linz0+llen
  2731                          linz2	= linz1+llen
  2732                          linz3	= linz2+llen
  2733                          linz4	= linz3+llen
  2734                          linz5	= linz4+llen
  2735                          linz6	= linz5+llen
  2736                          linz7	= linz6+llen
  2737                          linz8	= linz7+llen
  2738                          linz9	= linz8+llen
  2739                          linz10	= linz9+llen
  2740                          linz11	= linz10+llen
  2741                          linz12	= linz11+llen
  2742                          linz13	= linz12+llen
  2743                          linz14	= linz13+llen
  2744                          linz15	= linz14+llen
  2745                          linz16	= linz15+llen
  2746                          linz17	= linz16+llen
  2747                          linz18	= linz17+llen
  2748                          linz19	= linz18+llen
  2749                          linz20	= linz19+llen
  2750                          linz21	= linz20+llen
  2751                          linz22	= linz21+llen
  2752                          linz23	= linz22+llen
  2753                          linz24	= linz23+llen
  2754                          
  2755                          ;****** screen lines lo byte table ******
  2756  ec3a 00                 ldtb2:	!byte <linz0
  2757  ec3b 28                 	!byte <linz1
  2758  ec3c 50                 	!byte <linz2
  2759  ec3d 78                 	!byte <linz3
  2760  ec3e a0                 	!byte <linz4
  2761  ec3f c8                 	!byte <linz5
  2762  ec40 f0                 	!byte <linz6
  2763  ec41 18                 	!byte <linz7
  2764  ec42 40                 	!byte <linz8
  2765  ec43 68                 	!byte <linz9
  2766  ec44 90                 	!byte <linz10
  2767  ec45 b8                 	!byte <linz11
  2768  ec46 e0                 	!byte <linz12
  2769  ec47 08                 	!byte <linz13
  2770  ec48 30                 	!byte <linz14
  2771  ec49 58                 	!byte <linz15
  2772  ec4a 80                 	!byte <linz16
  2773  ec4b a8                 	!byte <linz17
  2774  ec4c d0                 	!byte <linz18
  2775  ec4d f8                 	!byte <linz19
  2776  ec4e 20                 	!byte <linz20
  2777  ec4f 48                 	!byte <linz21
  2778  ec50 70                 	!byte <linz22
  2779  ec51 98                 	!byte <linz23
  2780  ec52 c0                 	!byte <linz24
  2781                          
  2782                          ;****** screen lines hi byte table ******
  2783  ec53 d0                 ldtb1:	!byte >linz0
  2784  ec54 d0                 	!byte >linz1
  2785  ec55 d0                 	!byte >linz2
  2786  ec56 d0                 	!byte >linz3
  2787  ec57 d0                 	!byte >linz4
  2788  ec58 d0                 	!byte >linz5
  2789  ec59 d0                 	!byte >linz6
  2790  ec5a d1                 	!byte >linz7
  2791  ec5b d1                 	!byte >linz8
  2792  ec5c d1                 	!byte >linz9
  2793  ec5d d1                 	!byte >linz10
  2794  ec5e d1                 	!byte >linz11
  2795  ec5f d1                 	!byte >linz12
  2796  ec60 d2                 	!byte >linz13
  2797  ec61 d2                 	!byte >linz14
  2798  ec62 d2                 	!byte >linz15
  2799  ec63 d2                 	!byte >linz16
  2800  ec64 d2                 	!byte >linz17
  2801  ec65 d2                 	!byte >linz18
  2802  ec66 d2                 	!byte >linz19
  2803  ec67 d3                 	!byte >linz20
  2804  ec68 d3                 	!byte >linz21
  2805  ec69 d3                 	!byte >linz22
  2806  ec6a d3                 	!byte >linz23
  2807  ec6b d3                 	!byte >linz24
  2808                          ; -------------------------------------------------------------------------------------------------
  2809                          ; EC6C Dispatch table (control codes $00-$1F, $80-$9F)
  2810  ec6c 21e3               ctable:	!word cuser-1
  2811  ec6e 01e6               	!word chkcol-1		; -/orange
  2812  ec70 21e3               	!word cuser-1
  2813  ec72 c8e5               	!word stprun-1		; stop/run
  2814  ec74 a2e6               	!word ce-1		; cancel
  2815  ec76 01e6               	!word chkcol-1		; white/-
  2816  ec78 9fe7               	!word unused-1		; unused - from rev.01/02 editor (uses $03BF)
  2817  ec7a 74e6               	!word bell-1		; bell/-
  2818  ec7c 21e3               	!word cuser-1
  2819  ec7e 6ae3               	!word tabit-1		; tab/tab toggle
  2820  ec80 21e3               	!word cuser-1
  2821  ec82 21e3               	!word cuser-1
  2822  ec84 21e3               	!word cuser-1
  2823  ec86 a4e3               	!word nxt1-1		; return or shifted return
  2824  ec88 50e2               	!word ctext-1		; text/graphic mode
  2825  ec8a 87ea               	!word window-1		; set top/bottom
  2826  ec8c 01e6               	!word chkcol-1		; -/black
  2827  ec8e 24e3               	!word cdnup-1		; cursor down/up
  2828  ec90 54e3               	!word rvsf-1		; rvs on/off
  2829  ec92 5ae3               	!word homclr-1		; home/clr
  2830  ec94 5ae5               	!word delins-1		; delete/insert character
  2831  ec96 01e6               	!word chkcol-1		; -/brown
  2832  ec98 01e6               	!word chkcol-1		; -/lightred
  2833  ec9a 01e6               	!word chkcol-1		; -/gray1
  2834  ec9c 01e6               	!word chkcol-1		; -/gray2
  2835  ec9e 01e6               	!word chkcol-1		; -/lightgreen
  2836  eca0 01e6               	!word chkcol-1		; -/lightblue
  2837  eca2 01e6               	!word chkcol-1		; -/gray3
  2838  eca4 01e6               	!word chkcol-1		; red/purple
  2839  eca6 41e3               	!word crtlf-1		; cursor right/left
  2840  eca8 01e6               	!word chkcol-1		; green/yellow
  2841  ecaa 01e6               	!word chkcol-1		; blue/cyan
  2842                          ; -------------------------------------------------------------------------------------------------
  2843                          ; ECAC Length of function key texts
  2844  ecac 03                 keylen: !byte key2-key1
  2845  ecad 03                 	!byte key3-key2
  2846  ecae 03                 	!byte key4-key3
  2847  ecaf 03                 	!byte key5-key4
  2848  ecb0 0d                 	!byte key6-key5
  2849  ecb1 0d                 	!byte key7-key6
  2850  ecb2 04                 	!byte key8-key7
  2851  ecb3 09                 	!byte key9-key8
  2852  ecb4 03                 	!byte key10-key9
  2853  ecb5 03                 	!byte keyend-key10                   ; 57 bytes keydef-text
  2854                          
  2855                          !ifdef STANDARD_FKEYS{          ; ********** Standard F-keys **********
  2856                          ; ECB6 Function key definitions
  2857                          keydef:
  2858                          key1:	!pet "print"                    ; F1
  2859                          key2:	!pet "list"                     ; F2
  2860                          key3:	!pet "dload",$22                ; F3
  2861                          key4:	!pet "dsave",$22                ; F4
  2862                          key5:	!pet "dopen"                    ; F5
  2863                          key6:	!pet "dclose"                   ; F6
  2864                          key7:	!pet "copy"                     ; F7
  2865                          key8:	!pet "directory"                ; F8
  2866                          key9:	!pet "scratch"                  ; F9
  2867                          key10:	!pet "chr$("                    ; F10
  2868                          ; -------------------------------------------------------------------------------------------------
  2869                          } else{                         ; ********** F-keys PATCH **********
  2870                          ; ECB6 Function key definitions
  2871                          keydef:
  2872  ecb6 52d50d             key1:	!pet "rU",$0d                   ; F1
  2873  ecb9 4cc90d             key2:	!pet "lI",$0d                   ; F2
  2874  ecbc 44cc22             key3:	!pet "dL",$22                   ; F3
  2875  ecbf 44d322             key4:	!pet "dS",$22                   ; F4
  2876  ecc2 4fd0382c382c3135...key5:	!pet "oP8,8,15,",$22,"cd:"      ; F5
  2877  eccf 4fd0392c392c3135...key6:	!pet "oP9,9,15,",$22,"cd:"      ; F6
  2878  ecdc 4443cc0d           key7:	!pet "dcL",$0d                  ; F7
  2879  ece0 4449d244304f4e55...key8:	!pet "diRd0onu8"                ; F8
  2880  ece9 53c322             key9:	!pet "sC",$22                   ; F9
  2881  ecec 48c522             key10:	!pet "hE",$22                   ; F10
  2882                          }
  2883                          ; Function key definitions
  2884                          ;keydef:
  2885                          ;key1:	!pet "run"                      ; F1
  2886                          ;key2:	!pet "list"                     ; F2
  2887                          ;key3:	!pet "dload",$22                ; F3
  2888                          ;key4:	!pet "dsave",$22                ; F4
  2889                          ;key5:	!pet "print"                    ; F5
  2890                          ;key6:	!pet "chr$("                    ; F6
  2891                          ;key7:	!pet "bank"                     ; F7
  2892                          ;key8:	!pet "directory"                ; F8
  2893                          ;key9:	!pet "scratch",$22              ; F9
  2894                          ;key10:	!pet "header",$22               ; F10
  2895                          ;}
  2896                          keyend:
  2897                          ; -------------------------------------------------------------------------------------------------
  2898                          ; ECEF bits  -  bit position table
  2899  ecef 8040201008040201   bits:	!byte $80,$40,$20,$10,$08,$04,$02,$01
  2900                          ; -------------------------------------------------------------------------------------------------
  2901                          ; ECF7 VIC initialization table regs $11-$21 
  2902  ecf7 1b00000000080040   tvic:	!byte $1B,$00,$00,$00,$00,$08,$00,$40
  2903  ecff 8f00000000000003   	!byte $8F,$00,$00,$00,$00,$00,$00,EXTCOL
  2904  ed07 01                 	!byte BGRCOL
  2905                          ; -------------------------------------------------------------------------------------------------
  2906                          ; ED08 Extended editor vector table (copied to $3B5)
  2907  ed08 f6e9               edvect:	!word dokeyf
  2908  ed0a 41e6               	!word wrvram
  2909  ed0c 50e6               	!word wrcram
  2910  ed0e 36e0               	!word nofunc
  2911  ed10 36e0               	!word nofunc
  2912                          ; -------------------------------------------------------------------------------------------------
  2913                          ; ED12 Color control code table
  2914                          ; blk,wht,red,cyan,magenta,grn,blue,yellow
  2915  ed12 90051c9f9c1e1f9e   coltab:	!byte $90,$05,$1C,$9F,$9C,$1E,$1F,$9E
  2916                          ; org,brown,lred,gray1,gray2,lgreen,lblue,gray3
  2917  ed1a 8195969798999a9b   	!byte $81,$95,$96,$97,$98,$99,$9A,$9B
  2918                          ; rsr modify for vic-40 system			*** Just for fun from rev.1 c64-kernal rev.1 ;) ***
  2919                          ; rsr 12/31/81 add 8 more colors
  2920                          ; -------------------------------------------------------------------------------------------------
  2921                          ; ED22 checksum byte
  2922  ed22 28                 cksume	!byte $28		; e-page checksum
  2923                          ; -------------------------------------------------------------------------------------------------
  2924                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  2925                          ;**************************************************
  2926                          ; patch1 - checks for a single line window
  2927                          ;          aborts if so...
  2928                          ;**************************************************
  2929  ed23 a6dd               patch1:	ldx scbot		; check
  2930  ed25 e4dc               	cpx sctop
  2931  ed27 d002               	bne patcha		; no...pass through old code
  2932  ed29 68                 	pla			; abort
  2933  ed2a 68                 	pla
  2934  ed2b 2c8703             patcha:	bit scrdis		; restore patched area (test for scrolling mode)
  2935  ed2e 60                 	rts
  2936                          }
  2937                          ; -------------------------------------------------------------------------------------------------
  2938                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  2939                          ; patch 4a-2 - make space for clear insert flag
  2940                          patch4a2:
  2941  ed2f 20e9e4             	jsr fistrt		; find begining of line
  2942  ed32 a900               	lda #0
  2943  ed34 60                 	rts
  2944                          ; -------------------------------------------------------------------------------------------------
  2945                          ; patch 4a-4 - remember bootom line no
  2946                          patch4a4:
  2947  ed35 05d0               	ora crsw		; NO SENSE - a already 3
  2948  ed37 85d0               	sta crsw		; fake a carriage return
  2949  ed39 a5dd               	lda scbot
  2950  ed3b 8d8403             	sta lintmp		; remember bootom line no
  2951  ed3e a5df               	lda scrt		; moved to patch to make space
  2952  ed40 60                 	rts
  2953                          ; -------------------------------------------------------------------------------------------------
  2954                          ; patch 4a-3 - RS232 output
  2955                          patch4a3:
  2956  ed41 9003               	bcc p4a3		; -> check output ?
  2957  ed43 4c5af9             	jmp errorx		; moved to patch to make space
  2958  ed46 08                 p4a3:	php
  2959  ed47 48                 	pha
  2960  ed48 a5a0               	lda sa
  2961  ed4a 2901               	and #$01
  2962  ed4c f00a               	beq p4a3x		; no output
  2963  ed4e a69e               	ldx la
  2964  ed50 20c9ff             	jsr ckout		; open channel
  2965  ed53 20ccff             	jsr clrch		; close channel
  2966  ed56 a6a6               	ldx ribuf
  2967  ed58 68                 p4a3x:	pla
  2968  ed59 28                 	plp
  2969  ed5a 60                 	rts
  2970                          }
  2971                          ; -------------------------------------------------------------------------------------------------
  2972                          !ifdef SYSPATCH{
  2973                          poker	= $1B
  2974                          dfbank	= $0257
  2975                          getpin	= $B4B9
  2976                          *= $EDDC
  2977  eddc 20b9b4             csys:	jsr getpin      ; get positive integer
  2978  eddf a501               	lda i6509
  2979  ede1 48                 	pha
  2980  ede2 ad5702             	lda dfbank 	; current bank
  2981  ede5 c90f               	cmp #$F
  2982  ede7 f00b               	beq fligm
  2983  ede9 a61b               	ldx poker
  2984  edeb a41c               	ldy poker+1
  2985  eded 206cff             	jsr newsys
  2986                          csysrz	=*-1
  2987  edf0 68                 	pla
  2988  edf1 8501               	sta $1
  2989  edf3 60                 	rts
  2990                          fligm:
  2991  edf4 a9ed               	lda #>csysrz    ;push return address
  2992  edf6 48                 	pha
  2993  edf7 a9ef               	lda #<csysrz
  2994  edf9 48                 	pha
  2995  edfa 6c1b00             	jmp (poker)
  2996  edfd 60                 	rts	
  2997                          }
  2998                          ; ****************************************** KERNAL ***********************************************
  2999                          ; ##### monitor #####
  3000                          !zone kernal
  3001                          ;************************************************
  3002                          ;* kernal monitor                               *
  3003                          ;*                                              *
  3004                          ;* entry via call (jmp) or breakpoint (brk)     *
  3005                          ;* ---functions---                              *
  3006                          ;* <:>      alter memory                        *
  3007                          ;* <;>      alter registers                     *
  3008                          ;* <r>      display registers                   *
  3009                          ;* <m>      display memory                      *
  3010                          ;* <g>      start execution of code             *
  3011                          ;* <l>      load memory                         *
  3012                          ;* <s>      save memory                         *
  3013                          ;* <v>      view segment                        *
  3014                          ;* <@>      disk command                        *
  3015                          ;* <x>      warm start basic                    *
  3016                          ;* <u>      set default disk unit               *
  3017                          ;* <other>  load and execute from disk          *
  3018                          ;*                                              *
  3019                          ;* for syntax & semantics see cbm kernal manual *
  3020                          ;* copyright (c) 1981 by cbm                    *
  3021                          ;************************************************
  3022                          ; EE00 Reset Entry
  3023                          *= kernal+$E00
  3024                          
  3025                          ; ***** Warm start entry *******
  3026  ee00 20fef9             monon:	jsr ioinit		; get i/o
  3027  ee03 20b1fb             	jsr restor		; vectors
  3028  ee06 2004e0             	jsr jcint		; screen editor
  3029                          
  3030                          ; ***** Cold start entry ******
  3031  ee09 20ccff             monoff:	jsr clrch		; clear channels
  3032  ee0c a95a               	lda #winit		; waste two bytes so timc=60950
  3033  ee0e a200               	ldx #<monon		; point reset vectors at monitor on
  3034  ee10 a0ee               	ldy #>monon
  3035  ee12 20d9fb             	jsr vreset
  3036  ee15 58                 	cli			; release irq's
  3037                          
  3038                          ; ***** Call entry *****
  3039  ee16 a9c0               timc:	lda #$40+$80
  3040  ee18 8d6103             	sta msgflg		; error+messages on
  3041  ee1b a940               	lda #ms34-ms1		; call entry
  3042  ee1d 85bd               	sta tmpc
  3043  ee1f d010               	bne b3			; branch always
  3044                          
  3045                          ; ***** Break entry *****
  3046  ee21 20ccff             timb:	jsr clrch		; clr channels
  3047  ee24 a953               	lda #ms36-ms1		; break entry
  3048  ee26 85bd               	sta tmpc
  3049  ee28 d8                 	cld 
  3050                          
  3051                          ; Save .y,.x,.a,flags, and pc
  3052  ee29 a205               	ldx #5
  3053                          ; EE2B Pop registers from stack and save them
  3054  ee2b 68                 b1:	pla
  3055  ee2c 95ae               	sta pch,x
  3056  ee2e ca                 	dex
  3057  ee2f 10fa               	bpl b1
  3058                          
  3059  ee31 a501               b3:	lda i6509		; save indirection segment
  3060  ee33 85b5               	sta xi6509
  3061  ee35 ad0003             	lda cinv
  3062  ee38 85b8               	sta invl		; save irq low
  3063  ee3a ad0103             	lda cinv+1
  3064  ee3d 85b7               	sta invh		; save irq high
  3065                          
  3066  ee3f ba                 	tsx
  3067  ee40 86b4               	stx sp			; save original sp
  3068  ee42 58                 	cli			; clear ints
  3069  ee43 a908               	lda #8			; set disk default to 8
  3070  ee45 85bf               	sta ddisk
  3071                          
  3072  ee47 a4bd               b5:	ldy tmpc		; message code
  3073  ee49 2023f2             	jsr spmsg		; print break/call
  3074                          
  3075  ee4c a952               	lda #'r'		; display regs on entry
  3076  ee4e d023               	bne s0			; branch always
  3077                          ; EE50 ***** Error entry *****
  3078                          
  3079  ee50 201eef             erropr:	jsr outqst
  3080  ee53 68                 	pla
  3081  ee54 68                 	pla
  3082                          
  3083                          ; ***** Command interpreter entry *****
  3084                          strtm1=*-1
  3085  ee55 a9c0               	lda #$40+$80
  3086  ee57 8d6103             	sta msgflg		; i/o messages to screen
  3087  ee5a a900               	lda #<buf		; put filename at bottom of basic buffer
  3088  ee5c 8590               	sta fnadr
  3089  ee5e a902               	lda #>buf
  3090  ee60 8591               	sta fnadr+1
  3091  ee62 a90f               	lda #irom
  3092  ee64 8592               	sta fnadr+2
  3093  ee66 2021ef             	jsr crlf
  3094                          
  3095  ee69 20cfff             st1:	jsr basin		; read command
  3096                          
  3097  ee6c c920               	cmp #' '
  3098  ee6e f0f9               	beq st1			; span blanks
  3099  ee70 6c1e03             	jmp (usrcmd)		; user indirect for monitor
  3100                          ; -------------------------------------------------------------------------------------------------
  3101                          ; EE73 Command interpreter
  3102  ee73 a200               s0:	ldx #0
  3103  ee75 869d               	stx fnlen
  3104  ee77 a8                 	tay			; save current command
  3105                          
  3106                          ; Put return address for commands on stack
  3107  ee78 a9ee               	lda #>strtm1
  3108  ee7a 48                 	pha
  3109  ee7b a954               	lda #<strtm1
  3110  ee7d 48                 	pha
  3111                          
  3112  ee7e 98                 	tya			; current command in .a
  3113                          
  3114  ee7f ddd1ee             s1:	cmp cmds,x		; is it this one?
  3115  ee82 d010               	bne s2			; notit
  3116                          
  3117  ee84 8d6603             	sta savx		; save current command
  3118                          
  3119                          ; Indirect jmp from table
  3120  ee87 bdd2ee             	lda cmds+1,x
  3121  ee8a 85b9               	sta tmp0
  3122  ee8c bdd3ee             	lda cmds+2,x
  3123  ee8f 85ba               	sta tmp0+1
  3124  ee91 6cb900             	jmp (tmp0)
  3125                          ; -------------------------------------------------------------------------------------------------
  3126                          ; EE94 Each table entry is 3 long---skip to next
  3127  ee94 e8                 s2:	inx
  3128  ee95 e8                 	inx
  3129  ee96 e8                 	inx
  3130  ee97 e024               	cpx #cmdend-cmds
  3131  ee99 90e4               	bcc s1			; loop for all commands
  3132                          
  3133                          ; Command not in table...look on disk.
  3134                          ; Command name can be any length and have parameters.
  3135  ee9b a200               	ldx #0			; length to zero
  3136  ee9d c90d               s3:	cmp #$D			; end of name?
  3137  ee9f f00d               	beq s4			; yes...
  3138  eea1 c920               	cmp #' '		; blank?
  3139  eea3 f009               	beq s4			; yes
  3140  eea5 9d0002             	sta buf,x
  3141  eea8 20cfff             	jsr basin		; get next
  3142  eeab e8                 	inx			; count char
  3143  eeac d0ef               	bne s3			; and continue
  3144                          
  3145  eeae 85bd               s4:	sta tmpc
  3146  eeb0 8a                 	txa			; count
  3147  eeb1 f01d               	beq s6			; is zero
  3148                          
  3149  eeb3 859d               	sta fnlen
  3150  eeb5 a940               	lda #$40
  3151  eeb7 8d6103             	sta msgflg		; messages off
  3152  eeba a5bf               	lda ddisk
  3153  eebc 859f               	sta fa			; will use default disk
  3154  eebe a90f               	lda #irom		; commands only load to rom segment !!!***
  3155  eec0 8501               	sta i6509		; turn indirect to rom segment
  3156  eec2 a2ff               	ldx #$FF
  3157  eec4 a0ff               	ldy #$FF
  3158  eec6 20d5ff             	jsr load		; try to load command
  3159  eec9 b005               	bcs s6			; bad load...
  3160                          
  3161  eecb a5bd               	lda tmpc		; pass last character
  3162  eecd 6c9900             	jmp (stal)		; go do it
  3163                          
  3164  eed0 60                 s6:	rts
  3165                          ; -------------------------------------------------------------------------------------------------
  3166                          ; EED1 Command table
  3167  eed1 3a                 cmds:	!pet ':'		; alter memory
  3168  eed2 f7ef               	!word altm
  3169  eed4 3b                 	!pet ';'		; alter registers
  3170  eed5 c5ef               	!word altr
  3171  eed7 52                 	!pet 'r'		; display registers
  3172  eed8 41ef               	!word dsplyr
  3173  eeda 4d                 	!pet 'm'		; display memory
  3174  eedb 84ef               	!word dsplym
  3175  eedd 47                 	!pet 'g'		; start execution
  3176  eede 14f0               	!word go
  3177  eee0 4c                 	!pet 'l'		; load memory
  3178  eee1 43f0               	!word ld
  3179  eee3 53                 	!pet 's'		; save memory
  3180  eee4 43f0               	!word ld
  3181  eee6 56                 	!pet 'v'		; view segment
  3182  eee7 dfef               	!word view
  3183  eee9 40                 	!pet '@'		; disk command (alternate)
  3184  eeea 68f1               	!word disk
  3185  eeec 5a                 	!pet 'z'		; transfer to 2nd microprocessor
  3186  eeed 72ff               	!word ipcgov		; ipcgo vector
  3187  eeef 58                 	!pet 'x'		; warm start basic
  3188  eef0 f5ee               	!word xeit
  3189  eef2 55                 	!pet 'u'		; default disk unit set
  3190  eef3 ebef               	!word unitd
  3191                          cmdend:
  3192                          ; -------------------------------------------------------------------------------------------------
  3193                          ; EEF5 Exit 'x'
  3194  eef5 68                 xeit:	pla			; remove command return from stack
  3195  eef6 68                 	pla
  3196  eef7 78                 	sei			; disable interrupts...all warm start code expects
  3197  eef8 6cf803             	jmp (evect)		; go warmstart language
  3198                          ; -------------------------------------------------------------------------------------------------
  3199                          ; EEFB Move tmp0/tmp0+1 to PC memory location
  3200  eefb a5b9               putp:	lda tmp0		; move tmp0 to pch,pcl
  3201  eefd 85af               	sta pcl
  3202  eeff a5ba               	lda tmp0+1
  3203  ef01 85ae               	sta pch
  3204  ef03 60                 	rts
  3205                          ; -------------------------------------------------------------------------------------------------
  3206                          ; EF04 Set tmp0 to point to the saved regs in zero page
  3207  ef04 a9b0               setr:	lda #<flgs		; set to access regs
  3208  ef06 85b9               	sta tmp0
  3209  ef08 a900               	lda #>flgs
  3210  ef0a 85ba               	sta tmp0+1
  3211  ef0c a90f               	lda #irom		; point indirect at roms
  3212  ef0e 8501               	sta i6509
  3213  ef10 a905               	lda #5
  3214  ef12 60                 	rts
  3215                          ; -------------------------------------------------------------------------------------------------
  3216                          ; EF13 Prints '.:' or '.;' before data to permit alter after 'm' or 'r' command
  3217                          
  3218  ef13 48                 altrit: pha			; preserve alter character
  3219  ef14 2021ef             	jsr crlf
  3220  ef17 68                 	pla
  3221  ef18 20d2ff             	jsr bsout
  3222                          
  3223  ef1b a920               space:  lda #' '		; output a space
  3224  ef1d 2c                 	!byte $2C		; skip two bytes
  3225                          
  3226  ef1e a93f               outqst: lda #'?'		; output question
  3227  ef20 2c                 	!byte $2C		; skip two bytes
  3228                          
  3229  ef21 a90d               crlf:   lda #$D		; do carriage return
  3230  ef23 4cd2ff             	jmp bsout
  3231                          ; -------------------------------------------------------------------------------------------------
  3232                          ; EF26 Data for register display heading
  3233  ef26 0d2020             regk:	!pet cr,"  "		; 3 spaces
  3234  ef29 2050432020495251...	!pet " pc "," irq "," sr ac xr yr sp"
  3235                          ; -------------------------------------------------------------------------------------------------
  3236                          ; EF41 Display register function 'r'
  3237  ef41 a200               dsplyr:	ldx #0
  3238  ef43 bd26ef             d2:	lda regk,x
  3239  ef46 20d2ff             	jsr bsout		; print heading
  3240  ef49 e8                 	inx
  3241  ef4a e01b               	cpx #dsplyr-regk	; max length
  3242  ef4c d0f5               	bne d2
  3243  ef4e a93b               	lda #';'
  3244  ef50 2013ef             	jsr altrit		; allow alter after display
  3245  ef53 a6ae               	ldx pch
  3246  ef55 a4af               	ldy pcl
  3247  ef57 20f9f0             	jsr wroa		; print program counter
  3248  ef5a 201bef             	jsr space
  3249  ef5d a6b7               	ldx invh
  3250  ef5f a4b8               	ldy invl
  3251  ef61 20f9f0             	jsr wroa		; print irq vector
  3252  ef64 2004ef             	jsr setr		; set to print .p,.a,.x,.y,.s
  3253                          
  3254                          ; display memory subroutine
  3255  ef67 85bd               dm:	sta tmpc		; byte count
  3256  ef69 a000               	ldy #0			; indirect index
  3257  ef6b 849d               	sty fnlen		; fnlen is zero-page crossing flag...
  3258  ef6d 201bef             dm1:	jsr space		; space tween bytes
  3259  ef70 b1b9               	lda (tmp0),y
  3260  ef72 20fef0             	jsr wrob		; write byte of memory
  3261                          
  3262                          ; increment indirect
  3263  ef75 e6b9               	inc tmp0
  3264  ef77 d006               	bne dm2
  3265  ef79 e6ba               	inc tmp0+1
  3266  ef7b d002               	bne dm2			; no zero page crossing
  3267  ef7d c69d               	dec fnlen		; fnlen<>0 is flag
  3268                          
  3269  ef7f c6bd               dm2:	dec tmpc		; count bytes
  3270  ef81 d0ea               	bne dm1			; until zero
  3271  ef83 60                 	rts
  3272                          ; -------------------------------------------------------------------------------------------------
  3273                          ; EF84 Display memory function 'm'
  3274  ef84 2026f1             dsplym:	jsr rdoa		; read start adr
  3275  ef87 b039               	bcs arrn		; ...err if no sa
  3276  ef89 2016f1             	jsr t2t2		; sa to tmp2
  3277                          
  3278                          ; allow user to type just one address
  3279  ef8c 2026f1             	jsr rdoa		; read end adr
  3280  ef8f 9008               	bcc dsp123		; good...no default
  3281                          
  3282  ef91 a5bb               	lda tmp2
  3283  ef93 85b9               	sta tmp0		; default low byte
  3284  ef95 a5bc               	lda tmp2+1
  3285  ef97 85ba               	sta tmp0+1		; default hi byte
  3286                          
  3287  ef99 2016f1             dsp123:	jsr t2t2		; sa to tmp0, ea to tmp2
  3288  ef9c 20e1ff             dsp1:	jsr stop		; stop key?
  3289  ef9f f020               	beq beqs1		; yes...break list
  3290                          
  3291  efa1 a93a               	lda #':'
  3292  efa3 2013ef             	jsr altrit		; allow alter
  3293  efa6 a6ba               	ldx tmp0+1
  3294  efa8 a4b9               	ldy tmp0
  3295  efaa 20f9f0             	jsr wroa		; write start address
  3296                          
  3297  efad a908               	lda #8			; count of bytes
  3298  efaf 2067ef             	jsr dm			; display bytes
  3299                          
  3300  efb2 a59d               	lda fnlen		; check for zero-crossing
  3301  efb4 d00b               	bne beqs1		; yup....
  3302  efb6 38                 	sec
  3303  efb7 a5bb               	lda tmp2
  3304  efb9 e5b9               	sbc tmp0
  3305  efbb a5bc               	lda tmp2+1
  3306  efbd e5ba               	sbc tmp0+1
  3307  efbf b0db               	bcs dsp1		; end >= start
  3308                          
  3309  efc1 60                 beqs1:	rts			; a.o.k. exit
  3310                          
  3311  efc2 4c50ee             arrn:	jmp erropr		; syntax error jump
  3312                          ; -------------------------------------------------------------------------------------------------
  3313                          ; EFC5 Alter register function ';'
  3314  efc5 2026f1             altr:	jsr rdoa		; read new pc
  3315  efc8 b0f8               	bcs arrn		; ...no address=error
  3316                          
  3317  efca 20fbee             	jsr putp		; alter pc
  3318                          
  3319  efcd 2026f1             	jsr rdoa		; read new irq
  3320  efd0 b0f0               	bcs arrn		; ...no address=error
  3321                          
  3322  efd2 a5b9               	lda tmp0
  3323  efd4 85b8               	sta invl		; alter irq vector
  3324  efd6 a5ba               	lda tmp0+1
  3325  efd8 85b7               	sta invh
  3326                          
  3327  efda 2004ef             	jsr setr		; set to alter r's
  3328  efdd d01f               	bne a4			; branch always
  3329                          ; -------------------------------------------------------------------------------------------------
  3330                          ; EFDF View a segment (point indirect) 'v'
  3331  efdf 2033f1             view:	jsr rdob		; get a byte
  3332  efe2 b0de               	bcs arrn		; ...if none...error
  3333  efe4 c910               	cmp #16			; range 0-15
  3334  efe6 b0da               	bcs arrn		; to large no modulo
  3335  efe8 8501               	sta i6509
  3336  efea 60                 	rts
  3337                          ; -------------------------------------------------------------------------------------------------
  3338                          ; EFEB Unit default for disk 'u'
  3339  efeb 2033f1             unitd:	jsr rdob		; get a byte
  3340  efee b0d2               	bcs arrn		; ...if none...error
  3341  eff0 c920               	cmp #32			; range 0-31
  3342  eff2 b0ce               	bcs arrn		; to large no modulo
  3343  eff4 85bf               	sta ddisk
  3344  eff6 60                 	rts
  3345                          ; -------------------------------------------------------------------------------------------------
  3346                          ; EFF7 Alter memory - read adr and data ':'
  3347  eff7 2026f1             altm:	jsr rdoa		; read alter adr
  3348  effa b0c6               	bcs arrn		; ...if none...error
  3349                          
  3350  effc a908               	lda #8			; allow 8 bytes change
  3351                          
  3352                          ; common code for ':' and ';'
  3353  effe 85bd               a4:	sta tmpc		; number of bytes to change
  3354                          
  3355  f000 2033f1             a5:	jsr rdob		; read byte
  3356  f003 b00e               	bcs a9
  3357                          
  3358  f005 a000               	ldy #0
  3359  f007 91b9               	sta (tmp0),y		; store it away
  3360                          
  3361                          ; increment store address
  3362  f009 e6b9               	inc tmp0
  3363  f00b d002               	bne a6
  3364  f00d e6ba               	inc tmp0+1
  3365                          
  3366  f00f c6bd               a6:	dec tmpc		; count byte
  3367  f011 d0ed               	bne a5			; until zero
  3368  f013 60                 a9:	rts
  3369                          ; -------------------------------------------------------------------------------------------------
  3370                          ; F014 Start execution function 'g'
  3371  f014 2062f1             go:	jsr rdoc		; see if default
  3372  f017 f008               	beq g1			; yes...pc is address
  3373  f019 2026f1             	jsr rdoa		; no...get new addr
  3374  f01c b022               	bcs errl		; ...none=error
  3375  f01e 20fbee             	jsr putp		; move addr to p.c.
  3376                          
  3377  f021 a6b4               g1:	ldx sp
  3378  f023 9a                 	txs			; orig or new sp value to sp
  3379                          
  3380  f024 78                 	sei			; prevent disaster
  3381                          
  3382  f025 a5b7               	lda invh
  3383  f027 8d0103             	sta cinv+1		; set up irq vector
  3384  f02a a5b8               	lda invl
  3385  f02c 8d0003             	sta cinv
  3386  f02f a5b5               	lda xi6509		; and indirection register
  3387  f031 8501               	sta i6509
  3388                          
  3389                          ; get flags,pch,pcl,.a,.x,.y
  3390  f033 a200               	ldx #0
  3391  f035 b5ae               g2:	lda pch,x
  3392  f037 48                 	pha			; everybody on stack
  3393  f038 e8                 	inx
  3394  f039 e006               	cpx #6
  3395  f03b d0f8               	bne g2
  3396                          
  3397                          ; interrupt return sets everybody up from data on stack
  3398  f03d 4cb3fc             	jmp prend
  3399                          
  3400  f040 4c50ee             errl:	jmp erropr
  3401                          ; -------------------------------------------------------------------------------------------------
  3402                          ; F043 Load ram function 'l' and 's'
  3403                          ;  *note - load/save reset indirect to rom
  3404  f043 a001               ld:	ldy #1
  3405  f045 849f               	sty fa			; default device #1
  3406  f047 88                 	dey			; .y=0 to count name length
  3407  f048 a9ff               	lda #$FF		; default no move load
  3408  f04a 85b9               	sta tmp0
  3409  f04c 85ba               	sta tmp0+1
  3410  f04e a501               	lda i6509		; save indirect for seg address
  3411  f050 85be               	sta t6509
  3412  f052 a90f               	lda #irom		; indirect to rom for filename
  3413  f054 8501               	sta i6509
  3414                          
  3415  f056 2062f1             l1:	jsr rdoc		; default?
  3416  f059 f01c               	beq l5			; yes...try load
  3417                          
  3418  f05b c920               	cmp #' '
  3419  f05d f0f7               	beq l1			; span blanks
  3420                          
  3421  f05f c922               	cmp #$22		; string next?
  3422  f061 d0dd               l2:	bne errl		; no file name...
  3423                          
  3424  f063 2062f1             l3:	jsr rdoc		; get character of name
  3425  f066 f00f               	beq l5			; end...asssume load
  3426                          
  3427  f068 c922               	cmp #$22		; end of string?
  3428  f06a f01d               	beq l8			; yes...could still be 'l' or 's'
  3429                          
  3430  f06c 9190               	sta (fnadr),y		; store name
  3431  f06e e69d               	inc fnlen
  3432  f070 c8                 	iny
  3433  f071 c010               	cpy #16			; max file name length
  3434                          
  3435  f073 f0cb               l4:	beq errl		; file name too long
  3436  f075 d0ec               	bne l3			; branch always
  3437                          ; see if we got a load
  3438  f077 ad6603             l5:	lda savx		; get last command
  3439  f07a c94c               	cmp #'l'
  3440  f07c d0e3               	bne l2			; no..not a load..error
  3441                          
  3442  f07e a5be               	lda t6509		; get segment to load to
  3443  f080 290f               	and #irom		; mask off verify bit
  3444  f082 a6b9               	ldx tmp0
  3445  f084 a4ba               	ldy tmp0+1
  3446  f086 4cd5ff             	jmp load		; yes...do load
  3447                          
  3448  f089 2062f1             l8:	jsr rdoc		; more stuff?
  3449  f08c f0e9               	beq l5			; no...defualt load
  3450                          
  3451  f08e c92c               	cmp #','		; delimeter?
  3452  f090 d0cf               l9:	bne l2			; no...bad syntax
  3453                          
  3454  f092 2033f1             	jsr rdob		; yes...get next parm
  3455  f095 b05f               	bcs l15			; ...error if none
  3456                          
  3457  f097 859f               	sta fa
  3458                          
  3459  f099 2062f1             	jsr rdoc		; more parms?
  3460  f09c f0d9               	beq l5			; no...default load
  3461                          
  3462  f09e c92c               	cmp #','		; delimeter?
  3463  f0a0 d0ee               l12:	bne l9			; no...bad syntax
  3464                          
  3465  f0a2 2033f1             	jsr rdob		; segment byte ?
  3466  f0a5 b04f               	bcs l15			; ...must have
  3467  f0a7 c910               	cmp #16			; 00-0f allowed
  3468  f0a9 b04b               	bcs l15			; too big...
  3469  f0ab 85be               	sta t6509
  3470  f0ad 859b               	sta stas		; prep segment
  3471  f0af 2026f1             	jsr rdoa
  3472  f0b2 b042               	bcs l15
  3473                          ; set up start save address
  3474  f0b4 a5b9               	lda tmp0
  3475  f0b6 8599               	sta stal
  3476  f0b8 a5ba               	lda tmp0+1
  3477  f0ba 859a               	sta stah
  3478                          
  3479  f0bc 2062f1             	jsr rdoc		; delimeter?
  3480  f0bf f0b6               	beq l5			; cr, do load
  3481  f0c1 c92c               	cmp #','
  3482  f0c3 d031               	bne l15			; no delim
  3483                          
  3484  f0c5 2033f1             	jsr rdob		; get segment byte
  3485  f0c8 b02c               	bcs l15			; ...must have
  3486  f0ca c910               	cmp #16			; allow only 00-0f
  3487  f0cc b028               	bcs l15			; too big...
  3488  f0ce 8598               	sta eas			; prep segment
  3489  f0d0 2026f1             	jsr rdoa		; try to read end address
  3490  f0d3 b021               	bcs l15			; ...must have
  3491                          
  3492                          ; set up end save address
  3493  f0d5 a5b9               	lda tmp0
  3494  f0d7 8596               	sta eal
  3495  f0d9 a5ba               	lda tmp0+1
  3496  f0db 8597               	sta eah
  3497                          
  3498  f0dd 20cfff             l20:	jsr basin
  3499  f0e0 c920               	cmp #' '
  3500  f0e2 f0f9               	beq l20			; span blanks
  3501                          
  3502  f0e4 c90d               	cmp #cr
  3503  f0e6 d0b8               l14:	bne l12			; missing cr at end
  3504  f0e8 ad6603             	lda savx 		; was command save?
  3505  f0eb c953               	cmp #'s'
  3506  f0ed d0f7               	bne l14			; no...load can't have parms
  3507  f0ef a299               	ldx #stal		; get params for save
  3508  f0f1 a096               	ldy #eal
  3509  f0f3 4cd8ff             	jmp save
  3510                          
  3511  f0f6 4c50ee             l15:	jmp erropr
  3512                          ; -------------------------------------------------------------------------------------------------
  3513                          ; F0F9 Write adr from tmp0 stores
  3514  f0f9 8a                 wroa:   txa			; hi-byte
  3515  f0fa 20fef0             	jsr wrob
  3516  f0fd 98                 	tya			; low-byte
  3517                          ; F0FE Write byte --- a = byte
  3518                          ; unpack byte data into two ascii characters. a=byte; x,a=chars
  3519  f0fe 48                 wrob:   pha
  3520  f0ff 4a                 	lsr
  3521  f100 4a                 	lsr
  3522  f101 4a                 	lsr
  3523  f102 4a                 	lsr
  3524  f103 200af1             	jsr ascii		; convert to ascii
  3525  f106 aa                 	tax
  3526  f107 68                 	pla
  3527  f108 290f               	and #$0F
  3528                          ; F10A Convert nybble in a to ascii and print it
  3529  f10a 18                 ascii:	clc
  3530  f10b 69f6               	adc #$F6
  3531  f10d 9002               	bcc asc1
  3532  f10f 6906               	adc #$06
  3533  f111 693a               asc1:	adc #$3A
  3534  f113 4cd2ff             	jmp bsout
  3535                          ; -------------------------------------------------------------------------------------------------
  3536                          ; F116 Exchange temporaries
  3537  f116 a202               t2t2:	ldx #2
  3538  f118 b5b8               t2t21:	lda tmp0-1,x
  3539  f11a 48                 	pha
  3540  f11b b5ba               	lda tmp2-1,x
  3541  f11d 95b8               	sta tmp0-1,x 
  3542  f11f 68                 	pla
  3543  f120 95ba               	sta tmp2-1,x
  3544  f122 ca                 	dex
  3545  f123 d0f3               	bne t2t21
  3546  f125 60                 	rts
  3547                          ; -------------------------------------------------------------------------------------------------
  3548                          ; F126 Read hex adr,return hi in tmp0, lo in tmp0+1,and cy=1, if sp cy=0
  3549  f126 2033f1             rdoa:	jsr rdob		; read 2-char byte
  3550  f129 b007               	bcs rdoa2		; space
  3551  f12b 85ba               	sta tmp0+1
  3552  f12d 2033f1             	jsr rdob
  3553  f130 85b9               	sta tmp0
  3554  f132 60                 rdoa2:	rts
  3555                          ; -------------------------------------------------------------------------------------------------
  3556                          ; F133 Read hex byte and return in a and cy=0 if sp cy=1
  3557  f133 a900               rdob:	lda #0			; space
  3558  f135 8d0001             	sta bad			; read next char
  3559  f138 2062f1             	jsr rdoc
  3560  f13b f019               	beq rdob4		; fail on cr
  3561  f13d c920               	cmp #' '		; blank?
  3562  f13f f0f2               	beq rdob		; span blanks...
  3563                          
  3564  f141 2057f1             	jsr hexit		; convert to hex nybble
  3565  f144 0a                 	asl
  3566  f145 0a                 	asl
  3567  f146 0a                 	asl
  3568  f147 0a                 	asl
  3569  f148 8d0001             	sta bad
  3570  f14b 2062f1             	jsr rdoc		; 2nd char assumed hex
  3571  f14e f006               	beq rdob4		; fail on cr
  3572  f150 2057f1             	jsr hexit
  3573  f153 0d0001             	ora bad
  3574                          
  3575  f156 60                 rdob4:	rts
  3576                          ; -------------------------------------------------------------------------------------------------
  3577                          ; F157 Convert char in A into hex value
  3578  f157 c93a               hexit:  cmp #$3A
  3579  f159 08                 	php			; save flags
  3580  f15a 290f               	and #$0F
  3581  f15c 28                 	plp
  3582  f15d 9002               	bcc hex09		; 0-9
  3583  f15f 6908               	adc #8			; alpha add 8+cy=9
  3584  f161 60                 hex09:	rts
  3585                          ; -------------------------------------------------------------------------------------------------
  3586                          ; F162 Get character and test for cr
  3587  f162 20cfff             rdoc:	jsr basin
  3588  f165 c90d               	cmp #$D			; is it a cr
  3589  f167 60                 	rts			; return with flags
  3590                          ; -------------------------------------------------------------------------------------------------
  3591                          ; F168 Send disk command or read status '@'
  3592  f168 a900               disk:	lda #0			; clear status @ i/o begin
  3593  f16a 859c               	sta status
  3594  f16c 859d               	sta fnlen		; filename length of zero...
  3595                          
  3596  f16e a6bf               	ldx ddisk		; get default disk
  3597  f170 a00f               	ldy #$0F		; open command channel
  3598  f172 204ffb             	jsr setlfs		; .a-0 temporary channel #
  3599  f175 18                 	clc
  3600  f176 20c0ff             	jsr open		; open a real channel
  3601  f179 b044               	bcs disk30		; exit if bad return
  3602                          
  3603  f17b 2062f1             	jsr rdoc		; see if status check
  3604  f17e f01d               	beq disk20		; yes
  3605                          
  3606  f180 48                 	pha
  3607  f181 a200               	ldx #0
  3608  f183 20c9ff             	jsr ckout		; set up as output
  3609  f186 68                 	pla
  3610  f187 b036               	bcs disk30		; bad status return
  3611  f189 9003               	bcc disk15		; no...ok
  3612                          
  3613  f18b 20cfff             disk10:	jsr basin		; get a character
  3614  f18e c90d               disk15:	cmp #$D			; see if end
  3615  f190 08                 	php			; save for later
  3616  f191 20d2ff             	jsr bsout		; out to floppy
  3617  f194 a59c               	lda status
  3618  f196 d023               	bne disk28		; bad status returned
  3619  f198 28                 	plp			; end?
  3620  f199 d0f0               	bne disk10		; no...continue
  3621  f19b f022               	beq disk30		; yes...floppy done
  3622                          
  3623  f19d 2021ef             disk20:	jsr crlf
  3624  f1a0 a200               	ldx #0
  3625  f1a2 20c6ff             	jsr chkin		; tell floppy to speak
  3626  f1a5 b018               	bcs disk30		; bad device
  3627                          
  3628  f1a7 20cfff             disk25:  jsr basin		; get a character
  3629  f1aa c90d               	cmp #$0D
  3630  f1ac 08                 	php			; save test for later
  3631  f1ad 20d2ff             	jsr bsout		; out to screen
  3632  f1b0 a59c               	lda status		; check for bad basin
  3633  f1b2 29bf               	and #$FF-$40		; remove eoi bit
  3634  f1b4 d005               	bne disk28		; report bad status
  3635  f1b6 28                 	plp			; end?
  3636  f1b7 d0ee               	bne disk25		; no...
  3637  f1b9 f004               	beq disk30		; yes...floppy done
  3638                          
  3639  f1bb 68                 disk28:	pla			; clean up...
  3640  f1bc 204cf9             disk29:	jsr error5		; report error #5 for bad device
  3641  f1bf 20ccff             disk30:	jsr clrch		; clean up
  3642  f1c2 a900               	lda #0
  3643  f1c4 18                 	clc			; just remove from table
  3644  f1c5 4cc3ff             	jmp close
  3645                          ; -------------------------------------------------------------------------------------------------
  3646                          ; F1C8 Unused
  3647  f1c8 ea                 	nop
  3648  f1c9 ea                 	nop
  3649                          ; -------------------------------------------------------------------------------------------------
  3650                          ; F1CA ##### messages #####
  3651  f1ca 0d492f4f20455252...ms1:	!pet $0D,"i/o error ",$A3
  3652  f1d6 0d53454152434849...ms5:	!pet $0D,"searching",$A0
  3653  f1e1 464f52a0           ms6:	!pet "for",$A0
  3654                          ;ms7:	!pet $0D,"press play on tap",$C5
  3655                          ;ms8:	!pet "press record & play on tap",$C5
  3656  f1e5 0d4c4f4144494ec7   ms10:	!pet $0D,"loadin",$C7
  3657  f1ed 0d534156494e47a0   ms11:	!pet $0D,"saving",$A0
  3658  f1f5 0d56455249465949...ms21:	!pet $0D,"verifyin",$C7
  3659  f1ff 0d464f554e44a0     ms17:	!pet $0D,"found",$A0
  3660  f206 0d4f4b8d           ms18:	!pet $0D,"ok",$8D
  3661  f20a 0d2a2a204d4f4e49...ms34:	!pet $0D,"** monitor 1.0 **",$8D
  3662  f21d 0d42524541cb       ms36:	!pet $0D,"brea",$CB
  3663                          ; -------------------------------------------------------------------------------------------------
  3664                          ; F223 Print message to screen only if output enabled
  3665  f223 2c6103             spmsg:	bit msgflg		; printing messages?
  3666  f226 100d               	bpl msg10		; no...
  3667  f228 b9caf1             msg:	lda ms1,y
  3668  f22b 08                 	php
  3669  f22c 297f               	and #$7F
  3670  f22e 20d2ff             	jsr bsout
  3671  f231 c8                 	iny
  3672  f232 28                 	plp
  3673  f233 10f3               	bpl msg
  3674  f235 18                 msg10:	clc
  3675  f236 60                 	rts
  3676                          ; -------------------------------------------------------------------------------------------------
  3677                          ; ##### ieee #####
  3678                          ; F237 Command ieee-488 device to talk
  3679  f237 0940               ntalk:	ora #tlkr		; make a talk adr
  3680  f239 d002               	bne list1		; always go to list1
  3681                          ; command ieee-488 device to listen
  3682  f23b 0920               nlistn:	ora #lstnr		; make a listen adr
  3683                          
  3684  f23d 48                 list1:	pha			; save device and talk/listen
  3685                          
  3686  f23e a93f               	lda #tddb		; set control for atn/data out
  3687  f240 8d03de             	sta tpi1+ddpa
  3688                          
  3689  f243 a9ff               	lda #$FF		; set direction for transmitt *
  3690  f245 8d00dc             	sta cia+pra		; set data   *
  3691  f248 8d02dc             	sta cia+ddra		; set data direction out   *
  3692  f24b a9fa               	lda #$FF-dc-ren		; enable transmitt
  3693  f24d 8d00de             	sta tpi1+pa
  3694  f250 a5aa               	lda c3po		; get ieee flags
  3695  f252 101b               	bpl list2		; if data in buffer
  3696                          
  3697  f254 ad00de             	lda tpi1+pa		; send eoi
  3698  f257 29df               	and #$FF-eoi
  3699  f259 8d00de             	sta tpi1+pa
  3700                          
  3701  f25c a5ab               	lda bsour		; get byte to send
  3702  f25e 20c0f2             	jsr tbyte		; send last character
  3703                          
  3704  f261 a5aa               	lda c3po		; clear byte in buffer flag
  3705  f263 297f               	and #$FF-dibf
  3706  f265 85aa               	sta c3po
  3707                          
  3708  f267 ad00de             	lda tpi1+pa		; clear eoi
  3709  f26a 0920               	ora #eoi
  3710  f26c 8d00de             	sta tpi1+pa
  3711                          
  3712  f26f ad00de             list2:	lda tpi1+pa		; assert atn
  3713  f272 29f7               	and #$FF-atn
  3714  f274 8d00de             	sta tpi1+pa
  3715                          
  3716  f277 68                 	pla			; get talk/listen address
  3717  f278 4cc0f2             	jmp tbyte
  3718                          ; -------------------------------------------------------------------------------------------------
  3719                          ; F27B Send secondary address after listen
  3720  f27b 20c0f2             nsecnd:	jsr tbyte		; send it      
  3721                          ; release attention after listen       
  3722                          scat1:
  3723  f27e ad00de             scatn:	lda tpi1+pa		; de-assert atn
  3724  f281 0908               	ora #atn
  3725  f283 8d00de             	sta tpi1+pa
  3726  f286 60                 	rts
  3727                          ; -------------------------------------------------------------------------------------------------
  3728                          ; F287 Talk second address
  3729  f287 20c0f2             ntksa:	jsr tbyte		; send secondary address
  3730                          
  3731  f28a a939               tkatn:	lda #$FF-nrfd-ndac-te-ren ; pull nrfd and ndac low
  3732  f28c 2d00de             	and tpi1+pa
  3733                          ; exit entry for untalk/unlisten
  3734  f28f 8d00de             setlns:	sta tpi1+pa
  3735  f292 a9c7               	lda #rddb		; set control lines for input
  3736  f294 8d03de             	sta tpi1+ddpa
  3737  f297 a900               	lda #$00		; set data lines for recieve
  3738  f299 8d02dc             	sta cia+ddra
  3739  f29c f0e0               	beq scatn
  3740                          ; -------------------------------------------------------------------------------------------------
  3741                          ; F29E Buffered output to ieee-488
  3742  f29e 48                 nciout:	pha			; save data
  3743  f29f a5aa               	lda c3po		; get ieee flags
  3744  f2a1 1007               	bpl ci1			; if no data in buffer
  3745  f2a3 a5ab               	lda bsour		; get data in buffer
  3746  f2a5 20c0f2             	jsr tbyte		; transmit byte
  3747  f2a8 a5aa               	lda c3po		; get ieee flags
  3748                          
  3749  f2aa 0980               ci1:	ora #dibf		; set data in buffer flag
  3750  f2ac 85aa               	sta c3po
  3751                          
  3752  f2ae 68                 	pla			; get new data
  3753  f2af 85ab               	sta bsour
  3754  f2b1 60                 	rts
  3755                          ; -------------------------------------------------------------------------------------------------
  3756                          ; F2B2 Send untalk command on ie
  3757  f2b2 a95f               nuntlk:	lda #utlkr		; untalk command
  3758  f2b4 d002               	bne unls1		; always
  3759                          
  3760                          ; send unlisten command on ieee-488
  3761  f2b6 a93f               nunlsn:	lda #ulstn		; unlisten command
  3762  f2b8 203df2             unls1:	jsr list1		; send it
  3763  f2bb a9f9               	lda #$FF-te-ren		; set for recieve all lines high
  3764  f2bd 4c8ff2             	jmp setlns		; go setup proper exit state
  3765                          ; -------------------------------------------------------------------------------------------------
  3766                          ; tbyte -- output byte onto ieee bus.
  3767                          ;   entry a = data byte to be output.
  3768                          ;   uses a register. 1 byte of stack space.
  3769                          ; F2C0
  3770  f2c0 49ff               tbyte:	eor #$FF	; compliment data
  3771  f2c2 8d00dc             	sta cia+pra
  3772                          
  3773  f2c5 ad00de             	lda tpi1+pa
  3774  f2c8 0912               	ora #dav+te		; say data not valid, te=data out
  3775  f2ca 8d00de             	sta tpi1+pa
  3776                          
  3777  f2cd 2c00de             	bit tpi1+pa		; test nrfd & ndac in high state
  3778  f2d0 5009               	bvc tby2		; either nrfd or ndac low => ok
  3779  f2d2 1007               	bpl tby2
  3780                          
  3781  f2d4 a980               tby1:	lda #nodev		; set no-device bit in status
  3782  f2d6 206efb             	jsr udst
  3783  f2d9 d030               	bne tby7		; always exit
  3784                          
  3785  f2db ad00de             tby2:	lda tpi1+pa
  3786  f2de 10fb               	bpl tby2		; if nrfd is high
  3787                          
  3788  f2e0 29ef               	and #$FF-dav
  3789  f2e2 8d00de             	sta tpi1+pa
  3790                          
  3791  f2e5 2076f3             tby3:	jsr timero		; set timeout
  3792  f2e8 9001               	bcc tby4		; c-clear means first time through
  3793  f2ea 38                 tby3t:	sec			; c-set is second time
  3794                          
  3795  f2eb 2c00de             tby4:	bit tpi1+pa
  3796  f2ee 7013               	bvs tby6		; if ndac hi
  3797  f2f0 ad0ddc             	lda cia+icr
  3798  f2f3 2902               	and #$02		; timer b posistion (cia)
  3799  f2f5 f0f4               	beq tby4		; if no timeout
  3800  f2f7 ad5e03             	lda timout		; timeout selection flag
  3801  f2fa 30e9               	bmi tby3		; no - loop
  3802  f2fc 90ec               	bcc tby3t		; wait full 64us
  3803                          
  3804  f2fe a901               tby5:	lda #toout		; set timeout on output in status
  3805  f300 206efb             	jsr udst		; update status
  3806                          
  3807  f303 ad00de             tby6:	lda tpi1+pa		; release dav
  3808  f306 0910               	ora #dav
  3809  f308 8d00de             	sta tpi1+pa
  3810                          
  3811  f30b a9ff               tby7:	lda #$FF		; release data bus
  3812  f30d 8d00dc             	sta cia+pra		; bus failure exit
  3813  f310 60                 	rts
  3814                          ; -------------------------------------------------------------------------------------------------
  3815                          ; rbyte -- input byte from ieee bus.
  3816                          ;   uses a register. 1 byte of stack space.
  3817                          ;   exit a = input data byte.
  3818                          ; F311
  3819                          nacptr:	; ********************************
  3820                          nrbyte:
  3821  f311 ad00de             	lda tpi1+pa		; set control lines
  3822  f314 29b9               	and #$FF-te-ndac-ren	; pull ndac low, te=data in
  3823  f316 0981               	ora #nrfd+dc		; say read for data
  3824  f318 8d00de             	sta tpi1+pa
  3825                          
  3826  f31b 2076f3             rby1:	jsr timero		; return c-clear for cbmii
  3827  f31e 9001               	bcc rby2		; c-clear is first time through
  3828  f320 38                 rby1t:	sec			; c-set is second time through
  3829                          
  3830  f321 ad00de             rby2:	lda tpi1+pa		; get ieee control lines
  3831  f324 2910               	and #dav
  3832  f326 f01e               	beq rby4		; if data available
  3833  f328 ad0ddc             	lda cia+icr
  3834  f32b 2902               	and #$02		; timer b (cia)
  3835  f32d f0f2               	beq rby2		; if not timed out
  3836  f32f ad5e03             	lda timout		; get timeout flag
  3837  f332 30e7               	bmi rby1		; loop
  3838  f334 90ea               	bcc rby1t		; go through twice
  3839                          
  3840  f336 a902               rby3:	lda #toin		; set timeout on input in status
  3841  f338 206efb             	jsr udst
  3842  f33b ad00de             	lda tpi1+pa
  3843  f33e 293d               	and #$FF-nrfd-ndac-te	; nrfd & ndac lo on error
  3844  f340 8d00de             	sta tpi1+pa
  3845  f343 a90d               	lda #cr			; return null input
  3846  f345 60                 	rts
  3847                          ; F346
  3848  f346 ad00de             rby4:	lda tpi1+pa		; say not read for data
  3849  f349 297f               	and #$FF-nrfd
  3850  f34b 8d00de             	sta tpi1+pa
  3851  f34e 2920               	and #eoi
  3852  f350 d005               	bne rby5		; if not eoi
  3853  f352 a940               	lda #eoist		; set eoi in status
  3854  f354 206efb             	jsr udst
  3855                          
  3856  f357 ad00dc             rby5:	lda cia+pra		; get data
  3857  f35a 49ff               	eor #$FF
  3858                          
  3859  f35c 48                 rby6:	pha			; save data
  3860  f35d ad00de             	lda tpi1+pa		; say data accepted
  3861  f360 0940               	ora #ndac
  3862  f362 8d00de             	sta tpi1+pa
  3863                          
  3864  f365 ad00de             rby7:	lda tpi1+pa		; get ieee control lines
  3865  f368 2910               	and #dav
  3866  f36a f0f9               	beq rby7		; if dav high
  3867                          
  3868  f36c ad00de             	lda tpi1+pa		; say dat not accpted
  3869  f36f 29bf               	and #$FF-ndac
  3870  f371 8d00de             	sta tpi1+pa
  3871  f374 68                 	pla			; return data in a
  3872  f375 60                 	rts
  3873                          ; -------------------------------------------------------------------------------------------------
  3874                          ; F376 Set up for timeout (6526)
  3875  f376 a980               timero:	lda #$80		; set time for at least 32us (cbmii $FF)
  3876                          
  3877  f378 8d07dc             	sta cia+tbhi
  3878  f37b a911               	lda #$11		; turn on timer continous in case of other irq's
  3879  f37d 8d0fdc             	sta cia+crb
  3880  f380 ad0ddc             	lda cia+icr		; clear interrupt
  3881  f383 18                 	clc
  3882  f384 60                 	rts
  3883                          ; -------------------------------------------------------------------------------------------------
  3884                          ; F385 ##### rs232 #####
  3885  f385 4c58f9             rs232:	jmp error9		; bad device number
  3886                          ; -------------------------------------------------------------------------------------------------
  3887                          ; opn232 - open an rs-232 channel
  3888                          ;   if sa=1 then output channel
  3889                          ;   if sa=2 then input  channel
  3890                          ;   if sa=3 then bidirectional channel
  3891                          ;   if sa>128 then ascii conversion enabled
  3892                          ;
  3893                          ;   filename consists of 0-4 bytes
  3894                          ;  byte #1- control register 6551
  3895                          ;  byte #2- command register 6551
  3896                          ;  byte #3- c/r lf delay...60ths of sec   (unimplemented)
  3897                          ;  byte #4- auto c/r insert afer xx chars (unimplemented)
  3898                          ;
  3899                          ;    actions:
  3900                          ;  1. clear  rs232 status:  rsstat
  3901                          ;  2. set 6551 contrl (ctr) register
  3902                          ;  3. set 6551 command (cdr) register
  3903                          ;       cdr bits (7-4) = filename byte 2 bits (7-4)
  3904                          ;                (3-2) = 00  (xmitter off)
  3905                          ;                (1)   = 1   (receiver off)
  3906                          ;                (0)   = 0   (dtr off)
  3907                          ;  4. do buffer alocatation, if needed
  3908                          ;---------------------------------------------
  3909                          ; F388
  3910  f388 2035f4             opn232:	jsr rst232		; reset rs232 status
  3911  f38b a000               	ldy #0
  3912                          
  3913  f38d c49d               opn020:	cpy fnlen		; filename all out ?
  3914  f38f f00b               	beq opn030		; yes...
  3915                          
  3916  f391 208dfe             	jsr fnadry
  3917  f394 997603             	sta m51ctr,y
  3918  f397 c8                 	iny
  3919  f398 c004               	cpy #4			; only four bytes in all
  3920  f39a d0f1               	bne opn020
  3921                          
  3922  f39c ad7603             opn030:	lda m51ctr		; set the register
  3923  f39f 8d03dd             	sta acia+ctr
  3924  f3a2 ad7703             	lda m51cdr		; clear up conflicts
  3925  f3a5 29f2               	and #$F2
  3926  f3a7 0902               	ora #$02
  3927  f3a9 8d02dd             	sta acia+cdr		; everything off
  3928  f3ac 18                 	clc
  3929  f3ad a5a0               	lda sa			; check for buffers needed
  3930  f3af 2902               	and #$02
  3931  f3b1 f015               	beq opn045		; no input
  3932                          
  3933  f3b3 ad7d03             	lda ridbe		; set up pointers
  3934  f3b6 8d7c03             	sta ridbs
  3935  f3b9 a5a8               	lda ribuf+2		; check for allocation
  3936  f3bb 29f0               	and #$F0		; $ff not allocated flag (see alloc error codes, too)
  3937  f3bd f009               	beq opn045		; already allocated
  3938  f3bf 2003f4             	jsr req256		; request 256 bytes for storage
  3939  f3c2 85a8               	sta ribuf+2		; save starting
  3940  f3c4 86a6               	stx ribuf
  3941  f3c6 84a7               	sty ribuf+1
  3942                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  3943  f3c8 4c41ed             opn045:	jmp patch4a3		; ***** patch 4a-3 - RS232 output *****
  3944  f3cb ea                 	nop
  3945  f3cc ea                 	nop
  3946                          } else{
  3947                          opn045:	bcc opn050
  3948                          	jmp errorx
  3949                          }
  3950                          
  3951  f3cd 60                 opn050:	rts			; c-clr already allocated
  3952                          ; -------------------------------------------------------------------------------------------------
  3953                          ; toasci - convert cbm text code to
  3954                          ;  ascii for valid ascii ranges.
  3955                          ; entry: .a - cbm text code
  3956                          ; exit : .a - ascii code
  3957                          ;----------------------------------------
  3958                          ; F3CE
  3959  f3ce c941               toasci:	cmp #'a'		; convert $41 to $5a
  3960  f3d0 9010               	bcc toa020
  3961  f3d2 c95b               	cmp #$5B
  3962  f3d4 b002               	bcs toa010
  3963  f3d6 0920               	ora #$20		; to lower case ascii
  3964  f3d8 c9c1               toa010:	cmp #$C1		; convert $c1 to $da
  3965  f3da 9006               	bcc toa020
  3966  f3dc c9db               	cmp #$DB
  3967  f3de b002               	bcs toa020
  3968  f3e0 297f               	and #$7F		; to upper case ascii
  3969  f3e2 60                 toa020:	rts
  3970                          ; -------------------------------------------------------------------------------------------------
  3971                          ; tocbm - convert ascii code to cbm
  3972                          ;  text code for valid ascii ranges.
  3973                          ; entry: .a - ascii code
  3974                          ; exit : .a - cbm text code
  3975                          ;----------------------------------------
  3976                          ; F3E3
  3977  f3e3 c941               tocbm:	cmp #'a'		; convert upper case ascii
  3978  f3e5 9010               	bcc toc020
  3979  f3e7 c95b               	cmp #$5B
  3980  f3e9 b002               	bcs toc010
  3981  f3eb 0980               	ora #$80		; to $c1 to $da
  3982  f3ed c961               toc010:	cmp #$61		; convert lower case ascii
  3983  f3ef 9006               	bcc toc020
  3984  f3f1 c97b               	cmp #$7B
  3985  f3f3 b002               	bcs toc020
  3986  f3f5 29df               	and #$FF-$20		; to $41 - $5a
  3987  f3f7 60                 toc020:	rts
  3988                          ; -------------------------------------------------------------------------------------------------
  3989                          ; xon232 - turn 6551 transmitter on, no transmit interrupts
  3990                          ;        cdr bits(3-2) = 10
  3991                          ;            bit(1)    = 1
  3992                          ;---------------------------------------------------------------
  3993                          ; F3F8
  3994  f3f8 ad02dd             xon232:	lda acia+cdr
  3995  f3fb 0909               	ora #$09
  3996  f3fd 29fb               	and #$FB
  3997  f3ff 8d02dd             	sta acia+cdr
  3998  f402 60                 	rts
  3999                          ; -------------------------------------------------------------------------------------------------
  4000                          ; F403 req256 - request 256 bytes of space
  4001                          ;  (don't care where we get it...)
  4002  f403 a200               req256:	ldx #00
  4003  f405 a001               	ldy #01		; one page = 256 bytes
  4004                          ; -------------------------------------------------------------------------------------------------
  4005                          ; alocat - alocatate space
  4006                          ;  entry:
  4007                          ; *  .a- if .a=$ff then don't care what segment
  4008                          ; *  .a- if .a=$80 then we want bottom of memory
  4009                          ; *  .a- if .a=$40 then we want top of memory
  4010                          ; *  .a- if .a=$0x then we need segment x
  4011                          ;    .x- low # of bytes needed
  4012                          ;    .y- high # of bytes needed
  4013                          ;
  4014                          ;  exit :
  4015                          ;    c-clr  no problem alocatating space
  4016                          ;     .a,.x,.y is start address of alocatated space
  4017                          ;    c-set  problem with alocatation
  4018                          ;     if .a =$ff then alocatation refused (cannot cross segment boundrys)
  4019                          ; *   if .a =$8x then bottom of memory needs to be changed
  4020                          ;     if .a =$4x then top of memory needs to be changed
  4021                          ; *   if .a =$c0 then bottom>top  !! fatal error !!
  4022                          ;     return to language
  4023                          ;
  4024                          ; *=> not implemented yet  10/30/81 rsr (only top alocatation)
  4025                          ;-----------------------------------------------------------------------
  4026                          ; F407
  4027                          alocat:
  4028  f407 8a                 tttop:	txa			; calc new hiadr
  4029  f408 38                 	sec
  4030  f409 49ff               	eor #$FF
  4031  f40b 6d5503             	adc hiadr		; sub low from end of system RAM
  4032  f40e aa                 	tax
  4033  f40f 98                 	tya
  4034  f410 49ff               	eor #$FF
  4035  f412 6d5603             	adc hiadr+1		; sub high
  4036  f415 a8                 	tay
  4037  f416 ad5703             	lda hiadr+2		; load highest system RAM bank
  4038  f419 b006               	bcs top010
  4039  f41b a9ff               refuse:	lda #$FF		; allocation refused...crossed boundry
  4040  f41d 0940               topbad:	ora #$40		; want top of memory changed
  4041  f41f 38                 	sec			; C=1 Not enough memory available 
  4042  f420 60                 	rts			; return unsuccessful
  4043                          
  4044  f421 cc5c03             top010:	cpy memsiz+1		; compare new high address with user memory high
  4045  f424 90f7               	bcc topbad		; branch if new high lower = not enough memory alocatatable
  4046  f426 d005               	bne topxit		; branch to memoryok if new high > 
  4047  f428 ec5b03             	cpx memsiz		; if higbyte equal compare low
  4048  f42b 90f0               	bcc topbad		; branch if lower = not enough memory alocatatable
  4049  f42d 8e5503             topxit:	stx hiadr		; store new end of system memory ($)
  4050  f430 8c5603             	sty hiadr+1
  4051  f433 18                 	clc
  4052  f434 60                 	rts
  4053                          ; -------------------------------------------------------------------------------------------------
  4054                          ; rst232 - reset rs232 and dcd/dsr status
  4055                          ;          note, the dcd and dsr bits of rsstat reflect whether a
  4056                          ;          dsr or dcd error occured since the last time the user
  4057                          ;          examined rsstat.
  4058                          ;          dcdsr has the dcd/dsr states prior to their last state
  4059                          ;          changes.
  4060                          ;-----------------------------------------------------------------
  4061                          ; F435
  4062  f435 08                 rst232:	php
  4063  f436 78                 	sei			; disable ints
  4064  f437 ad01dd             	lda acia+srsn
  4065  f43a 2960               	and #$60
  4066  f43c 8d7a03             	sta rsstat
  4067  f43f 8d7b03             	sta dcdsr
  4068  f442 28                 	plp
  4069  f443 60                 	rts
  4070                          ; -------------------------------------------------------------------------------------------------
  4071                          ; ##### channelio #####
  4072                          ;*****************************************
  4073                          ;* getin -- get character from channel   *
  4074                          ;*      channel is determined by dfltn.  *
  4075                          ;* if device is 0, keyboard queue is     *
  4076                          ;* examined and a character removed if   *
  4077                          ;* available.  devices 1,3-31 advance to *
  4078                          ;* basin.                                *
  4079                          ;*                                       *
  4080                          ;* exit:  .a = character                 *
  4081                          ;*        cy = 1, stop key error for cas-*
  4082                          ;*                cassetes and rs232     *
  4083                          ;*           = 0, otherwise.             *
  4084                          ;*        z  = 1, if kbd and queue empty.*
  4085                          ;*****************************************
  4086                          ; F444
  4087  f444 a5a1               ngetin:	lda dfltn		; check device
  4088  f446 d00c               	bne gn10		; not keyboard
  4089                          
  4090  f448 a5d1               	lda ndx			; queue index
  4091  f44a 05d6               	ora kyndx		; check function key que
  4092  f44c f053               	beq gn20		; nobody there...exit
  4093                          
  4094  f44e 78                 	sei
  4095  f44f 2007e0             	jsr jlp2		; go remove a character
  4096  f452 18                 	clc
  4097  f453 60                 	rts
  4098                          
  4099                          ; Check for input from device 2 = RS232
  4100  f454 c902               gn10:	cmp #2			; is it rs-232
  4101  f456 f003               	beq gn232
  4102  f458 4ccfff             	jmp basin		; no...use basin
  4103                          
  4104                          ; getin RS232
  4105  f45b 8c6503             gn232:	sty xsav		; save .y...
  4106  f45e 8e6603             	stx savx		; ..and .x
  4107  f461 ac7c03             	ldy ridbs		; get last byte address
  4108  f464 cc7d03             	cpy ridbe		; see if buffer emptyy
  4109  f467 d016               	bne gn15		; rs232 buffer not empty...
  4110                          
  4111  f469 ad02dd             	lda acia+cdr		; make sure receiver is on
  4112  f46c 29fd               	and #$FD
  4113  f46e 0901               	ora #$01		; bits(10) = 01 now
  4114  f470 8d02dd             	sta acia+cdr
  4115  f473 ad7a03             	lda rsstat		; set empty input buffer condition
  4116  f476 0910               	ora #$10
  4117  f478 8d7a03             	sta rsstat
  4118  f47b a900               	lda #0			; return a null byte
  4119  f47d f01c               	beq gnexit		; always
  4120                          
  4121                          ; Get one byte from RS232 input buffer
  4122  f47f ad7a03             gn15:	lda rsstat		; clear empty buffer status
  4123  f482 29ef               	and #$ef
  4124  f484 8d7a03             	sta rsstat
  4125  f487 a601               	ldx i6509
  4126  f489 a5a8               	lda ribuf+2
  4127  f48b 8501               	sta i6509		; point at buffer
  4128  f48d b1a6               	lda (ribuf),y		; get last char
  4129  f48f 8601               	stx i6509		; restore
  4130  f491 ee7c03             	inc ridbs		; inc to next posistion
  4131  f494 24a0               	bit sa			; check for ascii flag
  4132  f496 1003               	bpl gnexit		; not on...
  4133  f498 20e3f3             	jsr tocbm		; convert to cbm code
  4134  f49b ac6503             gnexit:	ldy xsav		; restore .y
  4135  f49e ae6603             	ldx savx
  4136  f4a1 18                 gn20:	clc			; good return
  4137  f4a2 60                 	rts
  4138                          ; -------------------------------------------------------------------------------------------------
  4139                          ;***************************************
  4140                          ;* basin-- input character from channel*
  4141                          ;*     input differs from get on device*
  4142                          ;* #0 function which is keyboard. the  *
  4143                          ;* screen editor makes ready an entire *
  4144                          ;* line which is passed char by char   *
  4145                          ;* up to the carriage return.  note,   *
  4146                          ;* rs232 uses getin to get each char.  *
  4147                          ;* other devices are:                  *
  4148                          ;*      0 -- keyboard                  *
  4149                          ;*      1 -- cassette #1               *
  4150                          ;*      2 -- rs232                     *
  4151                          ;*      3 -- screen                    *
  4152                          ;*   4-31 -- ieee   bus                *
  4153                          ;*                                     *
  4154                          ;* exit: cy=1, stop key error for cas- *
  4155                          ;*             settes and rs232.       *
  4156                          ;*       cy=0, otherwise.              *
  4157                          ;*                                     *
  4158                          ;*       all other errors must be de-  *
  4159                          ;*       tected by checking status !   *
  4160                          ;***************************************
  4161                          ; F4A3
  4162  f4a3 a5a1               nbasin:	lda dfltn		; check device
  4163  f4a5 d00b               	bne bn10		; is not keyboard...
  4164                          
  4165                          ; input from keyboard
  4166  f4a7 a5cb               	lda pntr		; save current...
  4167  f4a9 85ce               	sta lstp		; ... cursor column
  4168  f4ab a5ca               	lda tblx		; save current...
  4169  f4ad 85cf               	sta lsxp		; ... line number
  4170  f4af 4cbcf4             	jmp bn15		; blink cursor until return
  4171                          
  4172  f4b2 c903               bn10:	cmp #3			; is input from screen?
  4173  f4b4 d00b               	bne bn20		; no...
  4174                          
  4175                          !ifdef CBMPATCH4A{		; ********** cbmii revision 04a PATCH **********
  4176  f4b6 2035ed             	jsr patch4a4		; ***** patch 4a-4 - remember bootom line no *****
  4177  f4b9 ea                 	nop
  4178                          } else{
  4179                          	sta crsw		; fake a carriage return
  4180                          	lda scrt		; say we ended...
  4181                          }
  4182  f4ba 85d5               	sta indx		; ...up on this line
  4183  f4bc 200ae0             bn15:	jsr jloop5		; pick up characters
  4184  f4bf 18                 	clc
  4185  f4c0 60                 	rts
  4186                          
  4187  f4c1 b007               bn20:	bcs bn30		; devices >3
  4188  f4c3 c902               	cmp #2			; rs232?
  4189  f4c5 f010               	beq bn50
  4190                          
  4191  f4c7 2068fe             	jsr xtape		; go to tape indirect
  4192                          
  4193                          ; input from ieee bus
  4194  f4ca a59c               bn30:	lda status		; status from last
  4195  f4cc f004               	beq bn35		; was good
  4196  f4ce a90d               bn31:	lda #$D			; bad...all done
  4197  f4d0 18                 bn32:	clc			; valid data
  4198  f4d1 60                 bn33:	rts
  4199                          
  4200  f4d2 20a5ff             bn35:	jsr acptr		; good...handshake
  4201  f4d5 18                 	clc
  4202  f4d6 60                 	rts
  4203                          
  4204                          ; input from rs232
  4205  f4d7 20e4ff             bn50:	jsr getin		; get data
  4206  f4da b0f5               	bcs bn33		; error return
  4207  f4dc c900               	cmp #00			; non-null means good data always
  4208  f4de d0f0               	bne bn32		; have valid data
  4209  f4e0 ad7a03             	lda rsstat		; check for valid null byte
  4210  f4e3 2910               	and #$10
  4211  f4e5 f0e9               	beq bn32		; ok
  4212  f4e7 ad7a03             	lda rsstat		; buffer empty, check for errors in dsr, dcd
  4213  f4ea 2960               	and #dsrerr+dcderr
  4214  f4ec d0e0               	bne bn31		; have error...send c/r's
  4215  f4ee 20e1ff             	jsr stop		; check for stop key depressed
  4216  f4f1 d0e4               	bne bn50		; no, stay in loop 'til we get something
  4217  f4f3 38                 	sec			; .a=0, stop key error
  4218  f4f4 60                 	rts
  4219                          ; -------------------------------------------------------------------------------------------------
  4220                          ;***************************************
  4221                          ;* bsout -- out character to channel   *
  4222                          ;*     determined by variable dflto:   *
  4223                          ;*     0 -- invalid                    *
  4224                          ;*     1 -- cassette #1                *
  4225                          ;*     2 -- rs232                      *
  4226                          ;*     3 -- screen                     *
  4227                          ;*  4-31 -- ieee   bus                 *
  4228                          ;*                                     *
  4229                          ;* exit:  cy=1, stop key error for cas-*
  4230                          ;*              settes and rs232.      *
  4231                          ;*        cy=0, otherwise.             *
  4232                          ;*                                     *
  4233                          ;*       note, other errors must be de-*
  4234                          ;*       tected by checking status !   *
  4235                          ;***************************************
  4236                          ; F4F5
  4237  f4f5 48                 nbsout:	pha			; preserve .a
  4238  f4f6 a5a2               	lda dflto		; check device
  4239  f4f8 c903               	cmp #3			; is it the screen?
  4240  f4fa d006               	bne bo10		; no...
  4241                          
  4242                          ; print to crt
  4243  f4fc 68                 	pla			; restore data
  4244  f4fd 200de0             	jsr jprt		; print on crt
  4245  f500 18                 	clc
  4246  f501 60                 	rts
  4247                          
  4248  f502 9006               bo10:	bcc bo20		; device 1 or 2
  4249                          
  4250                          ; print to ieee   bus
  4251  f504 68                 	pla
  4252  f505 20a8ff             	jsr ciout
  4253  f508 18                 	clc
  4254  f509 60                 	rts
  4255                          
  4256                          ; print to cassette devices
  4257  f50a c902               bo20:	cmp #2			; rs232?
  4258  f50c f00a               	beq bo50
  4259                          
  4260  f50e 68                 	pla
  4261  f50f 2068fe             	jsr xtape		; go to tape indirect
  4262                          
  4263  f512 68                 rstbo:	pla			; restore .a (error exit for 232)
  4264  f513 9002               	bcc rstor1		; no error
  4265  f515 a900               	lda #00			; stop error if c-set
  4266  f517 60                 rstor1:	rts
  4267                          
  4268                          ; output to rs232
  4269  f518 8e6303             bo50:	stx t1			; put in a temp
  4270  f51b 8c6403             	sty t2
  4271                          
  4272  f51e ad7a03             bo55:	lda rsstat		; check for dsr,dcd errors
  4273  f521 2960               	and #$60
  4274  f523 d022               	bne bo90		; bad....
  4275                          
  4276  f525 68                 bo70:	pla			; restore data
  4277  f526 24a0               	bit sa			; check for cbm to ascii conversion
  4278  f528 1003               	bpl bo80		; none
  4279  f52a 20cef3             	jsr toasci		; convert cbm to ascii
  4280  f52d 8d00dd             bo80:	sta acia+drsn		; sending data
  4281  f530 48                 	pha
  4282                          
  4283  f531 ad7a03             bo60:	lda rsstat
  4284  f534 2960               	and #$60		; dcd,dsr errors?
  4285  f536 d00f               	bne bo90		; yes...
  4286  f538 ad01dd             bo64:	lda acia+srsn
  4287  f53b 2910               	and #$10		; transmit buffer empty?
  4288  f53d d008               	bne bo90		; yes, transmit done!
  4289  f53f 20e1ff             	jsr stop		; check for stop key
  4290  f542 d0ed               	bne bo60		; try again
  4291  f544 38                 bo66:	sec			; stop key/error return
  4292  f545 b0cb               	bcs rstbo		; exit....
  4293                          
  4294  f547 68                 bo90:	pla
  4295  f548 ae6303             	ldx t1          ;go restore
  4296  f54b ac6403             	ldy t2
  4297  f54e 18                 	clc
  4298  f54f 60                 	rts
  4299                          ; -------------------------------------------------------------------------------------------------
  4300                          ; ##### openchannel #####
  4301                          ;***************************************
  4302                          ;* nchkin -- open channel for input    *
  4303                          ;*                                     *
  4304                          ;* the number of the logical file to be*
  4305                          ;* opened for input is passed in .x.   *
  4306                          ;* chkin searches the logical file     *
  4307                          ;* to look up device and command info. *
  4308                          ;* errors are reported if the device   *
  4309                          ;* was not opened for input ,(e.g.     *
  4310                          ;* cassette write file), or the logical*
  4311                          ;* file has no reference in the tables.*
  4312                          ;* device 0, (keyboard), and device 3  *
  4313                          ;* (screen), require no table entries  *
  4314                          ;* and are handled separate.           *
  4315                          ;***************************************
  4316                          ; F550
  4317  f550 2045f6             nchkin:	jsr lookup		; see if file known
  4318  f553 f003               	beq jx310		; yup...
  4319                          
  4320  f555 4c46f9             	jmp error3		; no...file not open
  4321                          
  4322  f558 2057f6             jx310:	jsr jz100		; extract file info
  4323  f55b a59f               	lda fa
  4324  f55d f02e               	beq jx320		; is keyboard...done.
  4325                          
  4326                          ; could be screen, keyboard, or serial
  4327  f55f c903               	cmp #3
  4328  f561 f02a               	beq jx320		; is screen...done.
  4329  f563 b02c               	bcs jx330		; is serial...address it
  4330  f565 c902               	cmp #2			; rs232?
  4331  f567 d01e               	bne jx315		; no...
  4332                          
  4333                          ; rs232 channel
  4334  f569 a5a0               	lda sa
  4335  f56b 2902               	and #02			; check for input
  4336  f56d f01b               	beq jx316		; not input file
  4337  f56f 2d02dd             	and acia+cdr		; check if running
  4338  f572 f00f               	beq jx312		; is...done ?? (rceiver on => yes)
  4339  f574 49ff               	eor #$FF		; flip all bits
  4340  f576 2d02dd             	and acia+cdr		; turn on...
  4341  f579 0901               	ora #$01		; turn on dtr ;bits(10)=01
  4342  f57b 48                 	pha
  4343  f57c 2035f4             	jsr rst232		; reset rs232 status
  4344  f57f 68                 	pla
  4345  f580 8d02dd             	sta acia+cdr		; set command
  4346  f583 a902               jx312:	lda #2			; device
  4347  f585 d006               	bne jx320		; bra...done
  4348                          
  4349                          ; some extra checks for tape
  4350  f587 2068fe             jx315:	jsr xtape		; goto tape indirect
  4351                          
  4352  f58a 4c4ff9             jx316:	jmp error6		; not input file
  4353                          
  4354  f58d 85a1               jx320:	sta dfltn		; all input come from here
  4355                          
  4356  f58f 18                 	clc			; good exit
  4357  f590 60                 	rts
  4358                          
  4359                          ; an serial device has to be a talker
  4360  f591 aa                 jx330:	tax			; device # for dflto
  4361  f592 20b4ff             	jsr talk		; tell him to talk
  4362                          
  4363  f595 a5a0               	lda sa			; a second?
  4364  f597 1006               	bpl jx340		; yes...send it
  4365  f599 208af2             	jsr tkatn		; no...let go
  4366  f59c 4ca2f5             	jmp jx350
  4367                          
  4368  f59f 2096ff             jx340:	jsr tksa		; send second
  4369                          
  4370  f5a2 8a                 jx350:	txa
  4371  f5a3 249c               	bit status		; did he listen?
  4372  f5a5 10e6               	bpl jx320		; yes
  4373                          
  4374  f5a7 4c4cf9             	jmp error5		; device not present
  4375                          ; -------------------------------------------------------------------------------------------------
  4376                          ;***************************************
  4377                          ;* chkout -- open channel for output   *
  4378                          ;*                                     *
  4379                          ;* the number of the logical file to be*
  4380                          ;* opened for output is passed in .x.  *
  4381                          ;* chkout searches the logical file    *
  4382                          ;* to look up device and command info. *
  4383                          ;* errors are reported if the device   *
  4384                          ;* was not opened for input ,(e.g.     *
  4385                          ;* keyboard), or the logical file has  *
  4386                          ;* reference in the tables.            *
  4387                          ;* device 0, (keyboard), and device 3  *
  4388                          ;* (screen), require no table entries  *
  4389                          ;* and are handled separate.           *
  4390                          ;***************************************
  4391                          ; F5AA
  4392  f5aa 2045f6             nckout:	jsr lookup		; is file in table?
  4393  f5ad f003               	beq ck5			; yes...
  4394                          
  4395  f5af 4c46f9             	jmp error3		; no...file not open
  4396                          
  4397  f5b2 2057f6             ck5:	jsr jz100		; extract table info
  4398  f5b5 a59f               	lda fa			; is it keyboard?
  4399  f5b7 d003               	bne ck10		; no...something else.
  4400                          
  4401  f5b9 4c52f9             ck20:	jmp error7		; yes...not output file
  4402                          
  4403                          ;could be screen,serial,or tapes
  4404  f5bc c903               ck10:	cmp #3
  4405  f5be f018               	beq ck30		; is screen...done
  4406  f5c0 b01a               	bcs ck40		; is serial...address it
  4407  f5c2 c902               	cmp #2			; rs232?
  4408  f5c4 d00f               	bne ck15
  4409                          
  4410                          ; rs232 output
  4411  f5c6 a5a0               	lda sa			; check if output file
  4412  f5c8 4a                 	lsr
  4413  f5c9 90ee               	bcc ck20		; not so...
  4414  f5cb 2035f4             	jsr rst232		; reset rs232 status
  4415  f5ce 20f8f3             	jsr xon232		; make sure transmit is on
  4416  f5d1 a902               	lda #2			; device#
  4417  f5d3 d003               	bne ck30		; bra...done
  4418                          
  4419                          ; special tape channel handling
  4420  f5d5 2068fe             ck15:	jsr xtape		; goto system tape indirect
  4421                          
  4422  f5d8 85a2               ck30:	sta dflto		; all output goes here
  4423                          
  4424  f5da 18                 	clc			; good exit
  4425  f5db 60                 	rts
  4426                          
  4427  f5dc aa                 ck40:	tax			; save device for dflto
  4428  f5dd 20b1ff             	jsr listn		; tell him to listen
  4429                          
  4430  f5e0 a5a0               	lda sa			; is there a second?
  4431  f5e2 1005               	bpl ck50		; yes...
  4432                          
  4433  f5e4 207ef2             	jsr scatn		; no...release lines
  4434  f5e7 d003               	bne ck60		; branch always
  4435                          
  4436  f5e9 2093ff             ck50:	jsr secnd		; send second...
  4437                          
  4438  f5ec 8a                 ck60:	txa
  4439  f5ed 249c               	bit status		; did he listen?
  4440  f5ef 10e7               	bpl ck30		; yes...finish up
  4441                          
  4442  f5f1 4c4cf9             	jmp error5		; no...device not present
  4443                          ; -------------------------------------------------------------------------------------------------
  4444                          ; ##### close #####
  4445                          ;*************************************
  4446                          ;* nclose -- close logical file      *
  4447                          ;*                                   *
  4448                          ;* enter:                            *
  4449                          ;*     cy =1 ,transmit close to dev- *
  4450                          ;*            ice.                   *
  4451                          ;*     cy =0 ,only remove from kernal*
  4452                          ;*            tables.                *
  4453                          ;*                                   *
  4454                          ;*     the logical file number of the*
  4455                          ;* file to be closed is passed in .a.*
  4456                          ;* keyboard, screen, and files not   *
  4457                          ;* open pass straight through. tape  *
  4458                          ;* files open for write are closed by*
  4459                          ;* dumping the last buffer and       *
  4460                          ;* conditionally writing an end of   *
  4461                          ;* tape block.serial files are closed*
  4462                          ;* by sending a close file command if*
  4463                          ;* a secondary address was specified *
  4464                          ;* in its open command.              *
  4465                          ;*************************************
  4466                          ; F5F4
  4467  f5f4 08                 nclose:	php			; save cy flag
  4468  f5f5 204af6             	jsr jltlk		; look file up
  4469  f5f8 f003               	beq jx110		; was open...continue
  4470  f5fa 28                 	plp
  4471  f5fb 18                 	clc			; was never open...no error
  4472  f5fc 60                 	rts
  4473                          
  4474  f5fd 2057f6             jx110:	jsr jz100		; extract table data
  4475  f600 28                 	plp			; retrieve cy flag
  4476  f601 8a                 	txa			; save table index
  4477  f602 48                 	pha
  4478  f603 901f               	bcc jx150		; close out table entries only
  4479                          
  4480  f605 a59f               	lda fa			; check device number
  4481  f607 f01b               	beq jx150		; is keyboard...done
  4482  f609 c903               	cmp #3
  4483  f60b f017               	beq jx150		; is screen...done
  4484  f60d b012               	bcs jx120		; is ieee...process
  4485  f60f c902               	cmp #2			; rs232?
  4486  f611 d007               	bne jx115		; no...
  4487                          
  4488                          ; close rs-232 file
  4489  f613 a900               cls232:	lda #0
  4490  f615 8d02dd             	sta acia+cdr		; do a soft reset
  4491  f618 f00a               	beq jx150		; jmp...remove file
  4492                          
  4493                          ; close cassette file
  4494  f61a 68                 jx115:	pla			; cassette now closes the channel...
  4495  f61b 2025f6             	jsr jx151		; before transmitting out the final data
  4496  f61e 2068fe             	jsr xtape		; goto tape indirect
  4497                          
  4498                          ; close an ieee file
  4499  f621 20c6f8             jx120:	jsr clsei
  4500                          
  4501                          ; entry to remove a give logical file from table of logical, primary, and secondary addresses
  4502  f624 68                 jx150:	pla			; get table index off stack
  4503  f625 aa                 jx151:	tax			; entry for cassette special
  4504  f626 ce6003             	dec ldtnd
  4505  f629 ec6003             	cpx ldtnd		; is deleted file at end?
  4506  f62c f015               	beq jx160		; yes...done
  4507                          
  4508                          ; delete entry in middle by moving last entry to that position.
  4509  f62e ac6003             	ldy ldtnd
  4510  f631 b93403             	lda lat,y
  4511  f634 9d3403             	sta lat,x
  4512  f637 b93e03             	lda fat,y
  4513  f63a 9d3e03             	sta fat,x
  4514  f63d b94803             	lda sat,y
  4515  f640 9d4803             	sta sat,x
  4516  f643 18                 jx160:	clc
  4517  f644 60                 jx170:	rts			; close exit
  4518                          
  4519                          ; lookup tablized logical file data
  4520  f645 a900               lookup:	lda #0
  4521  f647 859c               	sta status
  4522  f649 8a                 	txa
  4523  f64a ae6003             jltlk:	ldx ldtnd
  4524  f64d ca                 jx600:	dex
  4525  f64e 302d               	bmi lkups4
  4526  f650 dd3403             	cmp lat,x
  4527  f653 d0f8               	bne jx600
  4528  f655 18                 	clc
  4529  f656 60                 	rts
  4530                          
  4531                          ; routine to fetch table entries
  4532  f657 bd3403             jz100:	lda lat,x
  4533  f65a 859e               	sta la
  4534  f65c bd3e03             	lda fat,x
  4535  f65f 859f               	sta fa
  4536  f661 bd4803             	lda sat,x
  4537  f664 85a0               	sta sa
  4538  f666 60                 jz101:	rts
  4539                          
  4540                          ; sa is passed in .y
  4541                          ; routine looks for match in tables
  4542                          ; carry set if not present
  4543                          ; carry clear:
  4544                          ; .a=la,.x=fa,.y=sa
  4545  f667 98                 lkupsa:	tya
  4546  f668 ae6003             	ldx ldtnd
  4547  f66b ca                 lkups2:	dex
  4548  f66c 300f               	bmi lkups4
  4549  f66e dd4803             	cmp sat,x
  4550  f671 d0f8               	bne lkups2
  4551  f673 18                 	clc
  4552  f674 2057f6             lkups3:	jsr jz100		; get table data
  4553  f677 a8                 	tay
  4554  f678 a59e               	lda la
  4555  f67a a69f               	ldx fa
  4556  f67c 60                 	rts
  4557  f67d 38                 lkups4:	sec
  4558  f67e 60                 	rts			; not found exit
  4559                          
  4560                          ; la is passed in .a
  4561                          ; routine looks for match in tables
  4562                          ; carry set if not found
  4563                          ; carry clear:
  4564                          ; .a=la,.x=fa,.y=sa
  4565  f67f aa                 lkupla:	tax
  4566  f680 2045f6             	jsr lookup
  4567  f683 90ef               	bcc lkups3
  4568  f685 60                 	rts
  4569                          ; -------------------------------------------------------------------------------------------------
  4570                          ; ##### clall #####
  4571                          ;******************************************
  4572                          ;* nclall -- close all logical files      *
  4573                          ;*      deletes all table entries and     *
  4574                          ;* restores default i/o channels          *
  4575                          ;* and clears ieee port devices           *
  4576                          ;******************************************
  4577                          ;------------------------------------------
  4578                          ; new ncall
  4579                          ;  closes all files untill done or an
  4580                          ;  error occurs.
  4581                          ;  entry:
  4582                          ;    c-clr => close all files
  4583                          ;    c-set => .a = fa (device to be closed)
  4584                          ;------------------------------------------
  4585                          ; F686 Close all logical files
  4586  f686 6e6503             nclall:	ror xsav		; save carry
  4587  f689 8d6603             	sta savx		; save .a
  4588  f68c ae6003             ncl010:	ldx ldtnd		; scan index
  4589  f68f ca                 ncl020:	dex
  4590                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  4591  f690 301b               	bmi nclrch		; all done...clear channels (dclose patch 5/31/83)
  4592                          } else{
  4593                          	bmi ncl040		; all done
  4594                          }
  4595  f692 2c6503             	bit xsav		; check for fixed fa
  4596  f695 1008               	bpl ncl030		; none...
  4597  f697 ad6603             	lda savx
  4598  f69a dd3e03             	cmp fat,x
  4599  f69d d0f0               	bne ncl020		; no match...
  4600  f69f bd3403             ncl030:	lda lat,x		; close this la
  4601  f6a2 38                 	sec			; c-set required to close
  4602  f6a3 20c3ff             	jsr close
  4603  f6a6 90e4               	bcc ncl010
  4604                          
  4605  f6a8 a900               ncl040:	lda #0			; original entry for nclall
  4606  f6aa 8d6003             	sta ldtnd		; forget all files
  4607                          ; -------------------------------------------------------------------------------------------------
  4608                          ;********************************************
  4609                          ;* nclrch -- clear channels                 *
  4610                          ;*   unlisten or untalk ieee devices, but   *
  4611                          ;* leave others alone.  default channels    *
  4612                          ;* are restored.                            *
  4613                          ;********************************************
  4614                          ; F6AD
  4615  f6ad a203               nclrch:	ldx #3
  4616  f6af e4a2               	cpx dflto		; is output channel ieee?
  4617  f6b1 b003               	bcs jx750		; no...
  4618                          
  4619  f6b3 20aeff             	jsr unlsn		; yes...unlisten it
  4620                          
  4621  f6b6 e4a1               jx750:	cpx dfltn		; is input channel ieee?
  4622  f6b8 b003               	bcs clall2		; no...
  4623                          
  4624  f6ba 20abff             	jsr untlk		; yes...untalk it
  4625                          
  4626                          ; restore default values
  4627  f6bd a203               clall2:	ldx #3
  4628  f6bf 86a2               	stx dflto		; output chan=3=screen
  4629  f6c1 a900               	lda #0
  4630  f6c3 85a1               	sta dfltn		; input chan=0=keyboard
  4631  f6c5 60                 	rts
  4632                          ; -------------------------------------------------------------------------------------------------
  4633                          ; ##### open #####
  4634                          ;***********************************
  4635                          ;*                                 *
  4636                          ;* open function                   *
  4637                          ;*                                 *
  4638                          ;* enter: cy=1, transmit command to*
  4639                          ;*              device.            *
  4640                          ;*        cy=0, perform open opera-*
  4641                          ;*              tion.              *
  4642                          ;*                                 *
  4643                          ;* la, fa, sa must be set up prior *
  4644                          ;* to the call to this routine, as *
  4645                          ;* well as the file name descript- *
  4646                          ;* tor.                            *
  4647                          ;*                                 *
  4648                          ;***********************************
  4649                          ; F6C6
  4650  f6c6 9003               nopen:	bcc     op000		; do open
  4651  f6c8 4c41f7             	jmp     tranr		; do transmit
  4652                          
  4653                          ;***********************************
  4654                          ;*                                 *
  4655                          ;* create an entry in the logical  *
  4656                          ;* files tables consisting of      *
  4657                          ;* logical file number--la, device *
  4658                          ;* number--fa, and secondary cmd-- *
  4659                          ;* sa.                             *
  4660                          ;*                                 *
  4661                          ;* a file name descriptor, fnadr & *
  4662                          ;* fnlen, is passed to this routine*
  4663                          ;*                                 *
  4664                          ;***********************************
  4665                          ; F6CB
  4666  f6cb a69e               op000:	ldx la			; check file #
  4667                          
  4668                          ; bne op98 ;is not the keyboard
  4669                          ; jmp error6 ;not input file...
  4670                          
  4671  f6cd 2045f6             op98:	jsr lookup		; see if in table
  4672  f6d0 d003               	bne op100		; not found...o.k.
  4673                          
  4674  f6d2 4c43f9             	jmp error2		; file open
  4675                          
  4676  f6d5 ae6003             op100:	ldx ldtnd		; logical device table end
  4677  f6d8 e00a               	cpx #10			; maximum # of open files
  4678  f6da 9003               	bcc op110		; less than 10...o.k.
  4679                          
  4680  f6dc 4c40f9             	jmp error1		; too many files
  4681                          
  4682  f6df ee6003             op110:	inc ldtnd		; new file
  4683  f6e2 a59e               	lda la
  4684  f6e4 9d3403             	sta lat,x		; store logical file #
  4685  f6e7 a5a0               	lda sa
  4686  f6e9 0960               	ora #$60		; make sa an ieee command
  4687  f6eb 85a0               	sta sa
  4688  f6ed 9d4803             	sta sat,x		; store command #
  4689  f6f0 a59f               	lda fa
  4690  f6f2 9d3e03             	sta fat,x		; store device #
  4691                          
  4692                          ; perform device specific open tasks
  4693  f6f5 f015               	beq op175		; is keyboard...done.
  4694  f6f7 c903               	cmp #3
  4695  f6f9 f011               	beq op175		; is screen...done.
  4696  f6fb 9005               	bcc op150		; are cassettes 1 & 2
  4697                          
  4698  f6fd 200ef7             	jsr openi		; is on ieee...open it
  4699  f700 900a               	bcc op175		; branch always...done
  4700                          
  4701                          ; perform tape open stuff
  4702  f702 c902               op150:	cmp #2
  4703  f704 d003               	bne op152
  4704                          
  4705  f706 4c88f3             	jmp opn232
  4706                          
  4707  f709 2068fe             op152:	jsr xtape		; goto tape device indirect
  4708                          
  4709  f70c 18                 op175:	clc			; flag good open
  4710  f70d 60                 op180:	rts			; exit in peace
  4711                          
  4712  f70e a5a0               openi:	lda sa
  4713  f710 302d               	bmi op50		; no sa...done
  4714                          
  4715  f712 a49d               	ldy fnlen
  4716  f714 f029               	beq op50		; no file name...done
  4717                          
  4718  f716 a59f               	lda fa
  4719  f718 20b1ff             	jsr listn		; device la to listen
  4720                          
  4721  f71b a5a0               	lda sa
  4722  f71d 09f0               	ora #$f0
  4723  f71f 2093ff             openib:	jsr secnd
  4724                          
  4725  f722 a59c               	lda status		; anybody home?
  4726  f724 1005               	bpl op35		; yes...continue
  4727                          
  4728                          ; this routine is called by other kernal routines which are called directly by os.
  4729                          ; kill return address to return to os.
  4730  f726 68                 	pla
  4731  f727 68                 	pla
  4732  f728 4c4cf9             	jmp error5		; device not present
  4733                          
  4734  f72b a59d               op35:	lda fnlen
  4735  f72d f00d               	beq op45		; no name...done sequence
  4736                          
  4737                          ; send file name over ieee
  4738  f72f a000               	ldy #0
  4739  f731 208dfe             op40:	jsr fnadry
  4740  f734 20a8ff             	jsr ciout
  4741  f737 c8                 	iny
  4742  f738 c49d               	cpy fnlen
  4743  f73a d0f5               	bne op40
  4744                          
  4745  f73c 20aeff             op45:	jsr unlsn
  4746                          
  4747  f73f 18                 op50:	clc			; no  error
  4748  f740 60                 	rts
  4749                          ; -------------------------------------------------------------------------------------------------
  4750                          ;*****************************************
  4751                          ;*  transmit command to device           *
  4752                          ;*                                       *
  4753                          ;*   fnlen,fnadr must be set up already  *
  4754                          ;*   to contain the command string.      *
  4755                          ;*   fa must be set for the device.      *
  4756                          ;*****************************************
  4757                          ; F741
  4758  f741 a59f               tranr:  lda fa
  4759  f743 20b1ff             	jsr listn
  4760  f746 a96f               	lda #$6F
  4761  f748 85a0               	sta sa
  4762  f74a 4c1ff7             	jmp openib
  4763                          ; -------------------------------------------------------------------------------------------------
  4764                          ; ##### load #####
  4765                          ;**************************************
  4766                          ;* load ram function     10/30/81     *
  4767                          ;*                                    *
  4768                          ;*  loads from cassette 1 or 2, or    *
  4769                          ;*  ieee bus devices >=4 to 31 as     *
  4770                          ;*  determined by contents of         *
  4771                          ;*  variable fa.                      *
  4772                          ;* entry:                             *
  4773                          ;*   .a(bit 7)=0 performs load        *
  4774                          ;*   .a(bit 7)=1 performs verify      *
  4775                          ;*   .a(bits 0123)=start segment      *
  4776                          ;*   .x=start address low             *
  4777                          ;*   .y=start address high            *
  4778                          ;*   if .x=$ff & .y=$ff => fixed load *
  4779                          ;* exit:                              *
  4780                          ;*   .a(bits 0123)=end segment        *
  4781                          ;*   .x=end address low               *
  4782                          ;*   .y=end address high              *
  4783                          ;*                                    *
  4784                          ;**************************************
  4785                          ; F74D
  4786  f74d 8e6f03             nload:	stx relsal		; save alt address
  4787  f750 8c7003             	sty relsah
  4788  f753 8d5f03             	sta verck		; set verify flag (n)
  4789  f756 8d7103             	sta relsas		; save start address
  4790  f759 a900               	lda #0			; clear status
  4791  f75b 859c               	sta status
  4792                          
  4793  f75d a59f               	lda fa			; check device number
  4794  f75f d003               	bne ld20
  4795                          
  4796  f761 4c58f9             ld10:	jmp error9		; bad device #-keyboard
  4797                          
  4798  f764 c903               ld20:	cmp #3
  4799  f766 f0f9               	beq ld10		; disallow screen load
  4800  f768 b003               	bcs *+5
  4801  f76a 4c17f8             	jmp ld100		; handle tapes different
  4802                          
  4803                          ; load from cbm ieee device
  4804  f76d a960               	lda #$60		; special load command
  4805  f76f 85a0               	sta sa
  4806                          
  4807  f771 a49d               	ldy fnlen		; must have file name
  4808  f773 d003               	bne ld25		; yes...ok
  4809                          
  4810  f775 4c55f9             	jmp error8		; missing file name
  4811                          
  4812  f778 2022f8             ld25:	jsr luking		; tell user looking
  4813  f77b 200ef7             	jsr openi		; open the file
  4814                          
  4815  f77e a59f               	lda fa
  4816  f780 20b4ff             	jsr talk		; establish the channel
  4817  f783 a5a0               	lda sa
  4818  f785 2096ff             	jsr tksa		; tell it to load
  4819                          
  4820  f788 20a5ff             	jsr acptr		; get first byte
  4821  f78b 8596               	sta eal
  4822  f78d 8599               	sta stal
  4823                          
  4824  f78f a59c               	lda status		; test status for error
  4825  f791 4a                 	lsr
  4826  f792 4a                 	lsr
  4827  f793 9003               	bcc *+5			; file  found...
  4828                          
  4829  f795 4c49f9             	jmp error4		; file not found error
  4830                          
  4831  f798 20a5ff             	jsr acptr
  4832  f79b 8597               	sta eah
  4833  f79d 859a               	sta stah
  4834                          
  4835  f79f 2047f8             	jsr loding		; tell user loading
  4836                          
  4837                          ; test for fixed or moveable load
  4838  f7a2 ad7103             	lda relsas		; no segment byte in storage ***
  4839  f7a5 8598               	sta eas
  4840  f7a7 859b               	sta stas
  4841  f7a9 ad6f03             	lda relsal
  4842  f7ac 2d7003             	and relsah
  4843  f7af c9ff               	cmp #$FF
  4844  f7b1 f00e               	beq ld40		; fixed load
  4845                          
  4846  f7b3 ad6f03             	lda relsal
  4847  f7b6 8596               	sta eal
  4848  f7b8 8599               	sta stal
  4849  f7ba ad7003             	lda relsah
  4850  f7bd 8597               	sta eah
  4851  f7bf 859a               	sta stah
  4852                          ;
  4853  f7c1 a9fd               ld40:	lda #$FD		; mask off timeout
  4854  f7c3 259c               	and status
  4855  f7c5 859c               	sta status
  4856                          
  4857  f7c7 20e1ff             	jsr stop		; stop key?
  4858  f7ca d003               	bne ld45		; no...
  4859                          
  4860  f7cc 4cbaf8             	jmp break		; stop key pressed
  4861                          
  4862  f7cf 20a5ff             ld45:	jsr acptr		; get byte off ieee
  4863  f7d2 aa                 	tax
  4864  f7d3 a59c               	lda status		; was there a timeout?
  4865  f7d5 4a                 	lsr
  4866  f7d6 4a                 	lsr
  4867  f7d7 b0e8               	bcs ld40		; yes...try again
  4868  f7d9 8a                 	txa
  4869                          ; change indirect pages
  4870  f7da a601               	ldx i6509
  4871  f7dc a498               	ldy eas
  4872  f7de 8401               	sty i6509
  4873  f7e0 a000               	ldy #0
  4874  f7e2 2c5f03             	bit verck		; performing verify?
  4875  f7e5 100e               	bpl ld50		; no...load
  4876  f7e7 8593               	sta sal			; use as a temp
  4877  f7e9 b196               	lda (eal),y
  4878  f7eb c593               	cmp sal
  4879  f7ed f008               	beq ld60		; okay
  4880  f7ef a910               	lda #sperr		; no good...verify error
  4881  f7f1 206efb             	jsr udst		; update status
  4882  f7f4 ad                 	!byte $AD		; skip next store
  4883                          
  4884  f7f5 9196               ld50:	sta (eal),y
  4885  f7f7 8601               ld60:	stx i6509		; restore indirect
  4886  f7f9 e696               	inc eal			; increment store addr
  4887  f7fb d00a               	bne ld64
  4888  f7fd e697               	inc eah
  4889  f7ff d006               	bne ld64
  4890  f801 e698               	inc eas
  4891  f803 a902               	lda #2			; skip $0000 $0001
  4892  f805 8596               	sta eal
  4893  f807 249c               ld64:	bit status		; eoi?
  4894  f809 50b6               	bvc ld40		; no...continue load
  4895                          
  4896  f80b 20abff             	jsr untlk		; close channel
  4897  f80e 20c6f8             	jsr clsei		; close the file
  4898  f811 4c1af8             	jmp ld180		; exit ieee load
  4899                          
  4900  f814 4c49f9             ld90:	jmp error4		; file not found
  4901                          
  4902                          ; load from tape
  4903  f817 2068fe             ld100:	jsr xtape		; goto tape indirect
  4904                          
  4905  f81a 18                 ld180:	clc			; good exit
  4906                          
  4907                          ; set up end load address
  4908  f81b a598               	lda eas
  4909  f81d a696               	ldx eal
  4910  f81f a497               	ldy eah
  4911                          
  4912  f821 60                 ld190:	rts
  4913                          
  4914                          ; subroutine to print to console: searching [for name]
  4915  f822 2c6103             luking:	bit msgflg		; supposed to print?
  4916  f825 101f               	bpl ld115
  4917  f827 a00c               	ldy #ms5-ms1		; "searching"
  4918  f829 2023f2             	jsr spmsg
  4919  f82c a59d               	lda fnlen
  4920  f82e f016               	beq ld115
  4921  f830 a017               	ldy #ms6-ms1		; "for"
  4922  f832 2023f2             	jsr spmsg
  4923                          
  4924                          ; subroutine to output file name
  4925  f835 a49d               outfn:	ldy fnlen		; is there a name?
  4926  f837 f00d               	beq ld115		; no...done
  4927  f839 a000               	ldy #0
  4928  f83b 208dfe             ld110:	jsr fnadry
  4929  f83e 20d2ff             	jsr bsout
  4930  f841 c8                 	iny
  4931  f842 c49d               	cpy fnlen
  4932  f844 d0f5               	bne ld110
  4933                          
  4934  f846 60                 ld115:	rts
  4935                          
  4936                          ; subroutine to print: loading/verifing
  4937  f847 a01b               loding:	ldy #ms10-ms1		; assume 'loading'
  4938  f849 ad5f03             	lda verck		; check flag
  4939  f84c 1002               	bpl ld410		; are doing load
  4940  f84e a02b               	ldy #ms21-ms1		; are 'verifying'
  4941  f850 4c23f2             ld410:	jmp spmsg
  4942                          
  4943                          ; rsr  fix segmentation 10/15/81
  4944                          ; rsr  6509 changes  10/15/81
  4945                          ; -------------------------------------------------------------------------------------------------
  4946                          ; ##### save #####
  4947                          ;***************************************
  4948                          ;* nsave              10/30/81         *
  4949                          ;*                                     *
  4950                          ;* saves to cassette 1 or 2, or        *
  4951                          ;* ieee devices 4>=n>=31 as selected   *
  4952                          ;* by variable fa.                     *
  4953                          ;*                                     *
  4954                          ;* .x => zpage address of start vector *
  4955                          ;* .y => zpage address of end vector   *
  4956                          ;***************************************
  4957                          ; F853
  4958  f853 b500               nsave:	lda 0,x			; get start vector
  4959  f855 8599               	sta stal
  4960  f857 b501               	lda 1,x
  4961  f859 859a               	sta stah
  4962  f85b b502               	lda 2,x
  4963  f85d 859b               	sta stas
  4964  f85f 98                 	tya
  4965  f860 aa                 	tax
  4966  f861 b500               	lda 0,x			; get end vector
  4967  f863 8596               	sta eal
  4968  f865 b501               	lda 1,x
  4969  f867 8597               	sta eah
  4970  f869 b502               	lda 2,x
  4971  f86b 8598               	sta eas
  4972                          
  4973  f86d a59f               	lda fa
  4974  f86f d003               	bne sv20
  4975                          
  4976  f871 4c58f9             sv10:	jmp error9		; bad device #
  4977                          
  4978  f874 c903               sv20:	cmp #3
  4979  f876 f0f9               	beq sv10
  4980  f878 9063               	bcc sv100
  4981  f87a a961               	lda #$61
  4982  f87c 85a0               	sta sa
  4983  f87e a49d               	ldy fnlen
  4984  f880 d003               	bne sv25
  4985                          
  4986  f882 4c55f9             	jmp error8		; missing file name
  4987                          
  4988  f885 200ef7             sv25:	jsr openi
  4989  f888 20e0f8             	jsr saving
  4990  f88b a59f               	lda fa
  4991  f88d 20b1ff             	jsr listn
  4992  f890 a5a0               	lda sa
  4993  f892 2093ff             	jsr secnd
  4994  f895 a601               	ldx i6509		; indirects switched by rd300
  4995  f897 2070fe             	jsr rd300
  4996  f89a a593               	lda sal
  4997  f89c 20a8ff             	jsr ciout
  4998  f89f a594               	lda sah
  4999  f8a1 20a8ff             	jsr ciout
  5000                          
  5001  f8a4 a000               	ldy #0
  5002  f8a6 207ffe             sv30:	jsr cmpste		; compare start to end
  5003  f8a9 b016               	bcs sv50		; have reached end
  5004  f8ab b193               	lda (sal),y
  5005  f8ad 20a8ff             	jsr ciout
  5006  f8b0 203fff             	jsr incsal
  5007  f8b3 20e1ff             	jsr stop
  5008  f8b6 d0ee               	bne sv30
  5009                          
  5010  f8b8 8601               	stx i6509		; restore indirects
  5011  f8ba 20c6f8             break:	jsr clsei
  5012  f8bd a900               	lda #0
  5013  f8bf 38                 	sec
  5014  f8c0 60                 	rts
  5015                          
  5016  f8c1 8601               sv50:	stx i6509		; restore indirects
  5017  f8c3 20aeff             	jsr unlsn
  5018                          
  5019  f8c6 24a0               clsei:	bit sa
  5020  f8c8 3011               	bmi clsei2
  5021  f8ca a59f               	lda fa
  5022  f8cc 20b1ff             	jsr listn
  5023  f8cf a5a0               	lda sa
  5024  f8d1 29ef               	and #$EF
  5025  f8d3 09e0               	ora #$E0
  5026  f8d5 2093ff             	jsr secnd
  5027  f8d8 20aeff             	jsr unlsn
  5028                          
  5029                          clsei2:
  5030  f8db 18                 sv110:	clc
  5031  f8dc 60                 sv115:	rts
  5032                          
  5033  f8dd 2068fe             sv100:	jsr xtape		; goto tape device
  5034                          
  5035                          ; subroutine to output: 'saving <file name>'
  5036  f8e0 ad6103             saving:	lda msgflg
  5037  f8e3 10f7               	bpl sv115		; no print
  5038                          
  5039  f8e5 a023               	ldy #ms11-ms1		; 'saving'
  5040  f8e7 2023f2             	jsr spmsg
  5041  f8ea 4c35f8             	jmp outfn		; <file name>
  5042                          ; -------------------------------------------------------------------------------------------------
  5043                          ; ##### time #####
  5044                          ;----------------------------------------
  5045                          ; time and alarm routines for 6526
  5046                          ;      rsr 11/12/81
  5047                          ;
  5048                          ; rdtim - read the time
  5049                          ;  .y = (bit7=pm,bit6/5=t8/t4,bits4-0 hrs)
  5050                          ;  .x = (bit7=t2,bits6-0 minutes)
  5051                          ;  .a = (bit7=t1,bits6-0 seconds)
  5052                          ;----------------------------------------
  5053                          ; F8ED
  5054  f8ed ad08dc             rdtim:	lda cia+tod10
  5055  f8f0 48                 	pha			; save for later
  5056  f8f1 48                 	pha
  5057  f8f2 0a                 	asl			; shift to add to todhrs
  5058  f8f3 0a                 	asl
  5059  f8f4 0a                 	asl
  5060  f8f5 2960               	and #$60		; bit posistions 5,6
  5061  f8f7 0d0bdc             	ora cia+todhr
  5062  f8fa a8                 	tay			; return in .y
  5063  f8fb 68                 	pla
  5064  f8fc 6a                 	ror			; shift to add to todsec
  5065  f8fd 6a                 	ror
  5066  f8fe 2980               	and #$80
  5067  f900 0d09dc             	ora cia+todsec
  5068  f903 8593               	sta sal			; save for later
  5069  f905 6a                 	ror			; shit to add to todmin
  5070  f906 2980               	and #$80
  5071  f908 0d0adc             	ora cia+todmin
  5072  f90b aa                 	tax			; return in .x
  5073  f90c 68                 	pla
  5074  f90d cd08dc             	cmp cia+tod10		; watch out for rollover
  5075  f910 d0db               	bne rdtim		; ...it changed do again...
  5076  f912 a593               	lda sal
  5077  f914 60                 	rts
  5078                          ; -------------------------------------------------------------------------------------------------
  5079                          ; settim - set tod and alarm
  5080                          ;  c-set => set alarm
  5081                          ;  c-clr => set tod
  5082                          ;  registers same as rdtim
  5083                          ;----------------------------------------
  5084                          ; F915
  5085  f915 48                 settim:	pha			; save for later
  5086  f916 48                 	pha
  5087  f917 6a                 	ror			; set bit 8
  5088  f918 2980               	and #$80
  5089  f91a 0d0fdc             	ora cia+crb
  5090  f91d 8d0fdc             	sta cia+crb
  5091  f920 98                 	tya			; get bits from todhrs
  5092  f921 2a                 	rol
  5093  f922 2a                 	rol
  5094  f923 2693               	rol sal			; bit t8 (don't need to clear sal)
  5095  f925 2a                 	rol
  5096  f926 2693               	rol sal			; bit t4
  5097  f928 8a                 	txa			; get bit from todmin
  5098  f929 2a                 	rol
  5099  f92a 2693               	rol sal			; bit t2
  5100  f92c 68                 	pla			; get bit from todsec
  5101  f92d 2a                 	rol
  5102  f92e 2693               	rol sal			; bit t1
  5103  f930 8c0bdc             	sty cia+todhr
  5104  f933 8e0adc             	stx cia+todmin
  5105  f936 68                 	pla
  5106  f937 8d09dc             	sta cia+todsec
  5107  f93a a593               	lda sal
  5108  f93c 8d08dc             	sta cia+tod10
  5109  f93f 60                 	rts
  5110                          ; -------------------------------------------------------------------------------------------------
  5111                          ; ##### errorhandler #####
  5112                          ;************************************
  5113                          ;* error handler                    *
  5114                          ;*  restores i/o channels to default*
  5115                          ;*  prints kernal error message if  *
  5116                          ;*  bit 6 of msgflg set.  returns   *
  5117                          ;*  with error # in .a and carry.   *
  5118                          ;************************************
  5119                          ; F940 
  5120  f940 a901               error1:	lda #1			; too many files
  5121  f942 2c                 	!byte $2c
  5122  f943 a902               error2:	lda #2			; file open
  5123  f945 2c                 	!byte $2c
  5124  f946 a903               error3:	lda #3			; file not open
  5125  f948 2c                 	!byte $2c
  5126  f949 a904               error4:	lda #4			; file not found
  5127  f94b 2c                 	!byte $2c
  5128  f94c a905               error5:	lda #5			; device not present
  5129  f94e 2c                 	!byte $2c
  5130  f94f a906               error6:	lda #6			; not input file
  5131  f951 2c                 	!byte $2c
  5132  f952 a907               error7:	lda #7			; not output file
  5133  f954 2c                 	!byte $2c
  5134  f955 a908               error8:	lda #8			; missing file name
  5135  f957 2c                 	!byte $2c
  5136  f958 a909               error9:	lda #9			; bad device #
  5137                          
  5138  f95a 48                 errorx:	pha			; error number on stack
  5139  f95b 20ccff             	jsr clrch		; restore i/o channels
  5140                          
  5141  f95e a000               	ldy #ms1-ms1
  5142  f960 2c6103             	bit msgflg		; are we printing error?
  5143  f963 500a               	bvc erexit		; no...
  5144                          
  5145  f965 2028f2             	jsr msg			; print "cbm i/o error #"
  5146  f968 68                 	pla
  5147  f969 48                 	pha
  5148  f96a 0930               	ora #$30		; make error # ascii
  5149  f96c 20d2ff             	jsr bsout		; print it
  5150                          
  5151  f96f 68                 erexit:	pla
  5152  f970 38                 	sec
  5153  f971 60                 	rts
  5154                          ; -------------------------------------------------------------------------------------------------
  5155                          ;***************************************
  5156                          ;* stop -- check stop key flag and     *
  5157                          ;* return z flag set if flag true.     *
  5158                          ;* also closes active channels and     *
  5159                          ;* flushes keyboard queue.             *
  5160                          ;* also returns key downs from last    *
  5161                          ;* keyboard row in .a.                 *
  5162                          ;***************************************
  5163                          ; F972 Check the stop key
  5164  f972 a5a9               nstop:	lda stkey		; value of last row
  5165  f974 2901               	and #$01		; check stop key position
  5166  f976 d007               	bne stop2		; not down
  5167  f978 08                 	php
  5168  f979 20ccff             	jsr clrch		; clear channels
  5169  f97c 85d1               	sta ndx			; flush queue
  5170  f97e 28                 	plp
  5171  f97f 60                 stop2:	rts
  5172                          ; -------------------------------------------------------------------------------------------------
  5173                          ; udtim - update the stop key location
  5174                          ;   expects keyboard outputs set to
  5175                          ;   default value. bit 0 of stkey =0
  5176                          ;   for stop key down.
  5177                          ;---------------------------------------
  5178                          ; F980 
  5179  f980 ad02df             udtim:	lda tpi2+pc		; check keyboard
  5180  f983 4a                 	lsr
  5181  f984 b012               	bcs udexit		; no  stop key
  5182  f986 a9fe               	lda #$FE		; check for shift
  5183  f988 8d01df             	sta tpi2+pb
  5184  f98b a910               	lda #$10
  5185  f98d 2d02df             	and tpi2+pc
  5186  f990 d001               	bne udttt		; no shift key
  5187  f992 38                 	sec			; shift key mark
  5188  f993 a9ff               udttt:	lda #$FF		; clear
  5189  f995 8d01df             	sta tpi2+pb
  5190  f998 2a                 udexit:	rol			; move bit 0 back
  5191  f999 85a9               	sta stkey
  5192  f99b 60                 	rts
  5193                          ; -------------------------------------------------------------------------------------------------
  5194                          ; ##### init #####
  5195                          ;------------------------------------------------
  5196                          ; start - system reset routine
  5197                          ;  kernal checks on 4k boundries from $1000-$8000
  5198                          ;    first occurance has priority.
  5199                          ;    if no occurance then $e000 is used for vector
  5200                          ;    $e000 => monitor start
  5201                          ;  kernal expects:
  5202                          ;    $x000 - jmp init  (cold start)
  5203                          ;    $x003 - jmp winit (warm start)
  5204                          ;    $x006 - 'c'(+$80)=> kernal cold start first
  5205                          ;    $x007 - 'b'+$80
  5206                          ;    $x008 - 'm'+$80
  5207                          ;    $x009 - 'x'  x=4k bank (1-8)
  5208                          ;------------------------------------------------
  5209                          ; F99C Test bytes for ROMs
  5210  f99c c2cd               patall: !byte $C2,$CD		; $x004 rom pattern
  5211                          ; F99E
  5212  f99e a2fe               start:	ldx #$FE		; do all normal junk...
  5213  f9a0 78                 	sei
  5214  f9a1 9a                 	txs
  5215  f9a2 d8                 	cld
  5216                          
  5217                          ; check for warm start
  5218                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  5219  f9a3 a9a5               	lda #warm
  5220  f9a5 cdfa03             	cmp evect+2		; check warm flag ?
  5221  f9a8 d003               	bne scold		; no -> cold start
  5222  f9aa 4c58ff             	jmp chkwarm		; warm start patch
  5223                          } else{
  5224                          	lda #$FF
  5225                          	eor evect+2
  5226                          	eor evect+3		; compare warm start flags $A5, $5A
  5227                          	beq swarm		; if yes...do warm start
  5228                          	}
  5229                          
  5230                          ; F9AD Check for roms
  5231  f9ad a906               scold:	lda #6			; set up indirect to $0006 = position ROM ident bytes
  5232  f9af 8596               	sta eal
  5233  f9b1 a900               	lda #0			; clear upper
  5234  f9b3 8597               	sta eah
  5235  f9b5 8df803             	sta evect		; set low byte of vector warm start to $00
  5236  f9b8 a230               	ldx #$30		; existance flag 4. rom ident byte compare value to '0'
  5237  f9ba a003               sloop0: ldy #3			; set counter to 4th ROM ident byte
  5238  f9bc a597               	lda eah
  5239  f9be 3018               	bmi sloop2		; no roms but this one... -> monitor cold boot
  5240  f9c0 18                 	clc			; calc new test point
  5241  f9c1 6910               	adc #$10                ; 4k steps
  5242  f9c3 8597               	sta eah
  5243  f9c5 e8                 	inx			; next 4. byte compare value $31, $32, $33...
  5244  f9c6 8a                 	txa
  5245  f9c7 d196               	cmp (eal),y		; compare if 4. byte $31 at address $1006+3, $32 at $2006...
  5246  f9c9 d0ef               	bne sloop0		; 4. byte does not mach - > next ROM pos. $2000, $3000...
  5247  f9cb 88                 	dey			; check next byte backwards if 4th byte matches
  5248  f9cc b196               sloop1: lda (eal),y		; load 3., 2., 1. byte
  5249  f9ce 88                 	dey
  5250  f9cf 300a               	bmi sloop3		; all done...correctly - 2.+3. byte matches -> autostart ROM found!
  5251  f9d1 d99cf9             	cmp patall,y		; compare test bytes 'M', 'B'
  5252  f9d4 f0f6               	beq sloop1		; 3. byte OK -> check 2. byte
  5253  f9d6 d0e2               	bne sloop0		; no good... 2. or 3. ident byte does not mach
  5254                          
  5255                          ; monitor (could be test for keydown ***)
  5256  f9d8 a0e0               sloop2: ldy #$E0                ; monitor vector
  5257  f9da 2c                 	!byte $2C		; skip two bytes
  5258  f9db a497               sloop3: ldy eah
  5259  f9dd 8cf903             	sty evect+1             ; set high byte of vector
  5260                          
  5261  f9e0 aa                 	tax                     ; move 1. ident byte to x to set N-flag
  5262  f9e1 1018               	bpl swarm               ; don't use kernal initilization
  5263                          				;   jump to warm start if value is positive ('c'=$43)
  5264                          
  5265                          ; kernal cold start
  5266  f9e3 20fef9             	jsr ioinit              ; initilize i/o -> $F9FE (TPI1, TPI2, CIA, TOD)
  5267  f9e6 a9f0               	lda #$F0		; prevent damage to non-tested buffers
  5268  f9e8 85c1               	sta pkybuf+1            ; start F-keys
  5269  f9ea 2004e0             	jsr jcint               ; cinit call for non-cleared system $E004 -> cint $E044
  5270  f9ed 2094fa             	jsr ramtas              ; ram-test and set -> $FA94
  5271  f9f0 20b1fb             	jsr restor              ; operationg system vectors -> $FBB1 (copies $0300 Vector Table)
  5272  f9f3 2004e0             	jsr jcint               ; screen editor init $E004 -> cint $E044 (editor, F-Keys, VIC)
  5273  f9f6 a9a5               	lda #warm		; Kernal initilize done flag
  5274  f9f8 8dfa03             	sta evect+2             ; save first warm start flag $A5
  5275                          ; F9FB Warm start entry
  5276  f9fb 6cf803             swarm:  jmp (evect)             ; start exit -> basic warm start $BBA0
  5277                          ; -------------------------------------------------------------------------------------------------
  5278                          ; ioinit - initilize i/o system
  5279                          ;   6509/6525/6525/6526
  5280                          ;   must be entered with irq's disabled
  5281                          ;------------------------------------------
  5282                          ; F9FE I/O register init (TPI1, TPI2, CIA, TOD)
  5283                          
  5284                          ; 6525 tpi1 initilization code
  5285  f9fe a9f3               ioinit: lda #%11110011		; cb,ca=hi ie3,4=neg ip=1 mc=1
  5286  fa00 8d06de             	sta tpi1+creg		; interrupt mode = on, parity / VIC bank 15 selected for both
  5287  fa03 a9ff               	lda #$FF
  5288  fa05 8d05de             	sta tpi1+mir		; mask on all irq's
  5289                          ; pb4=output 1, to claim dbus
  5290  fa08 a95c               	lda #%01011100  	; wrt=lo unused netr=off
  5291  fa0a 8d01de             	sta tpi1+pb		; IEEE ifc=0, netw.=0, arb.sw.=1, cass. write=0,motor=1 
  5292  fa0d a97d               	lda #%01111101  	; set directions
  5293  fa0f 8d04de             	sta tpi1+ddpb		; input: cassette switch, IEEE srq
  5294                          				; output: IEEE ifc, network, arb.sw., cass. motor,write
  5295                          
  5296  fa12 a93d               	lda #%00111101		; IEEE controls off: dc=1, te=0, ren=1, atn=1, dav=1, eo=1
  5297  fa14 8d00de             	sta tpi1+pa
  5298  fa17 a93f               	lda #%00111111  	; IEEE control to transmitt, data to receive
  5299  fa19 8d03de             	sta tpi1+ddpa		; in: ndac, nfrd / out: dc, te, ren, atn, dav, eoi
  5300                          
  5301                          ; 6525 tpi2 initilization code
  5302  fa1c a9ff               	lda #$FF     		; set up keyboard outputs
  5303  fa1e 8d00df             	sta tpi2+pa             ; keyboard out 8-15=1
  5304  fa21 8d01de             	sta tpi1+pb             ; IEEE ifc=1, network=1, arb.sw.=1, cass. motor=1,write=1
  5305  fa24 8d03df             	sta tpi2+ddpa           ; dir keyboard 8-15 = output
  5306  fa27 8d04df             	sta tpi2+ddpb           ; dir keyboard 0-7 = output
  5307  fa2a 4e00df             	lsr tpi2+pa             ; clear keyboard 15 bit #7
  5308  fa2d a9c0               	lda #$C0		; set up vic selects=out for p-series
  5309  fa2f 8d02df             	sta tpi2+pc             ; VIC 16k bank select=11 $c000-$ffff
  5310  fa32 8d05df             	sta tpi2+ddpc           ; dir input: #0-5 keyboard 0-5 / output: #6-7 VIC 16k bank
  5311                          
  5312                          ; 6526 cia initilization code
  5313                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5314  fa35 a97f               	lda #$7f		; turn off all irq sources from 6526...
  5315                          	} else{
  5316                          	lda #$84		; set irq: #7=set, #2=ALRM enable TOD interrupt
  5317                          }
  5318  fa37 8d0ddc             	sta cia+icr
  5319  fa3a a000               	ldy #$00     		; all ieee in / same all game inputs
  5320  fa3c 8c02dc             	sty cia+ddra		; dir input: IEEE data, #6,7 also trigger 1,2
  5321  fa3f 8c03dc             	sty cia+ddrb		; dir input: game 1,2
  5322  fa42 8c0fdc             	sty cia+crb		; Timer B stop, PB7=off, cont, Phi2, activate TOD write
  5323                          ; activate tod
  5324  fa45 8d08dc             	sta cia+tod10		; clear TOD 1/10 seconds
  5325                          ; 60/50 hz test code for tod
  5326  fa48 8c02de             	sty tpi1+lir		; clear all interrupts
  5327  fa4b ad02de             io100:  lda tpi1+lir		; wait untill it happens again
  5328  fa4e 6a                 	ror			; shift bit #0 to carry
  5329  fa4f 90fa               	bcc io100		; pc0 = 1 -> 50/60hz irq
  5330  fa51 8c02de             	sty tpi1+lir		; clear it again
  5331                          ; start a timmer
  5332  fa54 a200               	ldx #0   
  5333  fa56 a000               	ldy #0
  5334  fa58 e8                 io110:  inx
  5335  fa59 d0fd               	bne io110		; delay 256x -> 1.28 ms @ 1MHz
  5336  fa5b c8                 	iny
  5337  fa5c ad02de             	lda tpi1+lir		; load interrrupt latch reg
  5338  fa5f 6a                 	ror
  5339  fa60 90f6               	bcc io110		; pc0 = 1 -> 50/60hz irq          
  5340  fa62 c00e               	cpy #id55hz   
  5341  fa64 9003               	bcc io120               ; it was 60 hz, signal appears again in 14 tries = <18ms
  5342  fa66 a988               	lda #%10001000		; set for 50hz
  5343  fa68 2c                 	!byte $2C		; skip two bytes
  5344  fa69 a908               io120:  lda #%00001000
  5345  fa6b 8d0edc             	sta cia+cra            ; set TOD=50/60Hz, run mode=continuous
  5346                          
  5347                          ; 6526  inter-process communication initialization
  5348                          ;   pra = data port
  5349                          ;   prb = ipc lines
  5350                          ;   irq's from 2nd processor via flag input
  5351  fa6e ad0ddb             	lda ipcia+icr		; clear icr
  5352  fa71 a990               	lda #$90    
  5353  fa73 8d0ddb             	sta ipcia+icr		; flag irqs on
  5354  fa76 a940               	lda #$40    
  5355  fa78 8d01db             	sta ipcia+prb		; no nmi to z80, sem6509 low
  5356  fa7b a900               	lda #$00    
  5357  fa7d 8d02db             	sta ipcia+ddra		; port a=input
  5358  fa80 8d0fdb             	sta ipcia+crb		; timer b off
  5359  fa83 8d0edb             	sta ipcia+cra		; timer a off
  5360  fa86 a948               	lda #%01001000		; port b lines sem65,ennmi are outs
  5361  fa88 8d03db             	sta ipcia+ddrb
  5362                          
  5363                          ; 6551 initilization code handled by reset  10/19/81 rsr
  5364                          
  5365                          ; turn off ifc
  5366  fa8b a901               	lda #ifc
  5367  fa8d 0d01de             	ora tpi1+pb		; TPI1 PB set bit #0 IEEE ifc=1
  5368  fa90 8d01de             	sta tpi1+pb 
  5369  fa93 60                 	rts         
  5370                          ; -------------------------------------------------------------------------------------------------
  5371                          ; ramtas - initilize lower ram with $00
  5372                          ;  and test all system dynamic ram
  5373                          ;  set ram limits (64k bank min size)
  5374                          ;  alocatate initial buffer space
  5375                          ;  turn off rs232 and cassette buffers
  5376                          ;  reset xtape vectors to non-cassette
  5377                          ;-----------------------------------------
  5378                          ; FA94 RAM-test / vector init
  5379  fa94 a900               ramtas: lda #0			; init value A = $00, counter X = 0
  5380  fa96 aa                 	tax
  5381  fa97 9d0200             px1:    sta $0002,x		; clear ZP above 6509 bank regs
  5382  fa9a 9d0002             	sta buf,x		; clear basic input buffer from $0200       
  5383  fa9d 9df802             	sta evect-$100,x	; clear kernal RAM till evct $03F8
  5384  faa0 e8                 	inx
  5385  faa1 d0f4               	bne px1			; clear next byte
  5386                          
  5387                          ; memory size check
  5388  faa3 a900               	lda #0			; bottom of memory always segment 0 (P500)
  5389  faa5 8501               	sta i6509
  5390  faa7 8d5a03             	sta memstr+2		; set bottom of user memory
  5391  faaa 8d5403             	sta lowadr+2		; ...and system memory
  5392  faad a902               	lda #2			; start at byte $0002
  5393  faaf 8d5803             	sta memstr
  5394  fab2 8d5203             	sta lowadr
  5395  fab5 c601               	dec i6509		; place back one segment for test
  5396                          
  5397                          ; memsiz,sal,lowadr are zeroed above
  5398  fab7 e601               sizlop: inc i6509		; claculate next ind bank
  5399  fab9 a501               	lda i6509
  5400  fabb c90f               	cmp #irom		; all slots full...exit
  5401  fabd f024               	beq size
  5402  fabf a002               	ldy #2			; always start at $0002, sal/sah already $0000
  5403  fac1 b193               siz100: lda (sal),y
  5404  fac3 aa                 	tax			; save memory value in X 
  5405  fac4 a955               	lda #$55		; test with $55
  5406  fac6 9193               	sta (sal),y
  5407  fac8 b193               	lda (sal),y
  5408  faca c955               	cmp #$55		; check if $55 
  5409  facc d015               	bne size		; end test if different
  5410  face 0a                 	asl			; test with $AA
  5411  facf 9193               	sta (sal),y
  5412  fad1 b193               	lda (sal),y
  5413  fad3 c9aa               	cmp #$AA		; check if $AA
  5414  fad5 d00c               	bne size		; end test if different
  5415  fad7 8a                 	txa
  5416  fad8 9193               	sta (sal),y		; restore old memory value from X
  5417                          !ifdef FULL_RAMTEST{		; ********** Full RAM-test **********
  5418                          	iny
  5419                          	bne siz100		; test next byte
  5420                          } else{				; ********** Fast RAM-test PATCH **********
  5421  fada ea                 	nop
  5422  fadb ea                 	nop
  5423  fadc ea                 	nop
  5424                          }
  5425  fadd e694               	inc sah
  5426  fadf d0e0               	bne siz100		; test next page
  5427  fae1 f0d4               	beq sizlop		; test next bank
  5428                          
  5429                          ; set top of memory
  5430  fae3 a601               size:   ldx i6509		; bank number of failure
  5431  fae5 ca                 	dex			; back up one segment
  5432  fae6 8a                 	txa			; .a= bank#
  5433  fae7 a2ff               	ldx #$FF
  5434                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5435  fae9 a0fd               	ldy #$FD		; reserve top two pages for swapping system
  5436  faeb 8d5703             	sta hiadr+2		; set system top of memory = $FDFF
  5437  faee 8c5603             	sty hiadr+1
  5438  faf1 8e5503             	stx hiadr
  5439                          
  5440                          ; allocate 3 pages (512funcs,256rs232)
  5441  faf4 a0fa               	ldy #$FD-3		; user memory top = $FAFF
  5442                          } else{
  5443                          	ldy #$FE		; reserve top page for swapping system
  5444                          	sta hiadr+2		; set system top of memory = $FEFF
  5445                          	sty hiadr+1
  5446                          	stx hiadr
  5447                          
  5448                          ; allocate 3 pages (512funcs,256rs232)
  5449                          	ldy #$FE-3		; user memory top = $FBFF
  5450                          }
  5451  faf6 18                 	clc
  5452  faf7 2087fb             	jsr memtop              ; set user top of memory
  5453                          
  5454                          ; flag buffers as not assigned =>$ff
  5455  fafa c6a8               	dec ribuf+2             ; init rs232 buffer bank to $FF
  5456  fafc c6a5               	dec tape1+2             ; init tape buffer bank to $FF
  5457  fafe a96b               	lda #<nocass		; set up cassette indirects to $FE6B
  5458  fb00 8d6a03             	sta itape
  5459  fb03 a9fe               	lda #>nocass
  5460  fb05 8d6b03             	sta itape+1
  5461  fb08 60                 	rts
  5462                          ; -------------------------------------------------------------------------------------------------
  5463                          ; FB09 standard vector table - initialized at boot from restor sub to cinv $0300
  5464  fb09 f8fb               jmptab: !word yirq		; FB09 -> FBF8 cinv	
  5465  fb0b 21ee               	!word timb		; FB0B -> EE21 cbinv....brk goes to monitor
  5466  fb0d b8fc               	!word panic		; FB0D -> FCB8 no.....nminv !!!!!
  5467  fb0f c6f6               	!word nopen		; FB0F -> F6C6 open file
  5468  fb11 f4f5               	!word nclose		; FB11 -> F5F4 close file
  5469  fb13 50f5               	!word nchkin		; FB13 -> F550 open channel in
  5470  fb15 aaf5               	!word nckout		; FB15 -> F5AA open channel out
  5471  fb17 adf6               	!word nclrch		; FB17 -> F6AD close channel
  5472  fb19 a3f4               	!word nbasin		; FB19 -> F4A3 input from channel
  5473  fb1b f5f4               	!word nbsout		; FB1B -> F4F5 output to channel
  5474  fb1d 72f9               	!word nstop		; FB1D -> F972 scan stop key
  5475  fb1f 44f4               	!word ngetin		; FB1F -> F444 scan keyboard
  5476  fb21 86f6               	!word nclall		; FB21 -> F686 close all files
  5477  fb23 4df7               	!word nload		; FB23 -> F74D load from file
  5478  fb25 53f8               	!word nsave		; FB25 -> F853 save to file
  5479  fb27 73ee               	!word s0		; FB27 -> EE73 monitor command parser
  5480  fb29 1fe0               	!word jescrt		; FB29 -> E01F esc key vector
  5481  fb2b 1fe0               	!word jescrt		; FB2B -> E01F user ctrl key vector
  5482  fb2d 7bf2               	!word nsecnd		; FB2D -> F27B IEEE listen secondary address
  5483  fb2f 87f2               	!word ntksa		; FB2F -> F287 IEEE talk secondary address
  5484  fb31 11f3               	!word nacptr		; FB31 -> F311 IEEE character in
  5485  fb33 9ef2               	!word nciout		; FB33 -> F29E IEEE character out
  5486  fb35 b2f2               	!word nuntlk		; FB35 -> F2B2 IEEE untalk bus
  5487  fb37 b6f2               	!word nunlsn		; FB37 -> F2B6 IEEE unlisten bus
  5488  fb39 3bf2               	!word nlistn		; FB39 -> F23B IEEE listen a device
  5489  fb3b 37f2               	!word ntalk		; FB3B -> F237 IEEE talk to a device
  5490                          tabend:
  5491                          ; -------------------------------------------------------------------------------------------------
  5492                          ; FB3D NMI entry, jumps indirect to NMI routine
  5493  fb3d 6c0403             nmi:    jmp (nminv)             ; ($0304) default -> panic = $FCB8
  5494                          ; -------------------------------------------------------------------------------------------------
  5495                          ; FB40 Set file name address
  5496                          ; .a = filename length
  5497                          ; .x = zero page location of 3 byte address
  5498  fb40 859d               setnam: sta fnlen		; store length
  5499  fb42 b500               	lda $00,x		; load and store address
  5500  fb44 8590               	sta fnadr
  5501  fb46 b501               	lda $01,x
  5502  fb48 8591               	sta fnadr+1
  5503  fb4a b502               	lda $02,x
  5504  fb4c 8592               	sta fnadr+2
  5505  fb4e 60                 	rts
  5506                          ; -------------------------------------------------------------------------------------------------
  5507                          ; FB4F Set file paramaters
  5508                          ; .a = logical address
  5509                          ; .x = first address
  5510                          ; .y = secundary address
  5511  fb4f 859e               setlfs: sta la
  5512  fb51 869f               	stx fa
  5513  fb53 84a0               	sty sa
  5514  fb55 60                 	rts
  5515                          ; -------------------------------------------------------------------------------------------------
  5516                          ; FB56 Read/write status
  5517                          ; carry set -- read device status into .a
  5518  fb56 901b               readst: bcc storst
  5519  fb58 a59f               	lda fa			; see which devices' to read
  5520  fb5a c902               	cmp #2
  5521  fb5c d00e               	bne readss		; not rs-232
  5522  fb5e ad7a03             	lda rsstat		; yes get it and remember it
  5523  fb61 48                 	pha
  5524  fb62 a900               	lda #00		; clear status when read
  5525  fb64 8d7a03             	sta rsstat
  5526  fb67 68                 	pla			; get status from stack
  5527  fb68 60                 	rts
  5528                          ; FB69 Set the system message flag
  5529  fb69 8d6103             setmsg: sta msgflg
  5530  fb6c a59c               readss: lda status		; read status
  5531                          ; set status bit
  5532  fb6e 059c               udst:   ora status		; set bit and store status
  5533  fb70 859c               	sta status
  5534  fb72 60                 	rts
  5535                          ; carry clear -- set device status with .a
  5536  fb73 48                 storst: pha
  5537  fb74 a59f               	lda fa
  5538  fb76 c902               	cmp #2
  5539  fb78 d005               	bne storss		; not rs-232
  5540  fb7a 68                 	pla
  5541  fb7b 8d7a03             	sta rsstat		; store rs-232 status
  5542  fb7e 60                 	rts
  5543                          
  5544  fb7f 68                 storss: pla
  5545  fb80 859c               	sta status		; store status
  5546  fb82 60                 	rts
  5547                          ; -------------------------------------------------------------------------------------------------
  5548                          ; FB83 IEC timeout on/off
  5549  fb83 8d5e03             settmo: sta timout
  5550  fb86 60                 	rts
  5551                          ; -------------------------------------------------------------------------------------------------
  5552                          ; FB87 Read/set top of memory
  5553  fb87 9009               memtop: bcc settop
  5554                          
  5555                          ; carry set--read top of memory
  5556  fb89 ad5d03             	lda memsiz+2		; load user memory top in .a.x.y
  5557  fb8c ae5b03             	ldx memsiz
  5558  fb8f ac5c03             	ldy memsiz+1
  5559                          
  5560                          ; carry clear--set top of memory
  5561  fb92 8e5b03             settop: stx memsiz		; set user memory top
  5562  fb95 8c5c03             	sty memsiz+1
  5563  fb98 8d5d03             	sta memsiz+2
  5564  fb9b 60                 	rts
  5565                          ; -------------------------------------------------------------------------------------------------
  5566                          ; FB9C Manage bottom of memory
  5567  fb9c 9009               membot: bcc setbot
  5568                          
  5569                          ; carry set--read bottom of memory
  5570  fb9e ad5a03             	lda memstr+2		; load bottom mem in .a.x.y
  5571  fba1 ae5803             	ldx memstr
  5572  fba4 ac5903             	ldy memstr+1
  5573                          
  5574                          ; carry clear--set bottom of memory
  5575  fba7 8e5803             setbot: stx memstr		; set bottom mem
  5576  fbaa 8c5903             	sty memstr+1
  5577  fbad 8d5a03             	sta memstr+2
  5578  fbb0 60                 	rts
  5579                          ; -------------------------------------------------------------------------------------------------
  5580                          ; FBB1 Restore ram i/o vectors at $0300
  5581  fbb1 a209               restor: ldx #<jmptab		; load vector table address in kernal
  5582  fbb3 a0fb               	ldy #>jmptab
  5583  fbb5 a90f               	lda #irom
  5584  fbb7 18                 	clc
  5585                          
  5586                          ; FBB8 Manage ram i/o vectors
  5587  fbb8 8693               vector: stx sal			; store address
  5588  fbba 8494               	sty sah
  5589  fbbc a601               	ldx i6509		; save indirect
  5590  fbbe 8501               	sta i6509		; set ibank .a 
  5591  fbc0 900a               	bcc vect50		; carry=0 -> set/restore table
  5592                          
  5593                          ; carry set--read vectors
  5594  fbc2 a033               	ldy #tabend-jmptab-1
  5595  fbc4 b90003             vect20: lda cinv,y		; from ram table $F0300
  5596  fbc7 9193               	sta (sal),y		; into user area
  5597  fbc9 88                 	dey
  5598  fbca 10f8               	bpl vect20
  5599                          
  5600                          ; carry clear--set vectors
  5601  fbcc a033               vect50: ldy #tabend-jmptab-1
  5602  fbce b193               vect60: lda (sal),y		; from user area
  5603  fbd0 990003             	sta cinv,y		; into ram table $F0300
  5604  fbd3 88                 	dey
  5605  fbd4 10f8               	bpl vect60
  5606                          
  5607  fbd6 8601               	stx i6509		; restore indirect
  5608  fbd8 60                 	rts
  5609                          ; -------------------------------------------------------------------------------------------------
  5610                          ; FBD9 vreset - reset vector flags and control
  5611                          ;   .x - low vector address  .y - high vector address
  5612  fbd9 8ef803             vreset: stx evect
  5613  fbdc 8cf903             	sty evect+1
  5614  fbdf a95a               	lda #winit
  5615  fbe1 8dfb03             	sta evect+3
  5616  fbe4 60                 	rts
  5617                          ; -------------------------------------------------------------------------------------------------
  5618                          ; ##### irq #####
  5619                          ;**********************************************
  5620                          ;* nirq - handler for:       10/30/81 rsr     *
  5621                          ;* 6525 irq's:::::::::::::::::::::::::::::::::*
  5622                          ;* 6551 irq's                                 *
  5623                          ;*   (receiver,transmitter,dcd & dsr changes) *
  5624                          ;* 6526 irq's                                 *
  5625                          ;*   (alarm, timera, timerb)                  *
  5626                          ;* 6526 irq's                                 *
  5627                          ;*   (2nd processor)                          *
  5628                          ;* ieee srq                                   *
  5629                          ;* keyboard scan (50/60hz irq)                *
  5630                          ;*                                            *
  5631                          ;* also at present does not handle any of the *
  5632                          ;* 6566 (vic) interrupts.                     *
  5633                          ;**********************************************
  5634                          ; FBE5 IRQ handler
  5635  fbe5 48                 nirq:	pha			; save registers
  5636  fbe6 8a                 	txa
  5637  fbe7 48                 	pha
  5638  fbe8 98                 	tya
  5639  fbe9 48                 	pha
  5640  fbea ba                 	tsx			; check for brk...
  5641  fbeb bd0401             	lda stack+4,x
  5642  fbee 2910               	and #$10
  5643  fbf0 d003               	bne brkirq		; yes...
  5644  fbf2 6c0003             	jmp (cinv)		; via vector -> yirq $FBF8
  5645  fbf5 6c0203             brkirq: jmp (cbinv)		; yes...
  5646                          
  5647                          ; FBF8 entry via indirect vector cinv
  5648  fbf8 a501               yirq:   lda i6509		; save indirect bank #
  5649  fbfa 48                 	pha
  5650                          	;lda pass	; external break handler
  5651                          	;pha
  5652                          	;lda #0 	; clear for normal return
  5653                          	;sta pass
  5654  fbfb d8                 	cld			; clear dec to prevent future problems
  5655  fbfc ad07de             	lda tpi1+air
  5656  fbff d003               	bne irq000		; handle priority irq's
  5657                          
  5658                          ; external irq (vic and others)
  5659                          ;  (no code!!!!!!!!!!)
  5660  fc01 4cb0fc             	jmp prendn
  5661                          
  5662                          ; FC04 Check for ACIA IRQ
  5663  fc04 c910               irq000:	cmp #$10		; find irq source
  5664  fc06 f003               	beq irq002		; not 6551...
  5665  fc08 4c69fc             	jmp irq100
  5666                          
  5667                          ; 6551 interrupt handler
  5668  fc0b ad01dd             irq002:	lda acia+srsn		; find irq source
  5669  fc0e aa                 	tax
  5670  fc0f 2960               	and #$60		; dcd/dsr changes ??
  5671  fc11 a8                 	tay
  5672  fc12 4d7b03             	eor dcdsr
  5673  fc15 f00d               	beq irq004		; no change...
  5674  fc17 98                 	tya
  5675  fc18 8d7b03             	sta dcdsr		; update old dsr/dcd status
  5676  fc1b 0d7a03             	ora rsstat		; update rs232 status
  5677  fc1e 8d7a03             	sta rsstat
  5678  fc21 4cadfc             	jmp irq900		; done!
  5679                          ;
  5680  fc24 8a                 irq004:	txa
  5681  fc25 2908               	and #$08		; receiver ??
  5682  fc27 f025               	beq irq010		; no...
  5683                          
  5684                          ; receiver service
  5685  fc29 ac7d03             	ldy ridbe		; check buffers
  5686  fc2c c8                 	iny
  5687  fc2d cc7c03             	cpy ridbs		; have we passed start?
  5688  fc30 d004               	bne irq005		; no...
  5689                          
  5690  fc32 a908               	lda #doverr		; input buffer full error
  5691  fc34 d012               	bne irq007		; bra...set status
  5692                          
  5693  fc36 8c7d03             irq005:	sty ridbe		; move end foward
  5694  fc39 88                 	dey
  5695  fc3a a6a8               	ldx ribuf+2
  5696  fc3c 8601               	stx i6509
  5697                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  5698  fc3e ae01dd             	ldx acia+srsn		; get status register
  5699  fc41 2052ff             	jsr patch2		; moved to end because 1 byte missing here
  5700  fc44 8a                 	txa			; set status
  5701  fc45 ea                 	nop
  5702                          } else{
  5703                          	lda acia+drsn
  5704                          	sta (ribuf),y		; data to buffer
  5705                          	lda acia+srsn		; get status register
  5706                          }
  5707  fc46 2907               	and #$07
  5708  fc48 0d7a03             irq007:	ora rsstat		; set status
  5709  fc4b 8d7a03             	sta rsstat
  5710                          
  5711  fc4e ad01dd             irq010:	lda acia+srsn		; find irq source
  5712  fc51 2910               	and #$10		; transmitter ?
  5713  fc53 f011               	beq irq090		; no...
  5714  fc55 ad02dd             	lda acia+cdr		; check for transmitter on
  5715  fc58 290c               	and #$0c
  5716  fc5a c904               	cmp #$04		; bits(32)=01 => xmitter int enabled
  5717  fc5c d008               	bne irq090		; off...
  5718                          
  5719                          ; transmitter service (no interrrupt driven transmissions)
  5720  fc5e a9f3               	lda #%11110011		; turn of transmitter
  5721  fc60 2d02dd             	and acia+cdr
  5722  fc63 8d02dd             	sta acia+cdr
  5723  fc66 4cadfc             irq090:	jmp irq900		; exit..pop priority...
  5724                          
  5725                          ; FC69 Check for coprozessor IRQ
  5726  fc69 c908               irq100:	cmp #$08		; check if inter-process irq
  5727  fc6b d00a               	bne irq110		; no...
  5728  fc6d ad0ddb             	lda ipcia+icr		; clear irq condition
  5729  fc70 58                 	cli			; this irq can be interrupted
  5730  fc71 2056fd             	jsr ipserv		; do the request
  5731  fc74 4cadfc             	jmp irq900		; done!
  5732                          
  5733                          ; FC77 Check for CIA IRQ
  5734  fc77 58                 irq110:	cli			; all other irq's may be interrupted, too
  5735  fc78 c904               	cmp #$04		; check if 6526
  5736  fc7a d00c               	bne irq200		; no...
  5737                          
  5738                          ; 6526 interrupt reconized
  5739  fc7c ad0ddc             	lda cia+icr		; get active interrupts
  5740  fc7f 0d6903             	ora alarm		; in case we lose something
  5741  fc82 8d6903             	sta alarm
  5742                          
  5743                          ; nothing to do at present....need code ********
  5744  fc85 4cadfc             	jmp irq900		; ...dump interrupt
  5745                          
  5746                          ; FC88 Check for IEC bus IRQ (and ignore it)
  5747  fc88 c902               irq200:	cmp #$02		; check for ieee srq
  5748  fc8a d003               	bne irq300
  5749                          
  5750                          ; need code ************
  5751  fc8c 4cadfc             	jmp irq900		; ...dump interrupt
  5752                          
  5753                          ; FC8F Must be a 50/60Hz IRQ - poll keyboard, update time
  5754  fc8f 2013e0             irq300:	jsr jkey		; scan the keyboard
  5755  fc92 2080f9             	jsr udtim		; set stopkey flag
  5756                          
  5757                          ; test for cassette switch
  5758  fc95 ad01de             	lda tpi1+pb		; get cass switch
  5759  fc98 1009               	bpl irq310		; switch is down...
  5760  fc9a a000               	ldy #0			; flag motor off...
  5761  fc9c 8c7503             	sty cas1
  5762  fc9f 0940               	ora #$40		; turn motor off...
  5763  fca1 d007               	bne irq320		; jump
  5764  fca3 ac7503             irq310:	ldy cas1		; test for flag on...
  5765  fca6 d005               	bne irq900		; yes computer control..leave alone
  5766  fca8 29bf               	and #$FF-$40		; turn motor on...
  5767  fcaa 8d01de             irq320:	sta tpi1+pb		; store mods into port
  5768                          
  5769  fcad 8d07de             irq900:	sta tpi1+air		; pop the interrupt...
  5770                          
  5771                          prendn: ;lda pass	; check for foriegn call
  5772                          	;bne segrti	; yes...return
  5773                          	;pla
  5774                          	;sta pass	; restore interrupted interrupt
  5775  fcb0 68                 	pla             ;restore registers
  5776  fcb1 8501               	sta i6509
  5777  fcb3 68                 prend:	pla			; entry point for register only
  5778  fcb4 a8                 	tay
  5779  fcb5 68                 	pla
  5780  fcb6 aa                 	tax
  5781  fcb7 68                 	pla
  5782                          
  5783                          ; Default NMI routine
  5784  fcb8 40                 panic:	rti			; come here if no new nmi vector.
  5785                          ; -------------------------------------------------------------------------------------------------
  5786                          ; send a request
  5787                          ;   enter:   ipb buffer is initialized to hold the
  5788                          ;            command
  5789                          ;            input parameter bytes
  5790                          ;
  5791                          ;   exit:    ipb buffer holds
  5792                          ;            output parameter bytes
  5793                          ;            all other bytes in ipb unchanged
  5794                          ;---------------------------------------------------------------
  5795                          ; FCB9 Coprocessor request
  5796  fcb9 ad0008             iprqst:	lda ipb+ipccmd
  5797  fcbc 297f               	and #$7F
  5798  fcbe a8                 	tay
  5799  fcbf 202ffe             	jsr getpar		; get #ins,outs
  5800  fcc2 a904               	lda #sem88		; check 8088 semaphore
  5801  fcc4 2d01db             	and ipcia+prb
  5802  fcc7 d0f0               	bne iprqst		; locked out by other processor
  5803  fcc9 a908               	lda #sem65
  5804  fccb 0d01db             	ora ipcia+prb		; lock 6509 semaphore
  5805  fcce 8d01db             	sta ipcia+prb
  5806  fcd1 ea                 	nop			; a pause
  5807                          
  5808  fcd2 ad01db             	lda ipcia+prb		; collisions with 8088?
  5809  fcd5 aa                 	tax
  5810  fcd6 2904               	and #sem88
  5811  fcd8 f00c               	beq ipr100		; ok...
  5812  fcda 8a                 	txa
  5813  fcdb 4908               	eor #sem65
  5814  fcdd 8d01db             	sta ipcia+prb		; nope, clear 6509 semaphore
  5815  fce0 8a                 	txa			; kill some time
  5816  fce1 ea                 	nop
  5817  fce2 ea                 	nop
  5818  fce3 ea                 	nop
  5819  fce4 d0d3               	bne iprqst		; try again (br always)
  5820                          
  5821                          ;     send cmd byte and cause irq
  5822  fce6 a9ff               ipr100: lda #$FF
  5823  fce8 8d02db             	sta ipcia+ddra		; port direction = out
  5824  fceb ad0008             	lda ipb+ipccmd
  5825  fcee 8d00db             	sta ipcia+pra		; write cmd byte to port
  5826                          ; cause irq
  5827  fcf1 2016fe             	jsr frebus		; give up bus
  5828  fcf4 ad01db             	lda ipcia+prb		; pb6 := 0
  5829  fcf7 29bf               	and #$BF
  5830  fcf9 8d01db             	sta ipcia+prb
  5831  fcfc 0940               	ora #$40		; keep low for 4us (8 cycles)
  5832  fcfe 58                 	cli
  5833  fcff ea                 	nop
  5834  fd00 ea                 	nop
  5835  fd01 ea                 	nop
  5836  fd02 8d01db             	sta ipcia+prb		; pb6 := high
  5837                          
  5838  fd05 20fcfd             	jsr waithi		; sem8088 -> hi (cmd byte recvd)
  5839  fd08 a900               	lda #$00
  5840  fd0a 8d02db             	sta ipcia+ddra		; port direction = in
  5841  fd0d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5842  fd10 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5843                          
  5844                          ;    send data bytes, if any
  5845  fd13 a000               	ldy #0
  5846  fd15 f01d               	beq ipr250		; always
  5847                          
  5848  fd17 a9ff               ipr200:	lda #$FF
  5849  fd19 8d02db             	sta ipcia+ddra		; port direction = out
  5850  fd1c b90508             	lda ipb+ipcdat,y	; get next data byte
  5851  fd1f 8d00db             	sta ipcia+pra		; write cmd out
  5852  fd22 200dfe             	jsr ackhi		; sem6509 -> hi (data ready)
  5853  fd25 20fcfd             	jsr waithi		; sem8088 -> hi (data recvd)
  5854  fd28 a900               	lda #$00
  5855  fd2a 8d02db             	sta ipcia+ddra		; port direction = in
  5856  fd2d 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5857  fd30 20f4fd             	jsr waitlo		; sem8088 -> lo (ack ack)
  5858  fd33 c8                 	iny			; bump index to next data byte
  5859  fd34 cc0308             ipr250:	cpy ipb+ipcin		; any more ??
  5860  fd37 d0de               	bne ipr200		; yes...
  5861                          
  5862                          ;    receive data bytes, if any
  5863  fd39 a000               	ldy #0
  5864  fd3b f013               	beq ipr350		; always
  5865                          
  5866  fd3d 200dfe             ipr300:	jsr ackhi		; sem6509 -> hi (rdy to receive)
  5867  fd40 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5868  fd43 ad00db             	lda ipcia+pra		; get data from port
  5869  fd46 990508             	sta ipb+ipcdat,y	; stuff it away
  5870  fd49 2004fe             	jsr acklo		; sem6509 -> lo (data recvd)
  5871  fd4c 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5872  fd4f c8                 	iny
  5873                          
  5874  fd50 cc0408             ipr350:	cpy ipb+ipcout		; more?
  5875  fd53 d0e8               	bne ipr300		; yes...
  5876  fd55 60                 	rts			; done!!
  5877                          ; -------------------------------------------------------------------------------------------------
  5878                          ; service an 8088 request
  5879                          ;-------------------------------------------------------------------
  5880                          ; FD56 Coprocessor irq handler
  5881                          ipserv: ;ldy #ipbsiz-1	; copy ip buffer to stack
  5882                          	;ips050 lda ipb,y
  5883                          	; pha
  5884                          	; dey
  5885                          	; bpl ips050
  5886                          
  5887  fd56 a900               	lda #0
  5888  fd58 8d02db             	sta ipcia+ddra		; port dir=in, just in case...
  5889  fd5b ad00db             	lda ipcia+pra		; read cmd from port
  5890  fd5e 8d0008             	sta ipb+ipccmd		; store cmd and decode it
  5891  fd61 297f               	and #$7F		; mask off bus bit
  5892  fd63 a8                 	tay
  5893  fd64 202ffe             	jsr getpar		; get param counts
  5894  fd67 98                 	tya			; adjust offset for jump table
  5895  fd68 0a                 	asl
  5896  fd69 a8                 	tay
  5897  fd6a b91008             	lda ipjtab,y		; jump address(lo)
  5898  fd6d 8d0108             	sta ipb+ipcjmp
  5899  fd70 c8                 	iny
  5900  fd71 b91008             	lda ipjtab,y		; jump address (hi)
  5901  fd74 8d0208             	sta ipb+ipcjmp+1
  5902  fd77 200dfe             	jsr ackhi		; sem6509 -> hi (cmd recvd)
  5903  fd7a 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5904                          
  5905                          ;    receive input bytes, if any
  5906  fd7d a000               	ldy #0
  5907                          
  5908  fd7f cc0308             ips100:	cpy ipb+ipcin		; any more?
  5909  fd82 f015               	beq ips200		; no...
  5910  fd84 2004fe             	jsr acklo		; sem6509 ->lo (ack ack)
  5911  fd87 20fcfd             	jsr waithi		; sem8088 -> hi (data available)
  5912  fd8a ad00db             	lda ipcia+pra		; read data byte
  5913  fd8d 990508             	sta ipb+ipcdat,y	; store it
  5914  fd90 200dfe             	jsr ackhi		; sem6509 -> hi (data recvd)
  5915  fd93 20f4fd             	jsr waitlo		; sem8088 -> lo (ack)
  5916  fd96 c8                 	iny
  5917  fd97 d0e6               	bne ips100		; always...
  5918                          
  5919                          ;    process cmd
  5920  fd99 2c0008             ips200:	bit ipb+ipccmd		; cmd requires bus?
  5921  fd9c 3033               	bmi ips500		; yes...
  5922  fd9e a9fd               	lda #>ipsret		; push return
  5923  fda0 48                 	pha
  5924  fda1 a9a6               	lda #<ipsret
  5925  fda3 48                 	pha
  5926  fda4 6c0108             	jmp (ipb+ipcjmp)	; gone!!!
  5927                          
  5928                          ;    send return bytes, if any
  5929                          ips300:
  5930                          ipsret=ips300-1
  5931  fda7 2004fe             	jsr acklo		; sem6509 -> lo
  5932  fdaa a000               	ldy #0
  5933  fdac f01d               	beq ips350		; always
  5934                          ips310:
  5935  fdae 20fcfd             	jsr waithi		; sem8088 -> hi (8088 rdy to recv)
  5936  fdb1 a9ff               	lda #$FF
  5937  fdb3 8d02db             	sta ipcia+ddra		; port direction = out
  5938  fdb6 b90508             	lda ipb+ipcdat,y
  5939  fdb9 8d00db             	sta ipcia+pra		; write data to port
  5940  fdbc 200dfe             	jsr ackhi		; sem6509 -> hi (data available)
  5941  fdbf 20f4fd             	jsr waitlo		; sem8088 -> lo (data recvd)
  5942  fdc2 a900               	lda #0
  5943  fdc4 8d02db             	sta ipcia+ddra		; port direction = in
  5944  fdc7 2004fe             	jsr acklo		; sem6509 -> lo (ack)
  5945  fdca c8                 	iny
  5946  fdcb cc0408             ips350:	cpy ipb+ipcout		; any more?
  5947  fdce d0de               	bne ips310		; yes, repeat...
  5948                          
  5949                          ips400:	;ldy #0
  5950                          	;ips450 pla	; restore ip buffer
  5951                          	; sta ipb,y
  5952                          	; iny
  5953                          	; cpy #ipbsiz
  5954                          	; bne ips450
  5955  fdd0 60                 	rts			; done!
  5956                          
  5957                          ;      special,   for commands requiring the bus
  5958  fdd1 a9fd               ips500:	lda #>buret
  5959  fdd3 48                 	pha
  5960  fdd4 a9dc               	lda #<buret
  5961  fdd6 48                 	pha			; push return
  5962  fdd7 201ffe             	jsr getbus		; grab bus
  5963  fdda 6c0108             	jmp (ipb+ipcjmp)	; gone!
  5964                          
  5965                          ips600:
  5966                          buret=ips600-1
  5967  fddd 2016fe             	jsr frebus		; give up bus
  5968  fde0 ad0408             	lda ipb+ipcout		; #bytes to return
  5969  fde3 8d0308             	sta ipb+ipcin
  5970  fde6 8d0008             	sta ipb+ipccmd		; return op=#bytes to return
  5971  fde9 a900               	lda #0
  5972  fdeb 8d0408             	sta ipb+ipcout		; just send to 8088
  5973  fdee 20b9fc             	jsr iprqst
  5974  fdf1 4cd0fd             	jmp ips400		; done!
  5975                          
  5976                          ; FDF4 waitlo - wait until sem88 goes low
  5977  fdf4 ad01db             waitlo:	lda ipcia+prb
  5978  fdf7 2904               	and #sem88
  5979  fdf9 d0f9               	bne waitlo
  5980  fdfb 60                 	rts
  5981                          ; waithi - wait until sem88 goes high
  5982                          
  5983  fdfc ad01db             waithi:	lda ipcia+prb
  5984  fdff 2904               	and #sem88
  5985  fe01 f0f9               	beq waithi
  5986  fe03 60                 	rts
  5987                          
  5988                          ; acklo - acknowlegde sem65 low
  5989  fe04 ad01db             acklo:	lda ipcia+prb
  5990  fe07 29f7               	and #$FF-sem65
  5991  fe09 8d01db             	sta ipcia+prb
  5992  fe0c 60                 	rts
  5993                          
  5994                          ; ackhi - acknowledge sem6509 hi
  5995  fe0d a908               ackhi:	lda #sem65
  5996  fe0f 0d01db             	ora ipcia+prb
  5997  fe12 8d01db             	sta ipcia+prb
  5998  fe15 60                 	rts
  5999                          
  6000                          ; frebus - give up bus
  6001  fe16 ad01de             frebus:	lda tpi1+pb		; pb4 := 0
  6002  fe19 29ef               	and #$EF
  6003  fe1b 8d01de             	sta tpi1+pb
  6004  fe1e 60                 	rts
  6005                          
  6006                          ; getbus - grab bus
  6007                          getbus:
  6008  fe1f ad01db             	lda ipcia+prb		; check nbusy2
  6009  fe22 2902               	and #$02
  6010  fe24 f0f9               	beq getbus		; 2nd proc not off
  6011                          
  6012  fe26 ad01de             	lda tpi1+pb		; pb4 := 1
  6013  fe29 0910               	ora #$10
  6014  fe2b 8d01de             	sta tpi1+pb
  6015  fe2e 60                 	rts
  6016                          
  6017                          ; getpar
  6018                          ;  enter - .y = table offset
  6019                          ;  exit:   .y = table offset
  6020                          ;          #ins,#outs put into ipb buffer
  6021  fe2f b91009             getpar:	lda ipptab,y		; break apart nibbles
  6022  fe32 48                 	pha
  6023  fe33 290f               	and #$0F
  6024  fe35 8d0308             	sta ipb+ipcin		; #input bytes
  6025  fe38 68                 	pla
  6026  fe39 4a                 	lsr
  6027  fe3a 4a                 	lsr
  6028  fe3b 4a                 	lsr
  6029  fe3c 4a                 	lsr
  6030  fe3d 8d0408             	sta ipb+ipcout		; #output bytes
  6031  fe40 60                 	rts
  6032                          
  6033                          ; ipcgo - free bus, interrupt 2nd processor
  6034                          ;         go into a loop, waiting for requests.
  6035                          ;  * returns if bus error occurs
  6036  fe41 a2ff               ipcgo:	ldx #$FF
  6037  fe43 8601               	stx i6509		; indirects to bank f only
  6038  fe45 ad01de             	lda tpi1+pb		; tpi1 pb4:=0 frees dbus
  6039  fe48 29ef               	and #$EF
  6040  fe4a 8d01de             	sta tpi1+pb
  6041  fe4d ea                 	nop			; a pause
  6042  fe4e ad01db             	lda ipcia+prb		; check nbusy1
  6043  fe51 6a                 	ror
  6044  fe52 b001               	bcs ipcgx
  6045  fe54 60                 	rts			; bus not free!, error...
  6046                          
  6047  fe55 a900               ipcgx:	lda #0			; pb6 lo->hi in 4us...
  6048  fe57 78                 	sei
  6049  fe58 8d01db             	sta ipcia+prb		; interrupt 2nd processeor
  6050  fe5b a940               	lda #$40		; 2 cycles (4us=8cycles)
  6051  fe5d ea                 	nop
  6052  fe5e ea                 	nop
  6053  fe5f ea                 	nop
  6054  fe60 ea                 	nop			; 8 cycles of garb. 5us safer than 4!
  6055  fe61 8d01db             	sta ipcia+prb		; turn pb6 back on
  6056  fe64 58                 	cli
  6057  fe65 4c65fe             iploop:	jmp iploop		; sit down
  6058                          ; -------------------------------------------------------------------------------------------------
  6059                          ; FE68 no cassette routines avaliable
  6060  fe68 6c6a03             xtape:	jmp     (itape)		; goto tape device indirect -> nocass
  6061                          ;
  6062  fe6b 68                 nocass:	pla			; remove jsr xtape and return
  6063  fe6c 68                 	pla
  6064  fe6d 4c4cf9             	jmp error5		; send back ?device not present
  6065                          ; -------------------------------------------------------------------------------------------------
  6066                          ; some needed routines
  6067                          ; FE70 
  6068  fe70 a59a               rd300:	lda stah
  6069  fe72 8594               	sta sah
  6070  fe74 a599               	lda stal
  6071  fe76 8593               	sta sal
  6072  fe78 a59b               	lda stas
  6073  fe7a 8595               	sta sas
  6074  fe7c 8501               	sta i6509
  6075  fe7e 60                 	rts
  6076                          ; FE7F 
  6077  fe7f 38                 cmpste: sec
  6078  fe80 a593               	lda sal
  6079  fe82 e596               	sbc eal
  6080  fe84 a594               	lda sah
  6081  fe86 e597               	sbc eah
  6082  fe88 a595               	lda sas
  6083  fe8a e598               	sbc eas
  6084  fe8c 60                 	rts
  6085                          !ifndef CBMPATCH{
  6086                          ; FE8D
  6087                          incsal: inc sal
  6088                          	bne incr20
  6089                          	inc sah
  6090                          	bne incr20
  6091                          	inc sas
  6092                          	lda sas
  6093                          	sta i6509
  6094                          	lda #$02		; skip $0000 and $0001
  6095                          	sta sal
  6096                          incr20:	rts
  6097                          }
  6098                          ; -------------------------------------------------------------------------------------------------
  6099                          ;-------------------------------------
  6100                          ; tapery - get from the tape buffer
  6101                          ;   lda (tape1)y ;replacement
  6102                          ;-------------------------------------
  6103                          ;tapiry iny
  6104                          ;tapery ldx i6509
  6105                          ; lda tape1+2
  6106                          ; sta i6509
  6107                          ; lda (tape1)y
  6108                          ; stx i6509
  6109                          ; rts
  6110                          ;-------------------------------------
  6111                          ; tapewy - put char in the tape buffer
  6112                          ;   sta (tape1)y ;replacement
  6113                          ;-------------------------------------
  6114                          ;tapzwy ldy #$ff ;first byte in buffer
  6115                          ;tapiwy iny ;auto inc into buffer
  6116                          ;tapewy ldx i6509
  6117                          ; pha
  6118                          ; lda tape1+2
  6119                          ; sta i6509
  6120                          ; pla
  6121                          ; sta (tape1)y
  6122                          ; stx i6509
  6123                          ; rts
  6124                          ;-------------------------------------
  6125                          ; fnadry - get from file name buffer
  6126                          ;   lda (fnadr)y ;replacement
  6127                          ;-------------------------------------
  6128                          ; FEA0 Load a byte from the file name
  6129  fe8d a601               fnadry: ldx i6509
  6130  fe8f a592               	lda fnadr+2
  6131  fe91 8501               	sta i6509
  6132  fe93 b190               	lda (fnadr),y
  6133  fe95 8601               	stx i6509
  6134  fe97 60                 	rts
  6135                          ; -------------------------------------------------------------------------------------------------
  6136                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6137                          *= $FE9D
  6138                          ; ##### transx #####
  6139                          ; txjmp - transfer-of-execution jumper
  6140                          ;   entry - .a=seg # .x=low .y=high
  6141                          ;   caller must be a jsr txjmp
  6142                          ;   all registers and i6509 destroyed
  6143                          ;   returns directly to caller...
  6144  fe9d 8501               txjmp:	sta i6509		; bp routine
  6145  fe9f 8a                 	txa
  6146  fea0 18                 	clc
  6147  fea1 6902               	adc #2			; add 2 to target address
  6148  fea3 9001               	bcc txjmp1
  6149  fea5 c8                 	iny
  6150  fea6 aa                 txjmp1:	tax
  6151  fea7 98                 	tya
  6152  fea8 48                 	pha			; store target+2 to stack
  6153  fea9 8a                 	txa
  6154  feaa 48                 	pha
  6155  feab 2019ff             	jsr ipinit		; go initilize ipoint
  6156  feae a9fe               	lda #$fe
  6157  feb0 91ac               	sta (ipoint),y		; $fe to top of foreign stack
  6158                          ; 04/14/83 bp
  6159                          ; transfer exec routines for cbm2
  6160                          }
  6161                          ; -------------------------------------------------------------------------------------------------
  6162                          ; FEAB Support routine for cross bank calls
  6163  feb2 08                 exsub:	php			; save status
  6164  feb3 78                 	sei			; disable interrupts
  6165  feb4 48                 	pha			; .a
  6166  feb5 8a                 	txa
  6167  feb6 48                 	pha			; .x
  6168  feb7 98                 	tya
  6169  feb8 48                 	pha			; .y
  6170  feb9 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6171  febc a8                 	tay			; .y is xfer seg stack pointer
  6172  febd a500               	lda e6509		; push return segment to user stack
  6173  febf 202aff             	jsr putas		; push .a to other stack
  6174  fec2 a904               	lda #<excrt2		; xfer seg rts routn
  6175  fec4 a2ff               	ldx #>excrt2		; xfer seg rts routn
  6176  fec6 2024ff             	jsr putaxs		; put .a.x to xfer seg stack
  6177  fec9 ba                 	tsx
  6178  feca bd0501             	lda stack+5,x		; .sp +5 is actual routn addr lo
  6179  fecd 38                 	sec
  6180  fece e903               	sbc #03			; -3 for jsr to this routn
  6181  fed0 48                 	pha			; save .a
  6182  fed1 bd0601             	lda stack+6,x		; hi addr
  6183  fed4 e900               	sbc #00	
  6184  fed6 aa                 	tax			; .x hi
  6185  fed7 68                 	pla			; restore .a lo
  6186  fed8 2024ff             	jsr putaxs		; save .a.x onto xfer seg stack
  6187  fedb 98                 	tya			; xfer seg stack pointer
  6188  fedc 38                 excomm:	sec
  6189  fedd e904               	sbc #04			; 4 bytes .y.x.a.p
  6190  fedf 8dff01             	sta stackp		; xfer seg new stack pointer temp storage
  6191  fee2 a8                 	tay			; use this as new pointer also
  6192  fee3 a204               	ldx #04			; 4 bytes .y.x.a.p
  6193  fee5 68                 exsu10:	pla
  6194  fee6 c8                 	iny
  6195  fee7 91ac               	sta (ipoint),y		; push regs from this stack to xfer seg stack
  6196  fee9 ca                 	dex
  6197  feea d0f9               	bne exsu10
  6198  feec acff01             	ldy stackp		; restore .y as stack pointer for xfer seg
  6199  feef a92d               	lda #<expul2		; pull regs and rts routn
  6200  fef1 a2ff               	ldx #>expul2		; .hi prendn routn in xfer seg
  6201  fef3 2024ff             	jsr putaxs		; put .a.x on xfer seg stack
  6202  fef6 68                 	pla			; fix stack
  6203  fef7 68                 	pla			; fix stack
  6204  fef8 ba                 exgby:	tsx
  6205  fef9 8eff01             	stx stackp		; save current stack pointer this seg
  6206  fefc 98                 	tya			; .y is stack pointer for xfer seg
  6207  fefd aa                 	tax
  6208  fefe 9a                 	txs			; new stack for xfer seg
  6209  feff a501               	lda i6509		; xfer seg #
  6210  ff01 4cf6ff             	jmp gbye		; good bye
  6211                          ; -------------------------------------------------------------------------------------------------
  6212  ff04 ea                 	nop			; returns here if rti
  6213                          ; FEFE Return from call to foreign bank
  6214  ff05 08                 excrts: php			; .p
  6215  ff06 08                 	php			; .p
  6216                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6217  ff07 78                 	sei             	; dis ints
  6218                          }
  6219  ff08 48                 	pha			; .a
  6220  ff09 8a                 	txa
  6221  ff0a 48                 	pha			; .x
  6222  ff0b 98                 	tya
  6223  ff0c 48                 	pha			; .y
  6224  ff0d ba                 	tsx
  6225  ff0e bd0601             	lda stack+6,x		; sp +6 is return seg
  6226  ff11 8501               	sta i6509		; restore i6509 to return seg
  6227  ff13 2019ff             	jsr ipinit		; init ipoint and load stack from xfer seg
  6228  ff16 4cdcfe             	jmp excomm
  6229                          ; -------------------------------------------------------------------------------------------------
  6230                          ; FF11 ipoint = $100, Y = $FF (stack)
  6231  ff19 a001               ipinit: ldy #01
  6232  ff1b 84ad               	sty ipoint+1
  6233  ff1d 88                 	dey
  6234  ff1e 84ac               	sty ipoint		; ipoint=$0100
  6235  ff20 88                 	dey			; .y=$ff
  6236  ff21 b1ac               	lda (ipoint),y		; load stack pointer from $001ff
  6237  ff23 60                 	rts
  6238                          ; -------------------------------------------------------------------------------------------------
  6239                          ; FF1C Place X/A to ipoint (build stack in foreign bank)
  6240  ff24 48                 putaxs: pha			; save A
  6241  ff25 8a                 	txa
  6242  ff26 91ac               	sta (ipoint),y		; .x hi
  6243  ff28 88                 	dey
  6244  ff29 68                 	pla
  6245                          ; FF22 Place A to ipoint (build stack in foreign bank)
  6246  ff2a 91ac               putas:  sta (ipoint),y		; .a lo
  6247  ff2c 88                 	dey
  6248  ff2d 60                 	rts
  6249                          ; -------------------------------------------------------------------------------------------------
  6250                          ; FF26 Pull registers after calling subroutine in foreign bank
  6251  ff2e 68                 expull: pla
  6252  ff2f a8                 	tay			; .y
  6253  ff30 68                 	pla
  6254  ff31 aa                 	tax			; .x
  6255  ff32 68                 	pla			; .a
  6256  ff33 28                 	plp			; .p
  6257  ff34 60                 	rts
  6258                          ; -------------------------------------------------------------------------------------------------
  6259                          ; FF2D Helper routine to route interrupts from foreign to system bank
  6260  ff35 08                 exnmi:  php			; .p
  6261  ff36 6cfaff             	jmp (hwnmi)		; do nmi proc
  6262                          ; -------------------------------------------------------------------------------------------------
  6263                          ; FF31 Helper routine to route BRK insns from foreign to system bank
  6264  ff39 00                 exbrk:  brk
  6265  ff3a ea                 	nop
  6266  ff3b 60                 	rts
  6267                          ; -------------------------------------------------------------------------------------------------
  6268                          ; FF34 Helper routine to route interrupts from foreign to system bank
  6269  ff3c 58                 exirq:  cli
  6270  ff3d 60                 	rts
  6271                          exend:
  6272                          ;
  6273                          excrt2=excrts-1
  6274                          expul2=expull-1
  6275                          ; -------------------------------------------------------------------------------------------------
  6276                          ; (FF36) Unused space
  6277  ff3e ac                 	!byte $AC
  6278                          ; -------------------------------------------------------------------------------------------------
  6279                          !ifdef CBMPATCH{		; ***** moved to place to transfer routines right!
  6280                          ; FE8D 
  6281  ff3f e693               incsal: inc sal
  6282  ff41 d00e               	bne incr20
  6283  ff43 e694               	inc sah
  6284  ff45 d00a               	bne incr20
  6285  ff47 e695               	inc sas
  6286  ff49 a595               	lda sas
  6287  ff4b 8501               	sta i6509
  6288  ff4d a902               	lda #$02		; skip $0000 and $0001
  6289  ff4f 8593               	sta sal
  6290  ff51 60                 incr20:	rts
  6291                          
  6292                          patch2:				; ********** cbmii revision -03 PATCH  ACIA-IRQ routine **********
  6293  ff52 ad00dd             	lda acia+drsn
  6294  ff55 91a6               	sta (ribuf),y		; data to buffer
  6295  ff57 60                 	rts
  6296                          }
  6297                          !ifdef SRAMPATCH{		; ********** SRAM Patch - checks warm flags reliable **********
  6298  ff58 a95a               chkwarm:lda #winit
  6299  ff5a cdfb03             	cmp evect+3		; check winit ?
  6300  ff5d d003               	bne xcold		; no -> cold start
  6301  ff5f 4cfbf9             	jmp swarm		; yes -> warm start
  6302                          
  6303  ff62 4cadf9             xcold:	jmp scold
  6304                          }
  6305                          ; -------------------------------------------------------------------------------------------------
  6306                          ; ##### vectors #####
  6307                          ; FF6F (FF6C) Jump table kernal functions
  6308                          !ifdef CBMPATCH{		; ********** cbmii revision -03 PATCH **********
  6309                          *= $FF6C
  6310  ff6c 4c9dfe             newsys:	jmp txjmp		; Transfer-of-execution jumper
  6311                          }
  6312                          *= $FF6F
  6313  ff6f 4cd9fb             	jmp vreset		; Power-on/off vector reset
  6314  ff72 4c41fe             ipcgov:	jmp ipcgo		; Loop for ipc system
  6315  ff75 4c22e0             	jmp jfunky		; Function key vector
  6316  ff78 4cb9fc             	jmp iprqst		; Send ipc request
  6317  ff7b 4cfef9             	jmp ioinit		; I/O initialization
  6318  ff7e 4c04e0             	jmp jcint		; Screen initialization
  6319  ff81 4c07f4             aloca:	jmp alocat		; Allocation routine
  6320  ff84 4cb8fb             	jmp vector		; read/set I/O vectors
  6321  ff87 4cb1fb             	jmp restor		; restore I/O vectors
  6322  ff8a 4c67f6             	jmp lkupsa		; Match sa--return sa,fa
  6323  ff8d 4c7ff6             	jmp lkupla		; Match la--return sa,fa
  6324  ff90 4c69fb             	jmp setmsg		; Control o.s. messages
  6325  ff93 6c2403             secnd:	jmp (isecnd)		; Send sa after listen
  6326  ff96 6c2603             tksa:	jmp (itksa)		; Send sa after talk
  6327  ff99 4c87fb             	jmp memtop		; set/read top of memory
  6328  ff9c 4c9cfb             	jmp membot		; set/read bottom of memory
  6329  ff9f 4c13e0             	jmp jkey		; Scan keyboard
  6330  ffa2 4c83fb             	jmp settmo		; set timeout in IEEE
  6331  ffa5 6c2803             acptr:	jmp (iacptr)		; Handshake IEEE byte in
  6332  ffa8 6c2a03             ciout:	jmp (iciout)		; Handshake IEEE byte out
  6333  ffab 6c2c03             untlk:	jmp (iuntlk)		; Send untalk out IEEE
  6334  ffae 6c2e03             unlsn:	jmp (iunlsn)		; Send unlisten out IEEE
  6335  ffb1 6c3003             listn:	jmp (ilistn)		; Send listen out IEEE
  6336  ffb4 6c3203             talk:	jmp (italk)		; Send talk out IEEE
  6337  ffb7 4c56fb             	jmp readst		; read/write I/O status byte
  6338  ffba 4c4ffb             	jmp setlfs		; set la, fa, sa
  6339  ffbd 4c40fb             	jmp setnam		; set length and fn adr
  6340  ffc0 6c0603             open:	jmp (iopen)		; Open logical file/transmit command
  6341  ffc3 6c0803             close:	jmp (iclose)		; Close logical file
  6342  ffc6 6c0a03             chkin:	jmp (ichkin)		; Open channel in
  6343  ffc9 6c0c03             ckout:	jmp (ickout)		; Open channel out
  6344  ffcc 6c0e03             clrch:	jmp (iclrch)		; Close I/O channel
  6345  ffcf 6c1003             basin:	jmp (ibasin)		; Input from channel
  6346  ffd2 6c1203             bsout:	jmp (ibsout)		; Output to channel
  6347  ffd5 6c1a03             load:	jmp (iload)		; Load from file
  6348  ffd8 6c1c03             save:	jmp (isave)		; Save to file
  6349  ffdb 4c15f9             	jmp settim		; Set internal clock
  6350  ffde 4cedf8             	jmp rdtim		; read internal clock
  6351  ffe1 6c1403             stop: 	jmp (istop)		; scan stop key
  6352  ffe4 6c1603             getin:	jmp (igetin)		; Get char from q
  6353  ffe7 6c1803             clall:	jmp (iclall)		; Close all files
  6354  ffea 4c80f9             	jmp udtim		; increment clock
  6355  ffed 4c10e0             	jmp jscror		; Screen org
  6356  fff0 4c19e0             	jmp jplot		; read/set x,y coord
  6357  fff3 4c1ce0             	jmp jiobas		; return I/O base
  6358                          ; -------------------------------------------------------------------------------------------------
  6359                          ; FFF6 Actual execution segment switch routine
  6360  fff6 8500               gbye:	sta e6509		; goodbye...
  6361  fff8 60                 	rts
  6362                          
  6363                          *= $FFFA
  6364                          ; -------------------------------------------------------------------------------------------------
  6365                          ; FFFA Hardware vectors
  6366  fffa 3dfb               hwnmi:  !word nmi		; FB3D Program defineable
  6367  fffc 9ef9               	!word start		; F99E Initialization code
